<?xml version="1.0" encoding="utf-8" ?>
<plainxml>The 802.11 subsystems &amp;ndash; for kernel developers
Explaining wireless 802.11 networking in the Linux kernel
2007-2009Johannes BergJohannesBergjohannes@sipsolutions.net
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This documentation is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this documentation; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.


These books attempt to give a description of the
various subsystems that play a role in 802.11 wireless
networking in Linux. Since these books are for kernel
developers they attempts to document the structures
and functions used in the kernel as well as giving a
higher-level overview.

The reader is expected to be familiar with the 802.11
standard as published by the IEEE in 802.11-2007 (or
possibly later versions). References to this standard
will be given as &quot;802.11-2007 8.1.5&quot;.
The cfg80211 subsystem
Device registration

Actions and configuration
Scanning and BSS list handling
Utility functions
Data path helpers
Regulatory enforcement infrastructure
RFkill integration
Test mode
The mac80211 subsystem
&lt;!--
Generally, this document shall be ordered by increasing complexity.
It is important to note that readers should be able to read only
the first few sections to get a working driver and only advanced
usage should require reading the full document.
--&gt;The basic mac80211 driver interface
You should read and understand the information contained
within this part of the book while implementing a driver.
In some chapters, advanced usage is noted, that may be
skipped at first.

This part of the book only covers station and monitor mode
functionality, additional information required to implement
the other modes is covered in the second part of the book.
Basic hardware handlingTBD
This chapter shall contain information on getting a hw
struct allocated and registered with mac80211.

Since it is required to allocate rates/modes before registering
a hw struct, this chapter shall also contain information on setting
up the rate/mode structs.

Additionally, some discussion about the callbacks and
the general programming model should be in here, including
the definition of ieee80211_ops which will be referred to
a lot.

Finally, a discussion of hardware capabilities should be done
with references to other parts of the book.
&lt;!-- intentionally multiple !F lines to get proper order --&gt;
PHY configurationTBD
This chapter should describe PHY handling including
start/stop callbacks and the various structures used.

Virtual interfacesTBD
This chapter should describe virtual interface basics
that are relevant to the driver (VLANs, MGMT etc are not.)
It should explain the use of the add_iface/remove_iface
callbacks as well as the interface configuration callbacks.
Things related to AP mode should be discussed there.
Things related to supporting multiple interfaces should be
in the appropriate chapter, a BIG FAT note should be here about
this though and the recommendation to allow only a single
interface in STA mode at first!

Receive and transmit processingwhat should be hereTBD
This should describe the receive and transmit
paths in mac80211/the drivers as well as
transmit status handling.
Frame format
Packet alignment
Calling into mac80211 from interrupts
functions/definitions
Frame filtering
The mac80211 workqueue
Advanced driver interface
Information contained within this part of the book is
of interest only for advanced interaction of mac80211
with drivers to exploit more hardware capabilities and
improve performance.
LED support
Mac80211 supports various ways of blinking LEDs. Wherever possible,
device LEDs should be exposed as LED class devices and hooked up to
the appropriate trigger, which will then be triggered appropriately
by mac80211.

Hardware crypto acceleration
&lt;!-- intentionally multiple !F lines to get proper order --&gt;
Powersave support
Beacon filter support
Multiple queues and QoS supportTBD
Access point mode supportTBDSome parts of the if_conf should be discussed here instead
Insert notes about VLAN interfaces with hw crypto here or
in the hw crypto chapter.
support for powersaving clients

Supporting multiple virtual interfacesTBD
Note: WDS with identical MAC address should almost always be OK

Insert notes about having multiple virtual interfaces with
different MAC addresses here, note which configurations are
supported by mac80211, add notes about supporting hw crypto
with it.

Station handlingTODO
Hardware scan offloadTBD
AggregationTX A-MPDU aggregation
RX A-MPDU aggregation

Spatial Multiplexing Powersave (SMPS)
Rate control interfaceTBD
This part of the book describes the rate control algorithm
interface and how it relates to mac80211 and drivers.
Rate Control APITBD
InternalsTBD
This part of the book describes mac80211 internals.
Key handlingKey handling basics
MORE TBDTBDReceive processingTBDTransmit processingTBDStation info handlingProgramming information
STA information lifetime rules
Aggregation STA


SynchronisationTBDLocking, lots of RCUThe 802.11 subsystems &amp;ndash; for kernel developers
Explaining wireless 802.11 networking in the Linux kernel
2007-2009Johannes BergJohannesBergjohannes@sipsolutions.net
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This documentation is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this documentation; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.


These books attempt to give a description of the
various subsystems that play a role in 802.11 wireless
networking in Linux. Since these books are for kernel
developers they attempts to document the structures
and functions used in the kernel as well as giving a
higher-level overview.

The reader is expected to be familiar with the 802.11
standard as published by the IEEE in 802.11-2007 (or
possibly later versions). References to this standard
will be given as &quot;802.11-2007 8.1.5&quot;.
The cfg80211 subsystem
Device registration

Actions and configuration
Scanning and BSS list handling
Utility functions
Data path helpers
Regulatory enforcement infrastructure
RFkill integration
Test mode
The mac80211 subsystem
&lt;!--
Generally, this document shall be ordered by increasing complexity.
It is important to note that readers should be able to read only
the first few sections to get a working driver and only advanced
usage should require reading the full document.
--&gt;The basic mac80211 driver interface
You should read and understand the information contained
within this part of the book while implementing a driver.
In some chapters, advanced usage is noted, that may be
skipped at first.

This part of the book only covers station and monitor mode
functionality, additional information required to implement
the other modes is covered in the second part of the book.
Basic hardware handlingTBD
This chapter shall contain information on getting a hw
struct allocated and registered with mac80211.

Since it is required to allocate rates/modes before registering
a hw struct, this chapter shall also contain information on setting
up the rate/mode structs.

Additionally, some discussion about the callbacks and
the general programming model should be in here, including
the definition of ieee80211_ops which will be referred to
a lot.

Finally, a discussion of hardware capabilities should be done
with references to other parts of the book.
&lt;!-- intentionally multiple !F lines to get proper order --&gt;
PHY configurationTBD
This chapter should describe PHY handling including
start/stop callbacks and the various structures used.

Virtual interfacesTBD
This chapter should describe virtual interface basics
that are relevant to the driver (VLANs, MGMT etc are not.)
It should explain the use of the add_iface/remove_iface
callbacks as well as the interface configuration callbacks.
Things related to AP mode should be discussed there.
Things related to supporting multiple interfaces should be
in the appropriate chapter, a BIG FAT note should be here about
this though and the recommendation to allow only a single
interface in STA mode at first!

Receive and transmit processingwhat should be hereTBD
This should describe the receive and transmit
paths in mac80211/the drivers as well as
transmit status handling.
Frame format
Packet alignment
Calling into mac80211 from interrupts
functions/definitions
Frame filtering
The mac80211 workqueue
Advanced driver interface
Information contained within this part of the book is
of interest only for advanced interaction of mac80211
with drivers to exploit more hardware capabilities and
improve performance.
LED support
Mac80211 supports various ways of blinking LEDs. Wherever possible,
device LEDs should be exposed as LED class devices and hooked up to
the appropriate trigger, which will then be triggered appropriately
by mac80211.

Hardware crypto acceleration
&lt;!-- intentionally multiple !F lines to get proper order --&gt;
Powersave support
Beacon filter support
Multiple queues and QoS supportTBD
Access point mode supportTBDSome parts of the if_conf should be discussed here instead
Insert notes about VLAN interfaces with hw crypto here or
in the hw crypto chapter.
support for powersaving clients

Supporting multiple virtual interfacesTBD
Note: WDS with identical MAC address should almost always be OK

Insert notes about having multiple virtual interfaces with
different MAC addresses here, note which configurations are
supported by mac80211, add notes about supporting hw crypto
with it.

Station handlingTODO
Hardware scan offloadTBD
AggregationTX A-MPDU aggregation
RX A-MPDU aggregation

Spatial Multiplexing Powersave (SMPS)
Rate control interfaceTBD
This part of the book describes the rate control algorithm
interface and how it relates to mac80211 and drivers.
Rate Control APITBD
InternalsTBD
This part of the book describes mac80211 internals.
Key handlingKey handling basics
MORE TBDTBDReceive processingTBDTransmit processingTBDStation info handlingProgramming information
STA information lifetime rules
Aggregation

SynchronisationTBDLocking, lots of RCU&lt;!-- ****************************************************** --&gt;&lt;!-- Header  --&gt;&lt;!-- ****************************************************** --&gt;The ALSA Driver API
This document is free; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA
Management of Cards and DevicesCard Management
Device Components
Module requests and Device File Entries
Memory Management Helpers
PCM APIPCM Core
PCM Format Helpers
PCM Memory Management
Control/Mixer APIGeneral Control Interface
AC97 Codec API
Virtual Master Control API
MIDI APIRaw MIDI API
MPU401-UART API
Proc Info APIProc Info Interface
Miscellaneous FunctionsHardware-Dependent Devices API
Jack Abstraction Layer API
ISA DMA Helpers
Other Helper Macros
Debug objects life timeThomasGleixnertglx@linutronix.de2008Thomas Gleixner
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
debugobjects is a generic infrastructure to track the life time
of kernel objects and validate the operations on those.

debugobjects is useful to check for the following error patterns:
Activation of uninitialized objectsInitialization of active objectsUsage of freed/destroyed objects

debugobjects is not changing the data structure of the real
object so it can be compiled in with a minimal runtime impact
and enabled on demand with a kernel command line option.
Howto use debugobjects
A kernel subsystem needs to provide a data structure which
describes the object type and add calls into the debug code at
appropriate places. The data structure to describe the object
type needs at minimum the name of the object type. Optional
functions can and should be provided to fixup detected problems
so the kernel can continue to work and the debug information can
be retrieved from a live system instead of hard core debugging
with serial consoles and stack trace transcripts from the
monitor.

The debug calls provided by debugobjects are:
debug_object_initdebug_object_init_on_stackdebug_object_activatedebug_object_deactivatedebug_object_destroydebug_object_freedebug_object_assert_init
Each of these functions takes the address of the real object and
a pointer to the object type specific debug description
structure.

Each detected error is reported in the statistics and a limited
number of errors are printk&#39;ed including a full stack trace.

The statistics are available via /sys/kernel/debug/debug_objects/stats.
They provide information about the number of warnings and the
number of successful fixups along with information about the
usage of the internal tracking objects and the state of the
internal tracking objects pool.
Debug functionsDebug object function reference
debug_object_init
This function is called whenever the initialization function
of a real object is called.

When the real object is already tracked by debugobjects it is
checked, whether the object can be initialized.  Initializing
is not allowed for active and destroyed objects. When
debugobjects detects an error, then it calls the fixup_init
function of the object type description structure if provided
by the caller. The fixup function can correct the problem
before the real initialization of the object happens. E.g. it
can deactivate an active object in order to prevent damage to
the subsystem.

When the real object is not yet tracked by debugobjects,
debugobjects allocates a tracker object for the real object
and sets the tracker object state to ODEBUG_STATE_INIT. It
verifies that the object is not on the callers stack. If it is
on the callers stack then a limited number of warnings
including a full stack trace is printk&#39;ed. The calling code
must use debug_object_init_on_stack() and remove the object
before leaving the function which allocated it. See next
section.
debug_object_init_on_stack
This function is called whenever the initialization function
of a real object which resides on the stack is called.

When the real object is already tracked by debugobjects it is
checked, whether the object can be initialized. Initializing
is not allowed for active and destroyed objects. When
debugobjects detects an error, then it calls the fixup_init
function of the object type description structure if provided
by the caller. The fixup function can correct the problem
before the real initialization of the object happens. E.g. it
can deactivate an active object in order to prevent damage to
the subsystem.

When the real object is not yet tracked by debugobjects
debugobjects allocates a tracker object for the real object
and sets the tracker object state to ODEBUG_STATE_INIT. It
verifies that the object is on the callers stack.

An object which is on the stack must be removed from the
tracker by calling debug_object_free() before the function
which allocates the object returns. Otherwise we keep track of
stale objects.
debug_object_activate
This function is called whenever the activation function of a
real object is called.

When the real object is already tracked by debugobjects it is
checked, whether the object can be activated.  Activating is
not allowed for active and destroyed objects. When
debugobjects detects an error, then it calls the
fixup_activate function of the object type description
structure if provided by the caller. The fixup function can
correct the problem before the real activation of the object
happens. E.g. it can deactivate an active object in order to
prevent damage to the subsystem.

When the real object is not yet tracked by debugobjects then
the fixup_activate function is called if available. This is
necessary to allow the legitimate activation of statically
allocated and initialized objects. The fixup function checks
whether the object is valid and calls the debug_objects_init()
function to initialize the tracking of this object.

When the activation is legitimate, then the state of the
associated tracker object is set to ODEBUG_STATE_ACTIVE.
debug_object_deactivate
This function is called whenever the deactivation function of
a real object is called.

When the real object is tracked by debugobjects it is checked,
whether the object can be deactivated. Deactivating is not
allowed for untracked or destroyed objects.

When the deactivation is legitimate, then the state of the
associated tracker object is set to ODEBUG_STATE_INACTIVE.
debug_object_destroy
This function is called to mark an object destroyed. This is
useful to prevent the usage of invalid objects, which are
still available in memory: either statically allocated objects
or objects which are freed later.

When the real object is tracked by debugobjects it is checked,
whether the object can be destroyed. Destruction is not
allowed for active and destroyed objects. When debugobjects
detects an error, then it calls the fixup_destroy function of
the object type description structure if provided by the
caller. The fixup function can correct the problem before the
real destruction of the object happens. E.g. it can deactivate
an active object in order to prevent damage to the subsystem.

When the destruction is legitimate, then the state of the
associated tracker object is set to ODEBUG_STATE_DESTROYED.
debug_object_free
This function is called before an object is freed.

When the real object is tracked by debugobjects it is checked,
whether the object can be freed. Free is not allowed for
active objects. When debugobjects detects an error, then it
calls the fixup_free function of the object type description
structure if provided by the caller. The fixup function can
correct the problem before the real free of the object
happens. E.g. it can deactivate an active object in order to
prevent damage to the subsystem.

Note that debug_object_free removes the object from the
tracker. Later usage of the object is detected by the other
debug checks.
debug_object_assert_init
This function is called to assert that an object has been
initialized.

When the real object is not tracked by debugobjects, it calls
fixup_assert_init of the object type description structure
provided by the caller, with the hardcoded object state
ODEBUG_NOT_AVAILABLE. The fixup function can correct the problem
by calling debug_object_init and other specific initializing
functions.

When the real object is already tracked by debugobjects it is
ignored.
Fixup functionsDebug object type description structure
fixup_init
This function is called from the debug code whenever a problem
in debug_object_init is detected. The function takes the
address of the object and the state which is currently
recorded in the tracker.

Called from debug_object_init when the object state is:
ODEBUG_STATE_ACTIVE

The function returns 1 when the fixup was successful,
otherwise 0. The return value is used to update the
statistics.

Note, that the function needs to call the debug_object_init()
function again, after the damage has been repaired in order to
keep the state consistent.
fixup_activate
This function is called from the debug code whenever a problem
in debug_object_activate is detected.

Called from debug_object_activate when the object state is:
ODEBUG_STATE_NOTAVAILABLEODEBUG_STATE_ACTIVE

The function returns 1 when the fixup was successful,
otherwise 0. The return value is used to update the
statistics.

Note that the function needs to call the debug_object_activate()
function again after the damage has been repaired in order to
keep the state consistent.

The activation of statically initialized objects is a special
case. When debug_object_activate() has no tracked object for
this object address then fixup_activate() is called with
object state ODEBUG_STATE_NOTAVAILABLE. The fixup function
needs to check whether this is a legitimate case of a
statically initialized object or not. In case it is it calls
debug_object_init() and debug_object_activate() to make the
object known to the tracker and marked active. In this case
the function should return 0 because this is not a real fixup.
fixup_destroy
This function is called from the debug code whenever a problem
in debug_object_destroy is detected.

Called from debug_object_destroy when the object state is:
ODEBUG_STATE_ACTIVE

The function returns 1 when the fixup was successful,
otherwise 0. The return value is used to update the
statistics.
fixup_free
This function is called from the debug code whenever a problem
in debug_object_free is detected. Further it can be called
from the debug checks in kfree/vfree, when an active object is
detected from the debug_check_no_obj_freed() sanity checks.

Called from debug_object_free() or debug_check_no_obj_freed()
when the object state is:
ODEBUG_STATE_ACTIVE

The function returns 1 when the fixup was successful,
otherwise 0. The return value is used to update the
statistics.
fixup_assert_init
This function is called from the debug code whenever a problem
in debug_object_assert_init is detected.

Called from debug_object_assert_init() with a hardcoded state
ODEBUG_STATE_NOTAVAILABLE when the object is not found in the
debug bucket.

The function returns 1 when the fixup was successful,
otherwise 0. The return value is used to update the
statistics.

Note, this function should make sure debug_object_init() is
called before returning.

The handling of statically initialized objects is a special
case. The fixup function should check if this is a legitimate
case of a statically initialized object or not. In this case only
debug_object_init() should be called to make the object known to
the tracker. Then the function should return 0 because this is not
a real fixup.
Known Bugs And Assumptions
None (knock on wood).
Linux Device Drivers
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Driver BasicsDriver Entry and Exit points
Atomic and pointer manipulation
Delaying, scheduling, and timer routines
Wait queues and Wake events
High-resolution timers
Workqueues and Kevents
Internal Functions
Kernel objects manipulation&lt;!--
X!Iinclude/linux/kobject.h
--&gt;
Kernel utility functions
Device Resource Management
Device drivers infrastructureThe Basic Device Driver-Model Structures
Device Drivers Base
&lt;!-- Cannot be included, because
attribute_container_add_class_device_adapter
and attribute_container_classdev_to_container
exceed allowed 44 characters maximum
X!Edrivers/base/attribute_container.c
--&gt;
&lt;!--
X!Edrivers/base/interface.c
--&gt;
Device Drivers DMA Management
Device Drivers Power Management
Device Drivers ACPI Support&lt;!-- Internal functions only
X!Edrivers/acpi/sleep/main.c
X!Edrivers/acpi/sleep/wakeup.c
X!Edrivers/acpi/motherboard.c
X!Edrivers/acpi/bus.c
--&gt;
&lt;!-- No correct structured comments
X!Edrivers/acpi/pci_bind.c
--&gt;
Device drivers PnP support
&lt;!-- No correct structured comments
X!Edrivers/pnp/system.c
--&gt;
Userspace IO devices
Parallel Port Devices
Message-based devicesFusion message devices
I2O message devices
Sound Devices
&lt;!-- FIXME: Removed for now since no structured comments in source
X!Isound/sound_firmware.c
--&gt;
16x50 UART Driver
Frame Buffer Library
The frame buffer drivers depend heavily on four data structures.
These structures are declared in include/linux/fb.h.  They are
fb_info, fb_var_screeninfo, fb_fix_screeninfo and fb_monospecs.
The last three can be made available to and from userland.

fb_info defines the current state of a particular video card.
Inside fb_info, there exists a fb_ops structure which is a
collection of needed functions to make fbdev and fbcon work.
fb_info is only visible to the kernel.

fb_var_screeninfo is used to describe the features of a video card
that are user defined.  With fb_var_screeninfo, things such as
depth and the resolution may be defined.

The next structure is fb_fix_screeninfo. This defines the
properties of a card that are created when a mode is set and can&#39;t
be changed otherwise.  A good example of this is the start of the
frame buffer memory.  This &quot;locks&quot; the address of the frame buffer
memory, so that it cannot be changed or moved.

The last structure is fb_monospecs. In the old API, there was
little importance for fb_monospecs. This allowed for forbidden things
such as setting a mode of 800x600 on a fix frequency monitor. With
the new API, fb_monospecs prevents such things, and if used
correctly, can prevent a monitor from being cooked.  fb_monospecs
will not be useful until kernels 2.5.x.
Frame Buffer Memory
&lt;!--
&lt;sect1&gt;&lt;title&gt;Frame Buffer Console&lt;/title&gt;
X!Edrivers/video/console/fbcon.c
&lt;/sect1&gt;
--&gt;Frame Buffer Colormap
&lt;!-- FIXME:
drivers/video/fbgen.c has no docs, which stuffs up the sgml.  Comment
out until somebody adds docs.  KAO
&lt;sect1&gt;&lt;title&gt;Frame Buffer Generic Functions&lt;/title&gt;
X!Idrivers/video/fbgen.c
&lt;/sect1&gt;
KAO --&gt;Frame Buffer Video Mode Database
Frame Buffer Macintosh Video Mode Database
Frame Buffer Fonts
Refer to the file lib/fonts/fonts.c for more information.
&lt;!-- FIXME: Removed for now since no structured comments in source
X!Ilib/fonts/fonts.c
--&gt;Input SubsystemInput core
Multitouch Library
Polled input devices
Matrix keyboars/keypads
Sparse keymap support
Serial Peripheral Interface (SPI)
SPI is the &quot;Serial Peripheral Interface&quot;, widely used with
embedded systems because it is a simple and efficient
interface:  basically a multiplexed shift register.
Its three signal wires hold a clock (SCK, often in the range
of 1-20 MHz), a &quot;Master Out, Slave In&quot; (MOSI) data line, and
a &quot;Master In, Slave Out&quot; (MISO) data line.
SPI is a full duplex protocol; for each bit shifted out the
MOSI line (one per clock) another is shifted in on the MISO line.
Those bits are assembled into words of various sizes on the
way to and from system memory.
An additional chipselect line is usually active-low (nCS);
four signals are normally used for each peripheral, plus
sometimes an interrupt.

The SPI bus facilities listed here provide a generalized
interface to declare SPI busses and devices, manage them
according to the standard Linux driver model, and perform
input/output operations.
At this time, only &quot;master&quot; side interfaces are supported,
where Linux talks to SPI peripherals and does not implement
such a peripheral itself.
(Interfaces to support implementing SPI slaves would
necessarily look different.)

The programming interface is structured around two kinds of driver,
and two kinds of device.
A &quot;Controller Driver&quot; abstracts the controller hardware, which may
be as simple as a set of GPIO pins or as complex as a pair of FIFOs
connected to dual DMA engines on the other side of the SPI shift
register (maximizing throughput).  Such drivers bridge between
whatever bus they sit on (often the platform bus) and SPI, and
expose the SPI side of their device as a
struct spi_master.
SPI devices are children of that master, represented as a
struct spi_device and manufactured from
struct spi_board_info descriptors which
are usually provided by board-specific initialization code.
A struct spi_driver is called a
&quot;Protocol Driver&quot;, and is bound to a spi_device using normal
driver model calls.

The I/O model is a set of queued messages.  Protocol drivers
submit one or more struct spi_message
objects, which are processed and completed asynchronously.
(There are synchronous wrappers, however.)  Messages are
built from one or more struct spi_transfer
objects, each of which wraps a full duplex SPI transfer.
A variety of protocol tweaking options are needed, because
different chips adopt very different policies for how they
use the bits transferred with SPI.

I2C and SMBus Subsystem
I2C (or without fancy typography, &quot;I2C&quot;)
is an acronym for the &quot;Inter-IC&quot; bus, a simple bus protocol which is
widely used where low data rate communications suffice.
Since it&#39;s also a licensed trademark, some vendors use another
name (such as &quot;Two-Wire Interface&quot;, TWI) for the same bus.
I2C only needs two signals (SCL for clock, SDA for data), conserving
board real estate and minimizing signal quality issues.
Most I2C devices use seven bit addresses, and bus speeds of up
to 400 kHz; there&#39;s a high speed extension (3.4 MHz) that&#39;s not yet
found wide use.
I2C is a multi-master bus; open drain signaling is used to
arbitrate between masters, as well as to handshake and to
synchronize clocks from slower clients.

The Linux I2C programming interfaces support only the master
side of bus interactions, not the slave side.
The programming interface is structured around two kinds of driver,
and two kinds of device.
An I2C &quot;Adapter Driver&quot; abstracts the controller hardware; it binds
to a physical device (perhaps a PCI device or platform_device) and
exposes a struct i2c_adapter representing
each I2C bus segment it manages.
On each I2C bus segment will be I2C devices represented by a
struct i2c_client.  Those devices will
be bound to a struct i2c_driver,
which should follow the standard Linux driver model.
(At this writing, a legacy model is more widely used.)
There are functions to perform various I2C protocol operations; at
this writing all such functions are usable only from task context.

The System Management Bus (SMBus) is a sibling protocol.  Most SMBus
systems are also I2C conformant.  The electrical constraints are
tighter for SMBus, and it standardizes particular protocol messages
and idioms.  Controllers that support I2C can also support most
SMBus operations, but SMBus controllers don&#39;t support all the protocol
options that an I2C controller will.
There are functions to perform various SMBus protocol operations,
either using I2C primitives or by issuing SMBus commands to
i2c_adapter devices which don&#39;t support those I2C operations.


High Speed Synchronous Serial Interface (HSI)
High Speed Synchronous Serial Interface (HSI) is a
serial interface mainly used for connecting application
engines (APE) with cellular modem engines (CMT) in cellular
handsets.

HSI provides multiplexing for up to 16 logical channels,
low-latency and full duplex communication.


Bus-Independent Device AccessesMatthewWilcoxmatthew@wil.cxAlanCoxalan@lxorguk.ukuu.org.uk2001Matthew Wilcox
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
Linux provides an API which abstracts performing IO across all busses
and devices, allowing device drivers to be written independently of
bus type.
Known Bugs And Assumptions
None.
Memory Mapped IOGetting Access to the Device
The most widely supported form of IO is memory mapped IO.
That is, a part of the CPU&#39;s address space is interpreted
not as accesses to memory, but as accesses to a device.  Some
architectures define devices to be at a fixed address, but most
have some method of discovering devices.  The PCI bus walk is a
good example of such a scheme.    This document does not cover how
to receive such an address, but assumes you are starting with one.
Physical addresses are of type unsigned long.

This address should not be used directly.  Instead, to get an
address suitable for passing to the accessor functions described
below, you should call ioremap.
An address suitable for accessing the device will be returned to you.

After you&#39;ve finished using the device (say, in your module&#39;s
exit routine), call iounmap in order to return
the address space to the kernel.  Most architectures allocate new
address space each time you call ioremap, and
they can run out unless you call iounmap.
Accessing the device
The part of the interface most used by drivers is reading and
writing memory-mapped registers on the device.    Linux provides
interfaces to read and write 8-bit, 16-bit, 32-bit and 64-bit
quantities.  Due to a historical accident, these are named byte,
word, long and quad accesses.  Both read and write accesses are
supported; there is no prefetch support at this time.

The functions are named readb,
readw, readl,
readq, readb_relaxed,
readw_relaxed, readl_relaxed,
readq_relaxed, writeb,
writew, writel and
writeq.

Some devices (such as framebuffers) would like to use larger
transfers than 8 bytes at a time.  For these devices, the
memcpy_toio, memcpy_fromio
and memset_io functions are provided.
Do not use memset or memcpy on IO addresses; they
are not guaranteed to copy data in order.

The read and write functions are defined to be ordered. That is the
compiler is not permitted to reorder the I/O sequence. When the
ordering can be compiler optimised, you can use
__readb and friends to indicate the relaxed ordering. Use
this with care.

While the basic functions are defined to be synchronous with respect
to each other and ordered with respect to each other the busses the
devices sit on may themselves have asynchronicity. In particular many
authors are burned by the fact that PCI bus writes are posted
asynchronously. A driver author must issue a read from the same
device to ensure that writes have occurred in the specific cases the
author cares. This kind of property cannot be hidden from driver
writers in the API.  In some cases, the read used to flush the device
may be expected to fail (if the card is resetting, for example).  In
that case, the read should be done from config space, which is
guaranteed to soft-fail if the card doesn&#39;t respond.

The following is an example of flushing a write to a device when
the driver would like to ensure the write&#39;s effects are visible prior
to continuing execution.

static inline void
qla1280_disable_intrs(struct scsi_qla_host *ha)
{
struct device_reg *reg;

reg = ha-&amp;gt;iobase;
/* disable risc and host interrupts */
WRT_REG_WORD(&amp;amp;reg-&amp;gt;ictrl, 0);
/*
* The following read will ensure that the above write
* has been received by the device before we return from this
* function.
*/
RD_REG_WORD(&amp;amp;reg-&amp;gt;ictrl);
ha-&amp;gt;flags.ints_enabled = 0;
}

In addition to write posting, on some large multiprocessing systems
(e.g. SGI Challenge, Origin and Altix machines) posted writes won&#39;t
be strongly ordered coming from different CPUs.  Thus it&#39;s important
to properly protect parts of your driver that do memory-mapped writes
with locks and use the mmiowb to make sure they
arrive in the order intended.  Issuing a regular readX
will also ensure write ordering, but should only be used
when the driver has to be sure that the write has actually arrived
at the device (not that it&#39;s simply ordered with respect to other
writes), since a full readX is a relatively
expensive operation.

Generally, one should use mmiowb prior to
releasing a spinlock that protects regions using writeb
or similar functions that aren&#39;t surrounded by
readb calls, which will ensure ordering and flushing.  The
following pseudocode illustrates what might occur if write ordering
isn&#39;t guaranteed via mmiowb or one of the
readX functions.

CPU A:  spin_lock_irqsave(&amp;amp;dev_lock, flags)
CPU A:  ...
CPU A:  writel(newval, ring_ptr);
CPU A:  spin_unlock_irqrestore(&amp;amp;dev_lock, flags)
...
CPU B:  spin_lock_irqsave(&amp;amp;dev_lock, flags)
CPU B:  writel(newval2, ring_ptr);
CPU B:  ...
CPU B:  spin_unlock_irqrestore(&amp;amp;dev_lock, flags)

In the case above, newval2 could be written to ring_ptr before
newval.  Fixing it is easy though:

CPU A:  spin_lock_irqsave(&amp;amp;dev_lock, flags)
CPU A:  ...
CPU A:  writel(newval, ring_ptr);
CPU A:  mmiowb(); /* ensure no other writes beat us to the device */
CPU A:  spin_unlock_irqrestore(&amp;amp;dev_lock, flags)
...
CPU B:  spin_lock_irqsave(&amp;amp;dev_lock, flags)
CPU B:  writel(newval2, ring_ptr);
CPU B:  ...
CPU B:  mmiowb();
CPU B:  spin_unlock_irqrestore(&amp;amp;dev_lock, flags)

See tg3.c for a real world example of how to use mmiowb


PCI ordering rules also guarantee that PIO read responses arrive
after any outstanding DMA writes from that bus, since for some devices
the result of a readb call may signal to the
driver that a DMA transaction is complete.  In many cases, however,
the driver may want to indicate that the next
readb call has no relation to any previous DMA
writes performed by the device.  The driver can use
readb_relaxed for these cases, although only
some platforms will honor the relaxed semantics.  Using the relaxed
read functions will provide significant performance benefits on
platforms that support it.  The qla2xxx driver provides examples
of how to use readX_relaxed.  In many cases,
a majority of the driver&#39;s readX calls can
safely be converted to readX_relaxed calls, since
only a few will indicate or depend on DMA completion.
Port Space AccessesPort Space Explained
Another form of IO commonly supported is Port Space.  This is a
range of addresses separate to the normal memory address space.
Access to these addresses is generally not as fast as accesses
to the memory mapped addresses, and it also has a potentially
smaller address space.

Unlike memory mapped IO, no preparation is required
to access port space.
Accessing Port Space
Accesses to this space are provided through a set of functions
which allow 8-bit, 16-bit and 32-bit accesses; also
known as byte, word and long.  These functions are
inb, inw,
inl, outb,
outw and outl.

Some variants are provided for these functions.  Some devices
require that accesses to their ports are slowed down.  This
functionality is provided by appending a _p
to the end of the function.  There are also equivalents to memcpy.
The ins and outs
functions copy bytes, words or longs to the given port.
Public Functions Provided
Linux DRM Developer&#39;s GuideJesseBarnesInitial versionIntel Corporationjesse.barnes@intel.comLaurentPinchartDriver internalsIdeas on board SPRLlaurent.pinchart@ideasonboard.com2008-20092012Intel CorporationLaurent Pinchart
The contents of this file may be used under the terms of the GNU
General Public License version 2 (the &quot;GPL&quot;) as distributed in
the kernel source COPYING file.
&lt;!-- Put document revisions here, newest first. --&gt;1.02012-07-13LPAdded extensive documentation about driver internals.
&lt;!-- Introduction --&gt;Introduction
The Linux DRM layer contains code intended to support the needs
of complex graphics devices, usually containing programmable
pipelines well suited to 3D graphics acceleration.  Graphics
drivers in the kernel may make use of DRM functions to make
tasks like memory management, interrupt handling and DMA easier,
and provide a uniform interface to applications.

A note on versions: this guide covers features found in the DRM
tree, including the TTM memory manager, output configuration and
mode setting, and the new vblank internals, in addition to all
the regular features found in current kernels.

[Insert diagram of typical DRM stack here]
&lt;!-- Internals --&gt;DRM Internals
This chapter documents DRM internals relevant to driver authors
and developers working to add support for the latest features to
existing drivers.

First, we go over some typical driver initialization
requirements, like setting up command buffers, creating an
initial output configuration, and initializing core services.
Subsequent sections cover core internals in more detail,
providing implementation notes and examples.

The DRM layer provides several services to graphics drivers,
many of them driven by the application interfaces it provides
through libdrm, the library that wraps most of the DRM ioctls.
These include vblank event handling, memory
management, output management, framebuffer management, command
submission &amp;amp; fencing, suspend/resume support, and DMA
services.
&lt;!-- Internals: driver init --&gt;Driver Initialization
At the core of every DRM driver is a drm_driver
structure. Drivers typically statically initialize a drm_driver structure,
and then pass it to one of the drm_*_init() functions
to register it with the DRM subsystem.

The drm_driver structure contains static
information that describes the driver and features it supports, and
pointers to methods that the DRM core will call to implement the DRM API.
We will first go through the drm_driver static
information fields, and will then describe individual operations in
details as they get used in later sections.
Driver InformationDriver Features
Drivers inform the DRM core about their requirements and supported
features by setting appropriate flags in the
driver_features field. Since those flags
influence the DRM core behaviour since registration time, most of them
must be set to registering the drm_driver
instance.
u32 driver_features;Driver Feature FlagsDRIVER_USE_AGP
Driver uses AGP interface, the DRM core will manage AGP resources.
DRIVER_REQUIRE_AGP
Driver needs AGP interface to function. AGP initialization failure
will become a fatal error.
DRIVER_PCI_DMA
Driver is capable of PCI DMA, mapping of PCI DMA buffers to
userspace will be enabled. Deprecated.
DRIVER_SG
Driver can perform scatter/gather DMA, allocation and mapping of
scatter/gather buffers will be enabled. Deprecated.
DRIVER_HAVE_DMA
Driver supports DMA, the userspace DMA API will be supported.
Deprecated.
DRIVER_HAVE_IRQDRIVER_IRQ_SHARED
DRIVER_HAVE_IRQ indicates whether the driver has an IRQ handler
managed by the DRM Core. The core will support simple IRQ handler
installation when the flag is set. The installation process is
described in .DRIVER_IRQ_SHARED indicates whether the device &amp;amp; handler
support shared IRQs (note that this is required of PCI  drivers).
DRIVER_GEM
Driver use the GEM memory manager.
DRIVER_MODESET
Driver supports mode setting interfaces (KMS).
DRIVER_PRIME
Driver implements DRM PRIME buffer sharing.
DRIVER_RENDER
Driver supports dedicated render nodes.
Major, Minor and Patchlevelint major;
int minor;
int patchlevel;
The DRM core identifies driver versions by a major, minor and patch
level triplet. The information is printed to the kernel log at
initialization time and passed to userspace through the
DRM_IOCTL_VERSION ioctl.

The major and minor numbers are also used to verify the requested driver
API version passed to DRM_IOCTL_SET_VERSION. When the driver API changes
between minor versions, applications can call DRM_IOCTL_SET_VERSION to
select a specific version of the API. If the requested major isn&#39;t equal
to the driver major, or the requested minor is larger than the driver
minor, the DRM_IOCTL_SET_VERSION call will return an error. Otherwise
the driver&#39;s set_version() method will be called with the requested
version.
Name, Description and Datechar *name;
char *desc;
char *date;
The driver name is printed to the kernel log at initialization time,
used for IRQ registration and passed to userspace through
DRM_IOCTL_VERSION.

The driver description is a purely informative string passed to
userspace through the DRM_IOCTL_VERSION ioctl and otherwise unused by
the kernel.

The driver date, formatted as YYYYMMDD, is meant to identify the date of
the latest modification to the driver. However, as most drivers fail to
update it, its value is mostly useless. The DRM core prints it to the
kernel log at initialization time and passes it to userspace through the
DRM_IOCTL_VERSION ioctl.
Driver Load
The load method is the driver and device
initialization entry point. The method is responsible for allocating and
initializing driver private data, specifying supported performance
counters, performing resource allocation and mapping (e.g. acquiring
clocks, mapping registers or allocating command buffers), initializing
the memory manager (), installing
the IRQ handler (), setting up
vertical blanking handling (), mode
setting () and initial output
configuration ().

If compatibility is a concern (e.g. with drivers converted over from
User Mode Setting to Kernel Mode Setting), care must be taken to prevent
device initialization and control that is incompatible with currently
active userspace drivers. For instance, if user level mode setting
drivers are in use, it would be problematic to perform output discovery
&amp;amp; configuration at load time. Likewise, if user-level drivers
unaware of memory management are in use, memory management and command
buffer setup may need to be omitted. These requirements are
driver-specific, and care needs to be taken to keep both old and new
applications and libraries working.
int (*load) (struct drm_device *, unsigned long flags);
The method takes two arguments, a pointer to the newly created
drm_device and flags. The flags are used to
pass the driver_data field of the device id
corresponding to the device passed to drm_*_init().
Only PCI devices currently use this, USB and platform DRM drivers have
their load method called with flags to 0.
Driver Private &amp;amp; Performance Counters
The driver private hangs off the main
drm_device structure and can be used for
tracking various device-specific bits of information, like register
offsets, command buffer status, register state for suspend/resume, etc.
At load time, a driver may simply allocate one and set
drm_device.dev_priv
appropriately; it should be freed and
drm_device.dev_priv
set to NULL when the driver is unloaded.

DRM supports several counters which were used for rough performance
characterization. This stat counter system is deprecated and should not
be used. If performance monitoring is desired, the developer should
investigate and potentially enhance the kernel perf and tracing
infrastructure to export GPU related performance information for
consumption by performance monitoring tools and applications.
IRQ Registration
The DRM core tries to facilitate IRQ handler registration and
unregistration by providing drm_irq_install and
drm_irq_uninstall functions. Those functions only
support a single interrupt per device, devices that use more than one
IRQs need to be handled manually.
Managed IRQ Registration
Both the drm_irq_install and
drm_irq_uninstall functions get the device IRQ by
calling drm_dev_to_irq. This inline function will
call a bus-specific operation to retrieve the IRQ number. For platform
devices, platform_get_irq(..., 0) is used to
retrieve the IRQ number.
drm_irq_install starts by calling the
irq_preinstall driver operation. The operation
is optional and must make sure that the interrupt will not get fired by
clearing all pending interrupt flags or disabling the interrupt.

The IRQ will then be requested by a call to
request_irq. If the DRIVER_IRQ_SHARED driver
feature flag is set, a shared (IRQF_SHARED) IRQ handler will be
requested.

The IRQ handler function must be provided as the mandatory irq_handler
driver operation. It will get passed directly to
request_irq and thus has the same prototype as all
IRQ handlers. It will get called with a pointer to the DRM device as the
second argument.

Finally the function calls the optional
irq_postinstall driver operation. The operation
usually enables interrupts (excluding the vblank interrupt, which is
enabled separately), but drivers may choose to enable/disable interrupts
at a different time.
drm_irq_uninstall is similarly used to uninstall an
IRQ handler. It starts by waking up all processes waiting on a vblank
interrupt to make sure they don&#39;t hang, and then calls the optional
irq_uninstall driver operation. The operation
must disable all hardware interrupts. Finally the function frees the IRQ
by calling free_irq.
Manual IRQ Registration
Drivers that require multiple interrupt handlers can&#39;t use the managed
IRQ registration functions. In that case IRQs must be registered and
unregistered manually (usually with the request_irq
and free_irq functions, or their devm_* equivalent).

When manually registering IRQs, drivers must not set the DRIVER_HAVE_IRQ
driver feature flag, and must not provide the
irq_handler driver operation. They must set the
drm_device irq_enabled
field to 1 upon registration of the IRQs, and clear it to 0 after
unregistering the IRQs.
Memory Manager Initialization
Every DRM driver requires a memory manager which must be initialized at
load time. DRM currently contains two memory managers, the Translation
Table Manager (TTM) and the Graphics Execution Manager (GEM).
This document describes the use of the GEM memory manager only. See
for details.
Miscellaneous Device Configuration
Another task that may be necessary for PCI devices during configuration
is mapping the video BIOS. On many devices, the VBIOS describes device
configuration, LCD panel timings (if any), and contains flags indicating
device state. Mapping the BIOS can be done using the pci_map_rom() call,
a convenience function that takes care of mapping the actual ROM,
whether it has been shadowed into memory (typically at address 0xc0000)
or exists on the PCI device in the ROM BAR. Note that after the ROM has
been mapped and any necessary information has been extracted, it should
be unmapped; on many devices, the ROM address decoder is shared with
other BARs, so leaving it mapped could cause undesired behaviour like
hangs or memory corruption.
&lt;!--!Fdrivers/pci/rom.c pci_map_rom--&gt;
&lt;!-- Internals: memory management --&gt;Memory management
Modern Linux systems require large amount of graphics memory to store
frame buffers, textures, vertices and other graphics-related data. Given
the very dynamic nature of many of that data, managing graphics memory
efficiently is thus crucial for the graphics stack and plays a central
role in the DRM infrastructure.

The DRM core includes two memory managers, namely Translation Table Maps
(TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory
manager to be developed and tried to be a one-size-fits-them all
solution. It provides a single userspace API to accommodate the need of
all hardware, supporting both Unified Memory Architecture (UMA) devices
and devices with dedicated video RAM (i.e. most discrete video cards).
This resulted in a large, complex piece of code that turned out to be
hard to use for driver development.

GEM started as an Intel-sponsored project in reaction to TTM&#39;s
complexity. Its design philosophy is completely different: instead of
providing a solution to every graphics memory-related problems, GEM
identified common code between drivers and created a support library to
share it. GEM has simpler initialization and execution requirements than
TTM, but has no video RAM management capabitilies and is thus limited to
UMA devices.
The Translation Table Manager (TTM)
TTM design background and information belongs here.
TTM initializationThis section is outdated.
Drivers wishing to support TTM must fill out a drm_bo_driver
structure. The structure contains several fields with function
pointers for initializing the TTM, allocating and freeing memory,
waiting for command completion and fence synchronization, and memory
migration. See the radeon_ttm.c file for an example of usage.

The ttm_global_reference structure is made up of several fields:

struct ttm_global_reference {
enum ttm_global_types global_type;
size_t size;
void *object;
int (*init) (struct ttm_global_reference *);
void (*release) (struct ttm_global_reference *);
};

There should be one global reference structure for your memory
manager as a whole, and there will be others for each object
created by the memory manager at runtime.  Your global TTM should
have a type of TTM_GLOBAL_TTM_MEM.  The size field for the global
object should be sizeof(struct ttm_mem_global), and the init and
release hooks should point at your driver-specific init and
release routines, which probably eventually call
ttm_mem_global_init and ttm_mem_global_release, respectively.

Once your global TTM accounting structure is set up and initialized
by calling ttm_global_item_ref() on it,
you need to create a buffer object TTM to
provide a pool for buffer object allocation by clients and the
kernel itself.  The type of this object should be TTM_GLOBAL_TTM_BO,
and its size should be sizeof(struct ttm_bo_global).  Again,
driver-specific init and release functions may be provided,
likely eventually calling ttm_bo_global_init() and
ttm_bo_global_release(), respectively.  Also, like the previous
object, ttm_global_item_ref() is used to create an initial reference
count for the TTM, which will call your initialization function.
The Graphics Execution Manager (GEM)
The GEM design approach has resulted in a memory manager that doesn&#39;t
provide full coverage of all (or even all common) use cases in its
userspace or kernel API. GEM exposes a set of standard memory-related
operations to userspace and a set of helper functions to drivers, and let
drivers implement hardware-specific operations with their own private API.

The GEM userspace API is described in the
GEM - the Graphics
Execution Manager article on LWN. While slightly
outdated, the document provides a good overview of the GEM API principles.
Buffer allocation and read and write operations, described as part of the
common GEM API, are currently implemented using driver-specific ioctls.

GEM is data-agnostic. It manages abstract buffer objects without knowing
what individual buffers contain. APIs that require knowledge of buffer
contents or purpose, such as buffer allocation or synchronization
primitives, are thus outside of the scope of GEM and must be implemented
using driver-specific ioctls.

On a fundamental level, GEM involves several operations:
Memory allocation and freeingCommand executionAperture management at command execution time
Buffer object allocation is relatively straightforward and largely
provided by Linux&#39;s shmem layer, which provides memory to back each
object.

Device-specific operations, such as command execution, pinning, buffer
read &amp;amp; write, mapping, and domain ownership transfers are left to
driver-specific ioctls.
GEM Initialization
Drivers that use GEM must set the DRIVER_GEM bit in the struct
drm_driver
driver_features field. The DRM core will
then automatically initialize the GEM core before calling the
load operation. Behind the scene, this will
create a DRM Memory Manager object which provides an address space
pool for object allocation.

In a KMS configuration, drivers need to allocate and initialize a
command ring buffer following core GEM initialization if required by
the hardware. UMA devices usually have what is called a &quot;stolen&quot;
memory region, which provides space for the initial framebuffer and
large, contiguous memory regions required by the device. This space is
typically not managed by GEM, and must be initialized separately into
its own DRM MM object.
GEM Objects Creation
GEM splits creation of GEM objects and allocation of the memory that
backs them in two distinct operations.

GEM objects are represented by an instance of struct
drm_gem_object. Drivers usually need to extend
GEM objects with private information and thus create a driver-specific
GEM object structure type that embeds an instance of struct
drm_gem_object.

To create a GEM object, a driver allocates memory for an instance of its
specific GEM object type and initializes the embedded struct
drm_gem_object with a call to
drm_gem_object_init. The function takes a pointer to
the DRM device, a pointer to the GEM object and the buffer object size
in bytes.

GEM uses shmem to allocate anonymous pageable memory.
drm_gem_object_init will create an shmfs file of
the requested size and store it into the struct
drm_gem_object filp
field. The memory is used as either main storage for the object when the
graphics hardware uses system memory directly or as a backing store
otherwise.

Drivers are responsible for the actual physical pages allocation by
calling shmem_read_mapping_page_gfp for each page.
Note that they can decide to allocate pages when initializing the GEM
object, or to delay allocation until the memory is needed (for instance
when a page fault occurs as a result of a userspace memory access or
when the driver needs to start a DMA transfer involving the memory).

Anonymous pageable memory allocation is not always desired, for instance
when the hardware requires physically contiguous system memory as is
often the case in embedded devices. Drivers can create GEM objects with
no shmfs backing (called private GEM objects) by initializing them with
a call to drm_gem_private_object_init instead of
drm_gem_object_init. Storage for private GEM
objects must be managed by drivers.

Drivers that do not need to extend GEM objects with private information
can call the drm_gem_object_alloc function to
allocate and initialize a struct drm_gem_object
instance. The GEM core will call the optional driver
gem_init_object operation after initializing
the GEM object with drm_gem_object_init.
int (*gem_init_object) (struct drm_gem_object *obj);

No alloc-and-init function exists for private GEM objects.
GEM Objects Lifetime
All GEM objects are reference-counted by the GEM core. References can be
acquired and release by calling drm_gem_object_reference
and drm_gem_object_unreference respectively. The
caller must hold the drm_device
struct_mutex lock. As a convenience, GEM
provides the drm_gem_object_reference_unlocked and
drm_gem_object_unreference_unlocked functions that
can be called without holding the lock.

When the last reference to a GEM object is released the GEM core calls
the drm_driver
gem_free_object operation. That operation is
mandatory for GEM-enabled drivers and must free the GEM object and all
associated resources.
void (*gem_free_object) (struct drm_gem_object *obj);
Drivers are responsible for freeing all GEM object resources, including
the resources created by the GEM core. If an mmap offset has been
created for the object (in which case
drm_gem_object::map_list::map
is not NULL) it must be freed by a call to
drm_gem_free_mmap_offset. The shmfs backing store
must be released by calling drm_gem_object_release
(that function can safely be called if no shmfs backing store has been
created).
GEM Objects Naming
Communication between userspace and the kernel refers to GEM objects
using local handles, global names or, more recently, file descriptors.
All of those are 32-bit integer values; the usual Linux kernel limits
apply to the file descriptors.

GEM handles are local to a DRM file. Applications get a handle to a GEM
object through a driver-specific ioctl, and can use that handle to refer
to the GEM object in other standard or driver-specific ioctls. Closing a
DRM file handle frees all its GEM handles and dereferences the
associated GEM objects.

To create a handle for a GEM object drivers call
drm_gem_handle_create. The function takes a pointer
to the DRM file and the GEM object and returns a locally unique handle.
When the handle is no longer needed drivers delete it with a call to
drm_gem_handle_delete. Finally the GEM object
associated with a handle can be retrieved by a call to
drm_gem_object_lookup.

Handles don&#39;t take ownership of GEM objects, they only take a reference
to the object that will be dropped when the handle is destroyed. To
avoid leaking GEM objects, drivers must make sure they drop the
reference(s) they own (such as the initial reference taken at object
creation time) as appropriate, without any special consideration for the
handle. For example, in the particular case of combined GEM object and
handle creation in the implementation of the
dumb_create operation, drivers must drop the
initial reference to the GEM object before returning the handle.

GEM names are similar in purpose to handles but are not local to DRM
files. They can be passed between processes to reference a GEM object
globally. Names can&#39;t be used directly to refer to objects in the DRM
API, applications must convert handles to names and names to handles
using the DRM_IOCTL_GEM_FLINK and DRM_IOCTL_GEM_OPEN ioctls
respectively. The conversion is handled by the DRM core without any
driver-specific support.

Similar to global names, GEM file descriptors are also used to share GEM
objects across processes. They offer additional security: as file
descriptors must be explicitly sent over UNIX domain sockets to be shared
between applications, they can&#39;t be guessed like the globally unique GEM
names.

Drivers that support GEM file descriptors, also known as the DRM PRIME
API, must set the DRIVER_PRIME bit in the struct
drm_driver
driver_features field, and implement the
prime_handle_to_fd and
prime_fd_to_handle operations.
int (*prime_handle_to_fd)(struct drm_device *dev,
struct drm_file *file_priv, uint32_t handle,
uint32_t flags, int *prime_fd);
int (*prime_fd_to_handle)(struct drm_device *dev,
struct drm_file *file_priv, int prime_fd,
uint32_t *handle);
Those two operations convert a handle to a PRIME file descriptor and
vice versa. Drivers must use the kernel dma-buf buffer sharing framework
to manage the PRIME file descriptors.

While non-GEM drivers must implement the operations themselves, GEM
drivers must use the drm_gem_prime_handle_to_fd
and drm_gem_prime_fd_to_handle helper functions.
Those helpers rely on the driver
gem_prime_export and
gem_prime_import operations to create a dma-buf
instance from a GEM object (dma-buf exporter role) and to create a GEM
object from a dma-buf instance (dma-buf importer role).
struct dma_buf * (*gem_prime_export)(struct drm_device *dev,
struct drm_gem_object *obj,
int flags);
struct drm_gem_object * (*gem_prime_import)(struct drm_device *dev,
struct dma_buf *dma_buf);
These two operations are mandatory for GEM drivers that support DRM
PRIME.
DRM PRIME Helper Functions Reference
GEM Objects Mapping
Because mapping operations are fairly heavyweight GEM favours
read/write-like access to buffers, implemented through driver-specific
ioctls, over mapping buffers to userspace. However, when random access
to the buffer is needed (to perform software rendering for instance),
direct access to the object can be more efficient.

The mmap system call can&#39;t be used directly to map GEM objects, as they
don&#39;t have their own file handle. Two alternative methods currently
co-exist to map GEM objects to userspace. The first method uses a
driver-specific ioctl to perform the mapping operation, calling
do_mmap under the hood. This is often considered
dubious, seems to be discouraged for new GEM-enabled drivers, and will
thus not be described here.

The second method uses the mmap system call on the DRM file handle.
void *mmap(void *addr, size_t length, int prot, int flags, int fd,
off_t offset);
DRM identifies the GEM object to be mapped by a fake offset passed
through the mmap offset argument. Prior to being mapped, a GEM object
must thus be associated with a fake offset. To do so, drivers must call
drm_gem_create_mmap_offset on the object. The
function allocates a fake offset range from a pool and stores the
offset divided by PAGE_SIZE in
obj-&amp;gt;map_list.hash.key. Care must be taken not to
call drm_gem_create_mmap_offset if a fake offset
has already been allocated for the object. This can be tested by
obj-&amp;gt;map_list.map being non-NULL.

Once allocated, the fake offset value
(obj-&amp;gt;map_list.hash.key &amp;lt;&amp;lt; PAGE_SHIFT)
must be passed to the application in a driver-specific way and can then
be used as the mmap offset argument.

The GEM core provides a helper method drm_gem_mmap
to handle object mapping. The method can be set directly as the mmap
file operation handler. It will look up the GEM object based on the
offset value and set the VMA operations to the
drm_driver gem_vm_ops
field. Note that drm_gem_mmap doesn&#39;t map memory to
userspace, but relies on the driver-provided fault handler to map pages
individually.

To use drm_gem_mmap, drivers must fill the struct
drm_driver gem_vm_ops
field with a pointer to VM operations.
struct vm_operations_struct *gem_vm_ops

struct vm_operations_struct {
void (*open)(struct vm_area_struct * area);
void (*close)(struct vm_area_struct * area);
int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
};
The open and close
operations must update the GEM object reference count. Drivers can use
the drm_gem_vm_open and
drm_gem_vm_close helper functions directly as open
and close handlers.

The fault operation handler is responsible for mapping individual pages
to userspace when a page fault occurs. Depending on the memory
allocation scheme, drivers can allocate pages at fault time, or can
decide to allocate memory for the GEM object at the time the object is
created.

Drivers that want to map the GEM object upfront instead of handling page
faults can implement their own mmap file operation handler.
Dumb GEM Objects
The GEM API doesn&#39;t standardize GEM objects creation and leaves it to
driver-specific ioctls. While not an issue for full-fledged graphics
stacks that include device-specific userspace components (in libdrm for
instance), this limit makes DRM-based early boot graphics unnecessarily
complex.

Dumb GEM objects partly alleviate the problem by providing a standard
API to create dumb buffers suitable for scanout, which can then be used
to create KMS frame buffers.

To support dumb GEM objects drivers must implement the
dumb_create,
dumb_destroy and
dumb_map_offset operations.
int (*dumb_create)(struct drm_file *file_priv, struct drm_device *dev,
struct drm_mode_create_dumb *args);
The dumb_create operation creates a GEM
object suitable for scanout based on the width, height and depth
from the struct drm_mode_create_dumb
argument. It fills the argument&#39;s handle,
pitch and size
fields with a handle for the newly created GEM object and its line
pitch and size in bytes.
int (*dumb_destroy)(struct drm_file *file_priv, struct drm_device *dev,
uint32_t handle);
The dumb_destroy operation destroys a dumb
GEM object created by dumb_create.
int (*dumb_map_offset)(struct drm_file *file_priv, struct drm_device *dev,
uint32_t handle, uint64_t *offset);
The dumb_map_offset operation associates an
mmap fake offset with the GEM object given by the handle and returns
it. Drivers must use the
drm_gem_create_mmap_offset function to
associate the fake offset as described in
.
Memory Coherency
When mapped to the device or used in a command buffer, backing pages
for an object are flushed to memory and marked write combined so as to
be coherent with the GPU. Likewise, if the CPU accesses an object
after the GPU has finished rendering to the object, then the object
must be made coherent with the CPU&#39;s view of memory, usually involving
GPU cache flushing of various kinds. This core CPU&amp;lt;-&amp;gt;GPU
coherency management is provided by a device-specific ioctl, which
evaluates an object&#39;s current domain and performs any necessary
flushing or synchronization to put the object into the desired
coherency domain (note that the object may be busy, i.e. an active
render target; in that case, setting the domain blocks the client and
waits for rendering to complete before performing any necessary
flushing operations).
Command Execution
Perhaps the most important GEM function for GPU devices is providing a
command execution interface to clients. Client programs construct
command buffers containing references to previously allocated memory
objects, and then submit them to GEM. At that point, GEM takes care to
bind all the objects into the GTT, execute the buffer, and provide
necessary synchronization between clients accessing the same buffers.
This often involves evicting some objects from the GTT and re-binding
others (a fairly expensive operation), and providing relocation
support which hides fixed GTT offsets from clients. Clients must take
care not to submit command buffers that reference more objects than
can fit in the GTT; otherwise, GEM will reject them and no rendering
will occur. Similarly, if several objects in the buffer require fence
registers to be allocated for correct rendering (e.g. 2D blits on
pre-965 chips), care must be taken not to require more fence registers
than are available to the client. Such resource management should be
abstracted from the client in libdrm.
&lt;!-- Internals: mode setting --&gt;Mode Setting
Drivers must initialize the mode setting core by calling
drm_mode_config_init on the DRM device. The function
initializes the drm_device
mode_config field and never fails. Once done,
mode configuration must be setup by initializing the following fields.
int min_width, min_height;
int max_width, max_height;
Minimum and maximum width and height of the frame buffers in pixel
units.
struct drm_mode_config_funcs *funcs;Mode setting functions.Frame Buffer Creationstruct drm_framebuffer *(*fb_create)(struct drm_device *dev,
struct drm_file *file_priv,
struct drm_mode_fb_cmd2 *mode_cmd);
Frame buffers are abstract memory objects that provide a source of
pixels to scanout to a CRTC. Applications explicitly request the
creation of frame buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and
receive an opaque handle that can be passed to the KMS CRTC control,
plane configuration and page flip functions.

Frame buffers rely on the underneath memory manager for low-level memory
operations. When creating a frame buffer applications pass a memory
handle (or a list of memory handles for multi-planar formats) through
the drm_mode_fb_cmd2 argument. This document
assumes that the driver uses GEM, those handles thus reference GEM
objects.

Drivers must first validate the requested frame buffer parameters passed
through the mode_cmd argument. In particular this is where invalid
sizes, pixel formats or pitches can be caught.

If the parameters are deemed valid, drivers then create, initialize and
return an instance of struct drm_framebuffer.
If desired the instance can be embedded in a larger driver-specific
structure. Drivers must fill its width,
height, pitches,
offsets, depth,
bits_per_pixel and
pixel_format fields from the values passed
through the drm_mode_fb_cmd2 argument. They
should call the drm_helper_mode_fill_fb_struct
helper function to do so.

The initailization of the new framebuffer instance is finalized with a
call to drm_framebuffer_init which takes a pointer
to DRM frame buffer operations (struct
drm_framebuffer_funcs). Note that this function
publishes the framebuffer and so from this point on it can be accessed
concurrently from other threads. Hence it must be the last step in the
driver&#39;s framebuffer initialization sequence. Frame buffer operations
are
int (*create_handle)(struct drm_framebuffer *fb,
struct drm_file *file_priv, unsigned int *handle);
Create a handle to the frame buffer underlying memory object. If
the frame buffer uses a multi-plane format, the handle will
reference the memory object associated with the first plane.

Drivers call drm_gem_handle_create to create
the handle.
void (*destroy)(struct drm_framebuffer *framebuffer);
Destroy the frame buffer object and frees all associated
resources. Drivers must call
drm_framebuffer_cleanup to free resources
allocated by the DRM core for the frame buffer object, and must
make sure to unreference all memory objects associated with the
frame buffer. Handles created by the
create_handle operation are released by
the DRM core.
int (*dirty)(struct drm_framebuffer *framebuffer,
struct drm_file *file_priv, unsigned flags, unsigned color,
struct drm_clip_rect *clips, unsigned num_clips);
This optional operation notifies the driver that a region of the
frame buffer has changed in response to a DRM_IOCTL_MODE_DIRTYFB
ioctl call.


The lifetime of a drm framebuffer is controlled with a reference count,
drivers can grab additional references with
drm_framebuffer_reference  and drop them
again with drm_framebuffer_unreference. For
driver-private framebuffers for which the last reference is never
dropped (e.g. for the fbdev framebuffer when the struct
drm_framebuffer is embedded into the fbdev
helper struct) drivers can manually clean up a framebuffer at module
unload time with
drm_framebuffer_unregister_private.
Output Pollingvoid (*output_poll_changed)(struct drm_device *dev);
This operation notifies the driver that the status of one or more
connectors has changed. Drivers that use the fb helper can just call the
drm_fb_helper_hotplug_event function to handle this
operation.
Locking
Beside some lookup structures with their own locking (which is hidden
behind the interface functions) most of the modeset state is protected
by the dev-&amp;lt;mode_config.lock mutex and additionally
per-crtc locks to allow cursor updates, pageflips and similar operations
to occur concurrently with background tasks like output detection.
Operations which cross domains like a full modeset always grab all
locks. Drivers there need to protect resources shared between crtcs with
additional locking. They also need to be careful to always grab the
relevant crtc locks if a modset functions touches crtc state, e.g. for
load detection (which does only grab the mode_config.lock
to allow concurrent screen updates on live crtcs).
&lt;!-- Internals: kms initialization and cleanup --&gt;KMS Initialization and Cleanup
A KMS device is abstracted and exposed as a set of planes, CRTCs, encoders
and connectors. KMS drivers must thus create and initialize all those
objects at load time after initializing mode setting.
CRTCs (struct drm_crtc)
A CRTC is an abstraction representing a part of the chip that contains a
pointer to a scanout buffer. Therefore, the number of CRTCs available
determines how many independent scanout buffers can be active at any
given time. The CRTC structure contains several fields to support this:
a pointer to some video memory (abstracted as a frame buffer object), a
display mode, and an (x, y) offset into the video memory to support
panning or configurations where one piece of video memory spans multiple
CRTCs.
CRTC Initialization
A KMS device must create and register at least one struct
drm_crtc instance. The instance is allocated
and zeroed by the driver, possibly as part of a larger structure, and
registered with a call to drm_crtc_init with a
pointer to CRTC functions.
CRTC OperationsSet Configurationint (*set_config)(struct drm_mode_set *set);
Apply a new CRTC configuration to the device. The configuration
specifies a CRTC, a frame buffer to scan out from, a (x,y) position in
the frame buffer, a display mode and an array of connectors to drive
with the CRTC if possible.

If the frame buffer specified in the configuration is NULL, the driver
must detach all encoders connected to the CRTC and all connectors
attached to those encoders and disable them.

This operation is called with the mode config lock held.

FIXME: How should set_config interact with DPMS? If the CRTC is
suspended, should it be resumed?
Page Flippingint (*page_flip)(struct drm_crtc *crtc, struct drm_framebuffer *fb,
struct drm_pending_vblank_event *event);
Schedule a page flip to the given frame buffer for the CRTC. This
operation is called with the mode config mutex held.

Page flipping is a synchronization mechanism that replaces the frame
buffer being scanned out by the CRTC with a new frame buffer during
vertical blanking, avoiding tearing. When an application requests a page
flip the DRM core verifies that the new frame buffer is large enough to
be scanned out by  the CRTC in the currently configured mode and then
calls the CRTC page_flip operation with a
pointer to the new frame buffer.

The page_flip operation schedules a page flip.
Once any pending rendering targeting the new frame buffer has
completed, the CRTC will be reprogrammed to display that frame buffer
after the next vertical refresh. The operation must return immediately
without waiting for rendering or page flip to complete and must block
any new rendering to the frame buffer until the page flip completes.

If a page flip can be successfully scheduled the driver must set the
drm_crtc-&amp;lt;fb field to the new framebuffer pointed to
by fb. This is important so that the reference counting
on framebuffers stays balanced.

If a page flip is already pending, the
page_flip operation must return
-EBUSY.

To synchronize page flip to vertical blanking the driver will likely
need to enable vertical blanking interrupts. It should call
drm_vblank_get for that purpose, and call
drm_vblank_put after the page flip completes.

If the application has requested to be notified when page flip completes
the page_flip operation will be called with a
non-NULL event argument pointing to a
drm_pending_vblank_event instance. Upon page
flip completion the driver must call drm_send_vblank_event
to fill in the event and send to wake up any waiting processes.
This can be performed with

spin_lock_irqsave(&amp;amp;dev-&amp;gt;event_lock, flags);
...
drm_send_vblank_event(dev, pipe, event);
spin_unlock_irqrestore(&amp;amp;dev-&amp;gt;event_lock, flags);


FIXME: Could drivers that don&#39;t need to wait for rendering to complete
just add the event to dev-&amp;gt;vblank_event_list and
let the DRM core handle everything, as for &quot;normal&quot; vertical blanking
events?

While waiting for the page flip to complete, the
event-&amp;gt;base.link list head can be used freely by
the driver to store the pending event in a driver-specific list.

If the file handle is closed before the event is signaled, drivers must
take care to destroy the event in their
preclose operation (and, if needed, call
drm_vblank_put).
Miscellaneousvoid (*set_property)(struct drm_crtc *crtc,
struct drm_property *property, uint64_t value);
Set the value of the given CRTC property to
value. See
for more information about properties.
void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
uint32_t start, uint32_t size);
Apply a gamma table to the device. The operation is optional.
void (*destroy)(struct drm_crtc *crtc);
Destroy the CRTC when not needed anymore. See
.
Planes (struct drm_plane)
A plane represents an image source that can be blended with or overlayed
on top of a CRTC during the scanout process. Planes are associated with
a frame buffer to crop a portion of the image memory (source) and
optionally scale it to a destination size. The result is then blended
with or overlayed on top of a CRTC.
Plane Initialization
Planes are optional. To create a plane, a KMS drivers allocates and
zeroes an instances of struct drm_plane
(possibly as part of a larger structure) and registers it with a call
to drm_plane_init. The function takes a bitmask
of the CRTCs that can be associated with the plane, a pointer to the
plane functions and a list of format supported formats.
Plane Operationsint (*update_plane)(struct drm_plane *plane, struct drm_crtc *crtc,
struct drm_framebuffer *fb, int crtc_x, int crtc_y,
unsigned int crtc_w, unsigned int crtc_h,
uint32_t src_x, uint32_t src_y,
uint32_t src_w, uint32_t src_h);
Enable and configure the plane to use the given CRTC and frame buffer.

The source rectangle in frame buffer memory coordinates is given by
the src_x, src_y,
src_w and src_h
parameters (as 16.16 fixed point values). Devices that don&#39;t support
subpixel plane coordinates can ignore the fractional part.

The destination rectangle in CRTC coordinates is given by the
crtc_x, crtc_y,
crtc_w and crtc_h
parameters (as integer values). Devices scale the source rectangle to
the destination rectangle. If scaling is not supported, and the source
rectangle size doesn&#39;t match the destination rectangle size, the
driver must return a -EINVAL error.
int (*disable_plane)(struct drm_plane *plane);
Disable the plane. The DRM core calls this method in response to a
DRM_IOCTL_MODE_SETPLANE ioctl call with the frame buffer ID set to 0.
Disabled planes must not be processed by the CRTC.
void (*destroy)(struct drm_plane *plane);
Destroy the plane when not needed anymore. See
.
Encoders (struct drm_encoder)
An encoder takes pixel data from a CRTC and converts it to a format
suitable for any attached connectors. On some devices, it may be
possible to have a CRTC send data to more than one encoder. In that
case, both encoders would receive data from the same scanout buffer,
resulting in a &quot;cloned&quot; display configuration across the connectors
attached to each encoder.
Encoder Initialization
As for CRTCs, a KMS driver must create, initialize and register at
least one struct drm_encoder instance. The
instance is allocated and zeroed by the driver, possibly as part of a
larger structure.

Drivers must initialize the struct drm_encoder
possible_crtcs and
possible_clones fields before registering the
encoder. Both fields are bitmasks of respectively the CRTCs that the
encoder can be connected to, and sibling encoders candidate for cloning.

After being initialized, the encoder must be registered with a call to
drm_encoder_init. The function takes a pointer to
the encoder functions and an encoder type. Supported types are

DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A

DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort

DRM_MODE_ENCODER_LVDS for display panels

DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video, Component,
SCART)

DRM_MODE_ENCODER_VIRTUAL for virtual machine displays


Encoders must be attached to a CRTC to be used. DRM drivers leave
encoders unattached at initialization time. Applications (or the fbdev
compatibility layer when implemented) are responsible for attaching the
encoders they want to use to a CRTC.
Encoder Operationsvoid (*destroy)(struct drm_encoder *encoder);
Called to destroy the encoder when not needed anymore. See
.
void (*set_property)(struct drm_plane *plane,
struct drm_property *property, uint64_t value);
Set the value of the given plane property to
value. See
for more information about properties.
Connectors (struct drm_connector)
A connector is the final destination for pixel data on a device, and
usually connects directly to an external display device like a monitor
or laptop panel. A connector can only be attached to one encoder at a
time. The connector is also the structure where information about the
attached display is kept, so it contains fields for display data, EDID
data, DPMS &amp;amp; connection status, and information about modes
supported on the attached displays.
Connector Initialization
Finally a KMS driver must create, initialize, register and attach at
least one struct drm_connector instance. The
instance is created as other KMS objects and initialized by setting the
following fields.
interlace_allowed
Whether the connector can handle interlaced modes.
doublescan_allowed
Whether the connector can handle doublescan.
display_info

Display information is filled from EDID information when a display
is detected. For non hot-pluggable displays such as flat panels in
embedded systems, the driver should initialize the
display_info.width_mm
and
display_info.height_mm
fields with the physical size of the display.
polled
Connector polling mode, a combination of
DRM_CONNECTOR_POLL_HPD
The connector generates hotplug events and doesn&#39;t need to be
periodically polled. The CONNECT and DISCONNECT flags must not
be set together with the HPD flag.
DRM_CONNECTOR_POLL_CONNECT
Periodically poll the connector for connection.
DRM_CONNECTOR_POLL_DISCONNECT
Periodically poll the connector for disconnection.

Set to 0 for connectors that don&#39;t support connection status
discovery.

The connector is then registered with a call to
drm_connector_init with a pointer to the connector
functions and a connector type, and exposed through sysfs with a call to
drm_sysfs_connector_add.

Supported connector types are
DRM_MODE_CONNECTOR_VGADRM_MODE_CONNECTOR_DVIIDRM_MODE_CONNECTOR_DVIDDRM_MODE_CONNECTOR_DVIADRM_MODE_CONNECTOR_CompositeDRM_MODE_CONNECTOR_SVIDEODRM_MODE_CONNECTOR_LVDSDRM_MODE_CONNECTOR_ComponentDRM_MODE_CONNECTOR_9PinDINDRM_MODE_CONNECTOR_DisplayPortDRM_MODE_CONNECTOR_HDMIADRM_MODE_CONNECTOR_HDMIBDRM_MODE_CONNECTOR_TVDRM_MODE_CONNECTOR_eDPDRM_MODE_CONNECTOR_VIRTUAL

Connectors must be attached to an encoder to be used. For devices that
map connectors to encoders 1:1, the connector should be attached at
initialization time with a call to
drm_mode_connector_attach_encoder. The driver must
also set the drm_connector
encoder field to point to the attached
encoder.

Finally, drivers must initialize the connectors state change detection
with a call to drm_kms_helper_poll_init. If at
least one connector is pollable but can&#39;t generate hotplug interrupts
(indicated by the DRM_CONNECTOR_POLL_CONNECT and
DRM_CONNECTOR_POLL_DISCONNECT connector flags), a delayed work will
automatically be queued to periodically poll for changes. Connectors
that can generate hotplug interrupts must be marked with the
DRM_CONNECTOR_POLL_HPD flag instead, and their interrupt handler must
call drm_helper_hpd_irq_event. The function will
queue a delayed work to check the state of all connectors, but no
periodic polling will be done.
Connector Operations
Unless otherwise state, all operations are mandatory.
DPMSvoid (*dpms)(struct drm_connector *connector, int mode);
The DPMS operation sets the power state of a connector. The mode
argument is one of
DRM_MODE_DPMS_ONDRM_MODE_DPMS_STANDBYDRM_MODE_DPMS_SUSPENDDRM_MODE_DPMS_OFF

In all but DPMS_ON mode the encoder to which the connector is attached
should put the display in low-power mode by driving its signals
appropriately. If more than one connector is attached to the encoder
care should be taken not to change the power state of other displays as
a side effect. Low-power mode should be propagated to the encoders and
CRTCs when all related connectors are put in low-power mode.
Modesint (*fill_modes)(struct drm_connector *connector, uint32_t max_width,
uint32_t max_height);
Fill the mode list with all supported modes for the connector. If the
max_width and max_height
arguments are non-zero, the implementation must ignore all modes wider
than max_width or higher than
max_height.

The connector must also fill in this operation its
display_info
width_mm and
height_mm fields with the connected display
physical size in millimeters. The fields should be set to 0 if the value
isn&#39;t known or is not applicable (for instance for projector devices).
Connection Status
The connection status is updated through polling or hotplug events when
supported (see ). The status
value is reported to userspace through ioctls and must not be used
inside the driver, as it only gets initialized by a call to
drm_mode_getconnector from userspace.
enum drm_connector_status (*detect)(struct drm_connector *connector,
bool force);
Check to see if anything is attached to the connector. The
force parameter is set to false whilst polling or
to true when checking the connector due to user request.
force can be used by the driver to avoid
expensive, destructive operations during automated probing.

Return connector_status_connected if something is connected to the
connector, connector_status_disconnected if nothing is connected and
connector_status_unknown if the connection state isn&#39;t known.

Drivers should only return connector_status_connected if the connection
status has really been probed as connected. Connectors that can&#39;t detect
the connection status, or failed connection status probes, should return
connector_status_unknown.
Miscellaneousvoid (*set_property)(struct drm_connector *connector,
struct drm_property *property, uint64_t value);
Set the value of the given connector property to
value. See
for more information about properties.
void (*destroy)(struct drm_connector *connector);
Destroy the connector when not needed anymore. See
.
Cleanup
The DRM core manages its objects&#39; lifetime. When an object is not needed
anymore the core calls its destroy function, which must clean up and
free every resource allocated for the object. Every
drm_*_init call must be matched with a
corresponding drm_*_cleanup call to cleanup CRTCs
(drm_crtc_cleanup), planes
(drm_plane_cleanup), encoders
(drm_encoder_cleanup) and connectors
(drm_connector_cleanup). Furthermore, connectors
that have been added to sysfs must be removed by a call to
drm_sysfs_connector_remove before calling
drm_connector_cleanup.

Connectors state change detection must be cleanup up with a call to
drm_kms_helper_poll_fini.
Output discovery and initialization example
void intel_crt_init(struct drm_device *dev)
{
struct drm_connector *connector;
struct intel_output *intel_output;

intel_output = kzalloc(sizeof(struct intel_output), GFP_KERNEL);
if (!intel_output)
return;

connector = &amp;amp;intel_output-&amp;gt;base;
drm_connector_init(dev, &amp;amp;intel_output-&amp;gt;base,
&amp;amp;intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);

drm_encoder_init(dev, &amp;amp;intel_output-&amp;gt;enc, &amp;amp;intel_crt_enc_funcs,
DRM_MODE_ENCODER_DAC);

drm_mode_connector_attach_encoder(&amp;amp;intel_output-&amp;gt;base,
&amp;amp;intel_output-&amp;gt;enc);

/* Set up the DDC bus. */
intel_output-&amp;gt;ddc_bus = intel_i2c_create(dev, GPIOA, &quot;CRTDDC_A&quot;);
if (!intel_output-&amp;gt;ddc_bus) {
dev_printk(KERN_ERR, &amp;amp;dev-&amp;gt;pdev-&amp;gt;dev, &quot;DDC bus registration &quot;
&quot;failed.\n&quot;);
return;
}

intel_output-&amp;gt;type = INTEL_OUTPUT_ANALOG;
connector-&amp;gt;interlace_allowed = 0;
connector-&amp;gt;doublescan_allowed = 0;

drm_encoder_helper_add(&amp;amp;intel_output-&amp;gt;enc, &amp;amp;intel_crt_helper_funcs);
drm_connector_helper_add(connector, &amp;amp;intel_crt_connector_helper_funcs);

drm_sysfs_connector_add(connector);
}
In the example above (taken from the i915 driver), a CRTC, connector and
encoder combination is created. A device-specific i2c bus is also
created for fetching EDID data and performing monitor detection. Once
the process is complete, the new connector is registered with sysfs to
make its properties available to applications.
KMS API Functions
&lt;!-- Internals: kms helper functions --&gt;Mode Setting Helper Functions
The CRTC, encoder and connector functions provided by the drivers
implement the DRM API. They&#39;re called by the DRM core and ioctl handlers
to handle device state changes and configuration request. As implementing
those functions often requires logic not specific to drivers, mid-layer
helper functions are available to avoid duplicating boilerplate code.

The DRM core contains one mid-layer implementation. The mid-layer provides
implementations of several CRTC, encoder and connector functions (called
from the top of the mid-layer) that pre-process requests and call
lower-level functions provided by the driver (at the bottom of the
mid-layer). For instance, the
drm_crtc_helper_set_config function can be used to
fill the struct drm_crtc_funcs
set_config field. When called, it will split
the set_config operation in smaller, simpler
operations and call the driver to handle them.

To use the mid-layer, drivers call drm_crtc_helper_add,
drm_encoder_helper_add and
drm_connector_helper_add functions to install their
mid-layer bottom operations handlers, and fill the
drm_crtc_funcs,
drm_encoder_funcs and
drm_connector_funcs structures with pointers to
the mid-layer top API functions. Installing the mid-layer bottom operation
handlers is best done right after registering the corresponding KMS object.

The mid-layer is not split between CRTC, encoder and connector operations.
To use it, a driver must provide bottom functions for all of the three KMS
entities.
Helper Functionsint drm_crtc_helper_set_config(struct drm_mode_set *set);
The drm_crtc_helper_set_config helper function
is a CRTC set_config implementation. It
first tries to locate the best encoder for each connector by calling
the connector best_encoder helper
operation.

After locating the appropriate encoders, the helper function will
call the mode_fixup encoder and CRTC helper
operations to adjust the requested mode, or reject it completely in
which case an error will be returned to the application. If the new
configuration after mode adjustment is identical to the current
configuration the helper function will return without performing any
other operation.

If the adjusted mode is identical to the current mode but changes to
the frame buffer need to be applied, the
drm_crtc_helper_set_config function will call
the CRTC mode_set_base helper operation. If
the adjusted mode differs from the current mode, or if the
mode_set_base helper operation is not
provided, the helper function performs a full mode set sequence by
calling the prepare,
mode_set and
commit CRTC and encoder helper operations,
in that order.
void drm_helper_connector_dpms(struct drm_connector *connector, int mode);
The drm_helper_connector_dpms helper function
is a connector dpms implementation that
tracks power state of connectors. To use the function, drivers must
provide dpms helper operations for CRTCs
and encoders to apply the DPMS state to the device.

The mid-layer doesn&#39;t track the power state of CRTCs and encoders.
The dpms helper operations can thus be
called with a mode identical to the currently active mode.
int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
uint32_t maxX, uint32_t maxY);
The drm_helper_probe_single_connector_modes helper
function is a connector fill_modes
implementation that updates the connection status for the connector
and then retrieves a list of modes by calling the connector
get_modes helper operation.

The function filters out modes larger than
max_width and max_height
if specified. It then calls the connector
mode_valid helper operation for  each mode in
the probed list to check whether the mode is valid for the connector.
CRTC Helper Operationsbool (*mode_fixup)(struct drm_crtc *crtc,
const struct drm_display_mode *mode,
struct drm_display_mode *adjusted_mode);
Let CRTCs adjust the requested mode or reject it completely. This
operation returns true if the mode is accepted (possibly after being
adjusted) or false if it is rejected.

The mode_fixup operation should reject the
mode if it can&#39;t reasonably use it. The definition of &quot;reasonable&quot;
is currently fuzzy in this context. One possible behaviour would be
to set the adjusted mode to the panel timings when a fixed-mode
panel is used with hardware capable of scaling. Another behaviour
would be to accept any input mode and adjust it to the closest mode
supported by the hardware (FIXME: This needs to be clarified).
int (*mode_set_base)(struct drm_crtc *crtc, int x, int y,
struct drm_framebuffer *old_fb)
Move the CRTC on the current frame buffer (stored in
crtc-&amp;gt;fb) to position (x,y). Any of the frame
buffer, x position or y position may have been modified.

This helper operation is optional. If not provided, the
drm_crtc_helper_set_config function will fall
back to the mode_set helper operation.

FIXME: Why are x and y passed as arguments, as they can be accessed
through crtc-&amp;gt;x and
crtc-&amp;gt;y?
void (*prepare)(struct drm_crtc *crtc);
Prepare the CRTC for mode setting. This operation is called after
validating the requested mode. Drivers use it to perform
device-specific operations required before setting the new mode.
int (*mode_set)(struct drm_crtc *crtc, struct drm_display_mode *mode,
struct drm_display_mode *adjusted_mode, int x, int y,
struct drm_framebuffer *old_fb);
Set a new mode, position and frame buffer. Depending on the device
requirements, the mode can be stored internally by the driver and
applied in the commit operation, or
programmed to the hardware immediately.

The mode_set operation returns 0 on success
or a negative error code if an error occurs.
void (*commit)(struct drm_crtc *crtc);
Commit a mode. This operation is called after setting the new mode.
Upon return the device must use the new mode and be fully
operational.
Encoder Helper Operationsbool (*mode_fixup)(struct drm_encoder *encoder,
const struct drm_display_mode *mode,
struct drm_display_mode *adjusted_mode);
Let encoders adjust the requested mode or reject it completely. This
operation returns true if the mode is accepted (possibly after being
adjusted) or false if it is rejected. See the
mode_fixup CRTC helper
operation for an explanation of the allowed adjustments.
void (*prepare)(struct drm_encoder *encoder);
Prepare the encoder for mode setting. This operation is called after
validating the requested mode. Drivers use it to perform
device-specific operations required before setting the new mode.
void (*mode_set)(struct drm_encoder *encoder,
struct drm_display_mode *mode,
struct drm_display_mode *adjusted_mode);
Set a new mode. Depending on the device requirements, the mode can
be stored internally by the driver and applied in the
commit operation, or programmed to the
hardware immediately.
void (*commit)(struct drm_encoder *encoder);
Commit a mode. This operation is called after setting the new mode.
Upon return the device must use the new mode and be fully
operational.
Connector Helper Operationsstruct drm_encoder *(*best_encoder)(struct drm_connector *connector);
Return a pointer to the best encoder for the connecter. Device that
map connectors to encoders 1:1 simply return the pointer to the
associated encoder. This operation is mandatory.
int (*get_modes)(struct drm_connector *connector);
Fill the connector&#39;s probed_modes list
by parsing EDID data with drm_add_edid_modes or
calling drm_mode_probed_add directly for every
supported mode and return the number of modes it has detected. This
operation is mandatory.

When adding modes manually the driver creates each mode with a call to
drm_mode_create and must fill the following fields.
__u32 type;
Mode type bitmask, a combination of
DRM_MODE_TYPE_BUILTINnot used?DRM_MODE_TYPE_CLOCK_Cnot used?DRM_MODE_TYPE_CRTC_Cnot used?
DRM_MODE_TYPE_PREFERRED - The preferred mode for the connector
not used?DRM_MODE_TYPE_DEFAULTnot used?DRM_MODE_TYPE_USERDEFnot used?DRM_MODE_TYPE_DRIVER
The mode has been created by the driver (as opposed to
to user-created modes).

Drivers must set the DRM_MODE_TYPE_DRIVER bit for all modes they
create, and set the DRM_MODE_TYPE_PREFERRED bit for the preferred
mode.
__u32 clock;Pixel clock frequency in kHz unit__u16 hdisplay, hsync_start, hsync_end, htotal;
__u16 vdisplay, vsync_start, vsync_end, vtotal;Horizontal and vertical timing information
Active                 Front           Sync           Back
Region                 Porch                          Porch
&amp;lt;-----------------------&amp;gt;&amp;lt;----------------&amp;gt;&amp;lt;-------------&amp;gt;&amp;lt;--------------&amp;gt;

//////////////////////|
////////////////////// |
//////////////////////  |..................               ................
_______________

&amp;lt;----- [hv]display -----&amp;gt;
&amp;lt;------------- [hv]sync_start ------------&amp;gt;
&amp;lt;--------------------- [hv]sync_end ---------------------&amp;gt;
&amp;lt;-------------------------------- [hv]total -----------------------------&amp;gt;
__u16 hskew;
__u16 vscan;Unknown__u32 flags;
Mode flags, a combination of
DRM_MODE_FLAG_PHSYNC
Horizontal sync is active high
DRM_MODE_FLAG_NHSYNC
Horizontal sync is active low
DRM_MODE_FLAG_PVSYNC
Vertical sync is active high
DRM_MODE_FLAG_NVSYNC
Vertical sync is active low
DRM_MODE_FLAG_INTERLACE
Mode is interlaced
DRM_MODE_FLAG_DBLSCAN
Mode uses doublescan
DRM_MODE_FLAG_CSYNC
Mode uses composite sync
DRM_MODE_FLAG_PCSYNC
Composite sync is active high
DRM_MODE_FLAG_NCSYNC
Composite sync is active low
DRM_MODE_FLAG_HSKEW
hskew provided (not used?)
DRM_MODE_FLAG_BCAST
not used?
DRM_MODE_FLAG_PIXMUX
not used?
DRM_MODE_FLAG_DBLCLK
not used?
DRM_MODE_FLAG_CLKDIV2
?


Note that modes marked with the INTERLACE or DBLSCAN flags will be
filtered out by
drm_helper_probe_single_connector_modes if
the connector&#39;s interlace_allowed or
doublescan_allowed field is set to 0.
char name[DRM_DISPLAY_MODE_LEN];
Mode name. The driver must call
drm_mode_set_name to fill the mode name from
hdisplay,
vdisplay and interlace flag after
filling the corresponding fields.


The vrefresh value is computed by
drm_helper_probe_single_connector_modes.

When parsing EDID data, drm_add_edid_modes fill the
connector display_info
width_mm and
height_mm fields. When creating modes
manually the get_modes helper operation must
set the display_info
width_mm and
height_mm fields if they haven&#39;t been set
already (for instance at initilization time when a fixed-size panel is
attached to the connector). The mode width_mm
and height_mm fields are only used internally
during EDID parsing and should not be set when creating modes manually.
int (*mode_valid)(struct drm_connector *connector,
struct drm_display_mode *mode);
Verify whether a mode is valid for the connector. Return MODE_OK for
supported modes and one of the enum drm_mode_status values (MODE_*)
for unsupported modes. This operation is mandatory.

As the mode rejection reason is currently not used beside for
immediately removing the unsupported mode, an implementation can
return MODE_BAD regardless of the exact reason why the mode is not
valid.

Note that the mode_valid helper operation is
only called for modes detected by the device, and
not for modes set by the user through the CRTC
set_config operation.
Modeset Helper Functions Reference
fbdev Helper Functions Reference
Display Port Helper Functions Reference
EDID Helper Functions Reference
Rectangle Utilities Reference
Flip-work Helper Reference
VMA Offset Manager
&lt;!-- Internals: kms properties --&gt;KMS Properties
Drivers may need to expose additional parameters to applications than
those described in the previous sections. KMS supports attaching
properties to CRTCs, connectors and planes and offers a userspace API to
list, get and set the property values.

Properties are identified by a name that uniquely defines the property
purpose, and store an associated value. For all property types except blob
properties the value is a 64-bit unsigned integer.

KMS differentiates between properties and property instances. Drivers
first create properties and then create and associate individual instances
of those properties to objects. A property can be instantiated multiple
times and associated with different objects. Values are stored in property
instances, and all other property information are stored in the propery
and shared between all instances of the property.

Every property is created with a type that influences how the KMS core
handles the property. Supported property types are
DRM_MODE_PROP_RANGERange properties report their minimum and maximum
admissible values. The KMS core verifies that values set by
application fit in that range.DRM_MODE_PROP_ENUMEnumerated properties take a numerical value that
ranges from 0 to the number of enumerated values defined by the
property minus one, and associate a free-formed string name to each
value. Applications can retrieve the list of defined value-name pairs
and use the numerical value to get and set property instance values.
DRM_MODE_PROP_BITMASKBitmask properties are enumeration properties that
additionally restrict all enumerated values to the 0..63 range.
Bitmask property instance values combine one or more of the
enumerated bits defined by the property.DRM_MODE_PROP_BLOBBlob properties store a binary blob without any format
restriction. The binary blobs are created as KMS standalone objects,
and blob property instance values store the ID of their associated
blob object.Blob properties are only used for the connector EDID property
and cannot be created by drivers.

To create a property drivers call one of the following functions depending
on the property type. All property creation functions take property flags
and name, as well as type-specific arguments.
struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
const char *name,
uint64_t min, uint64_t max);Create a range property with the given minimum and maximum
values.struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
const char *name,
const struct drm_prop_enum_list *props,
int num_values);Create an enumerated property. The props
argument points to an array of num_values
value-name pairs.struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
int flags, const char *name,
const struct drm_prop_enum_list *props,
int num_values);Create a bitmask property. The props
argument points to an array of num_values
value-name pairs.

Properties can additionally be created as immutable, in which case they
will be read-only for applications but can be modified by the driver. To
create an immutable property drivers must set the DRM_MODE_PROP_IMMUTABLE
flag at property creation time.

When no array of value-name pairs is readily available at property
creation time for enumerated or range properties, drivers can create
the property using the drm_property_create function
and manually add enumeration value-name pairs by calling the
drm_property_add_enum function. Care must be taken to
properly specify the property type through the flags
argument.

After creating properties drivers can attach property instances to CRTC,
connector and plane objects by calling the
drm_object_attach_property. The function takes a
pointer to the target object, a pointer to the previously created property
and an initial instance value.
&lt;!-- Internals: vertical blanking --&gt;Vertical Blanking
Vertical blanking plays a major role in graphics rendering. To achieve
tear-free display, users must synchronize page flips and/or rendering to
vertical blanking. The DRM API offers ioctls to perform page flips
synchronized to vertical blanking and wait for vertical blanking.

The DRM core handles most of the vertical blanking management logic, which
involves filtering out spurious interrupts, keeping race-free blanking
counters, coping with counter wrap-around and resets and keeping use
counts. It relies on the driver to generate vertical blanking interrupts
and optionally provide a hardware vertical blanking counter. Drivers must
implement the following operations.
int (*enable_vblank) (struct drm_device *dev, int crtc);
void (*disable_vblank) (struct drm_device *dev, int crtc);
Enable or disable vertical blanking interrupts for the given CRTC.
u32 (*get_vblank_counter) (struct drm_device *dev, int crtc);
Retrieve the value of the vertical blanking counter for the given
CRTC. If the hardware maintains a vertical blanking counter its value
should be returned. Otherwise drivers can use the
drm_vblank_count helper function to handle this
operation.

Drivers must initialize the vertical blanking handling core with a call to
drm_vblank_init in their
load operation. The function will set the struct
drm_device
vblank_disable_allowed field to 0. This will
keep vertical blanking interrupts enabled permanently until the first mode
set operation, where vblank_disable_allowed is
set to 1. The reason behind this is not clear. Drivers can set the field
to 1 after calling drm_vblank_init to make vertical
blanking interrupts dynamically managed from the beginning.

Vertical blanking interrupts can be enabled by the DRM core or by drivers
themselves (for instance to handle page flipping operations). The DRM core
maintains a vertical blanking use count to ensure that the interrupts are
not disabled while a user still needs them. To increment the use count,
drivers call drm_vblank_get. Upon return vertical
blanking interrupts are guaranteed to be enabled.

To decrement the use count drivers call
drm_vblank_put. Only when the use count drops to zero
will the DRM core disable the vertical blanking interrupts after a delay
by scheduling a timer. The delay is accessible through the vblankoffdelay
module parameter or the drm_vblank_offdelay global
variable and expressed in milliseconds. Its default value is 5000 ms.

When a vertical blanking interrupt occurs drivers only need to call the
drm_handle_vblank function to account for the
interrupt.

Resources allocated by drm_vblank_init must be freed
with a call to drm_vblank_cleanup in the driver
unload operation handler.
&lt;!-- Internals: open/close, file operations and ioctls --&gt;Open/Close, File Operations and IOCTLsOpen and Closeint (*firstopen) (struct drm_device *);
void (*lastclose) (struct drm_device *);
int (*open) (struct drm_device *, struct drm_file *);
void (*preclose) (struct drm_device *, struct drm_file *);
void (*postclose) (struct drm_device *, struct drm_file *);Open and close handlers. None of those methods are mandatory.

The firstopen method is called by the DRM core
for legacy UMS (User Mode Setting) drivers only when an application
opens a device that has no other opened file handle. UMS drivers can
implement it to acquire device resources. KMS drivers can&#39;t use the
method and must acquire resources in the load
method instead.

Similarly the lastclose method is called when
the last application holding a file handle opened on the device closes
it, for both UMS and KMS drivers. Additionally, the method is also
called at module unload time or, for hot-pluggable devices, when the
device is unplugged. The firstopen and
lastclose calls can thus be unbalanced.

The open method is called every time the device
is opened by an application. Drivers can allocate per-file private data
in this method and store them in the struct
drm_file driver_priv
field. Note that the open method is called
before firstopen.

The close operation is split into preclose and
postclose methods. Drivers must stop and
cleanup all per-file operations in the preclose
method. For instance pending vertical blanking and page flip events must
be cancelled. No per-file operation is allowed on the file handle after
returning from the preclose method.

Finally the postclose method is called as the
last step of the close operation, right before calling the
lastclose method if no other open file handle
exists for the device. Drivers that have allocated per-file private data
in the open method should free it here.

The lastclose method should restore CRTC and
plane properties to default value, so that a subsequent open of the
device will not inherit state from the previous user. It can also be
used to execute delayed power switching state changes, e.g. in
conjunction with the vga-switcheroo infrastructure. Beyond that KMS
drivers should not do any further cleanup. Only legacy UMS drivers might
need to clean up device state so that the vga console or an independent
fbdev driver could take over.
File Operationsconst struct file_operations *fopsFile operations for the DRM device node.
Drivers must define the file operations structure that forms the DRM
userspace API entry point, even though most of those operations are
implemented in the DRM core. The open,
release and ioctl
operations are handled by

.owner = THIS_MODULE,
.open = drm_open,
.release = drm_release,
.unlocked_ioctl = drm_ioctl,
#ifdef CONFIG_COMPAT
.compat_ioctl = drm_compat_ioctl,
#endif


Drivers that implement private ioctls that requires 32/64bit
compatibility support must provide their own
compat_ioctl handler that processes private
ioctls and calls drm_compat_ioctl for core ioctls.

The read and poll
operations provide support for reading DRM events and polling them. They
are implemented by

.poll = drm_poll,
.read = drm_read,
.llseek = no_llseek,


The memory mapping implementation varies depending on how the driver
manages memory. Pre-GEM drivers will use drm_mmap,
while GEM-aware drivers will use drm_gem_mmap. See
.

.mmap = drm_gem_mmap,


No other file operation is supported by the DRM API.
IOCTLsstruct drm_ioctl_desc *ioctls;
int num_ioctls;Driver-specific ioctls descriptors table.
Driver-specific ioctls numbers start at DRM_COMMAND_BASE. The ioctls
descriptors table is indexed by the ioctl number offset from the base
value. Drivers can use the DRM_IOCTL_DEF_DRV() macro to initialize the
table entries.
DRM_IOCTL_DEF_DRV(ioctl, func, flags)ioctl is the ioctl name. Drivers must define
the DRM_##ioctl and DRM_IOCTL_##ioctl macros to the ioctl number
offset from DRM_COMMAND_BASE and the ioctl number respectively. The
first macro is private to the device while the second must be exposed
to userspace in a public header.
func is a pointer to the ioctl handler function
compatible with the drm_ioctl_t type.
typedef int drm_ioctl_t(struct drm_device *dev, void *data,
struct drm_file *file_priv);
flags is a bitmask combination of the following
values. It restricts how the ioctl is allowed to be called.

DRM_AUTH - Only authenticated callers allowed

DRM_MASTER - The ioctl can only be called on the master file
handle

DRM_ROOT_ONLY - Only callers with the SYSADMIN capability allowed

DRM_CONTROL_ALLOW - The ioctl can only be called on a control
device

DRM_UNLOCKED - The ioctl handler will be called without locking
the DRM global mutex

Command submission &amp;amp; fencing
This should cover a few device-specific command submission
implementations.
&lt;!-- Internals: suspend/resume --&gt;Suspend/Resume
The DRM core provides some suspend/resume code, but drivers wanting full
suspend/resume support should provide save() and restore() functions.
These are called at suspend, hibernate, or resume time, and should perform
any state save or restore required by your device across suspend or
hibernate states.
int (*suspend) (struct drm_device *, pm_message_t state);
int (*resume) (struct drm_device *);
Those are legacy suspend and resume methods. New driver should use the
power management interface provided by their bus type (usually through
the struct device_driver dev_pm_ops) and set
these methods to NULL.
DMA services
This should cover how DMA mapping etc. is supported by the core.
These functions are deprecated and should not be used.
&lt;!-- TODO

- Add a glossary
- Document the struct_mutex catch-all lock
- Document connector properties

- Why is the load method optional?
- What are drivers supposed to set the initial display state to, and how?
Connector&#39;s DPMS states are not initialized and are thus equal to
DRM_MODE_DPMS_ON. The fbcon compatibility layer calls
drm_helper_disable_unused_functions(), which disables unused encoders and
CRTCs, but doesn&#39;t touch the connectors&#39; DPMS state, and
drm_helper_connector_dpms() in reaction to fbdev blanking events. Do drivers
that don&#39;t implement (or just don&#39;t use) fbcon compatibility need to call
those functions themselves?
- KMS drivers must call drm_vblank_pre_modeset() and drm_vblank_post_modeset()
around mode setting. Should this be done in the DRM core?
- vblank_disable_allowed is set to 1 in the first drm_vblank_post_modeset()
call and never set back to 0. It seems to be safe to permanently set it to 1
in drm_vblank_init() for KMS driver, and it might be safe for UMS drivers as
well. This should be investigated.
- crtc and connector .save and .restore operations are only used internally in
drivers, should they be removed from the core?
- encoder mid-layer .save and .restore operations are only used internally in
drivers, should they be removed from the core?
- encoder mid-layer .detect operation is only used internally in drivers,
should it be removed from the core?
--&gt;&lt;!-- External interfaces --&gt;Userland interfaces
The DRM core exports several interfaces to applications,
generally intended to be used through corresponding libdrm
wrapper functions.  In addition, drivers export device-specific
interfaces for use by userspace drivers &amp;amp; device-aware
applications through ioctls and sysfs files.

External interfaces include: memory mapping, context management,
DMA operations, AGP management, vblank control, fence
management, memory management, and output management.

Cover generic ioctls and sysfs layout here.  We only need high-level
info, since man pages should cover the rest.
&lt;!-- External: render nodes --&gt;Render nodes
DRM core provides multiple character-devices for user-space to use.
Depending on which device is opened, user-space can perform a different
set of operations (mainly ioctls). The primary node is always created
and called card&amp;lt;num&amp;gt;. Additionally, a currently
unused control node, called controlD&amp;lt;num&amp;gt; is also
created. The primary node provides all legacy operations and
historically was the only interface used by userspace. With KMS, the
control node was introduced. However, the planned KMS control interface
has never been written and so the control node stays unused to date.

With the increased use of offscreen renderers and GPGPU applications,
clients no longer require running compositors or graphics servers to
make use of a GPU. But the DRM API required unprivileged clients to
authenticate to a DRM-Master prior to getting GPU access. To avoid this
step and to grant clients GPU access without authenticating, render
nodes were introduced. Render nodes solely serve render clients, that
is, no modesetting or privileged ioctls can be issued on render nodes.
Only non-global rendering commands are allowed. If a driver supports
render nodes, it must advertise it via the DRIVER_RENDER
DRM driver capability. If not supported, the primary node must be used
for render clients together with the legacy drmAuth authentication
procedure.

If a driver advertises render node support, DRM core will create a
separate render node called renderD&amp;lt;num&amp;gt;. There will
be one render node per device. No ioctls except  PRIME-related ioctls
will be allowed on this node. Especially GEM_OPEN will be
explicitly prohibited. Render nodes are designed to avoid the
buffer-leaks, which occur if clients guess the flink names or mmap
offsets on the legacy interface. Additionally to this basic interface,
drivers must mark their driver-dependent render-only ioctls as
DRM_RENDER_ALLOW so render clients can use them. Driver
authors must be careful not to allow any privileged ioctls on render
nodes.

With render nodes, user-space can now control access to the render node
via basic file-system access-modes. A running graphics server which
authenticates clients on the privileged primary/legacy node is no longer
required. Instead, a client can open the render node and is immediately
granted GPU access. Communication between clients (or servers) is done
via PRIME. FLINK from render node to legacy node is not supported. New
clients must not use the insecure FLINK interface.

Besides dropping all modeset/global ioctls, render nodes also drop the
DRM-Master concept. There is no reason to associate render clients with
a DRM-Master as they are independent of any graphics server. Besides,
they must work without any running master, anyway.
Drivers must be able to run without a master object if they support
render nodes. If, on the other hand, a driver requires shared state
between clients which is visible to user-space and accessible beyond
open-file boundaries, they cannot support render nodes.
&lt;!-- External: vblank handling --&gt;VBlank event handling
The DRM core exposes two vertical blank related ioctls:
DRM_IOCTL_WAIT_VBLANK
This takes a struct drm_wait_vblank structure as its argument,
and it is used to block or request a signal when a specified
vblank event occurs.
DRM_IOCTL_MODESET_CTL
This should be called by application level drivers before and
after mode setting, since on many devices the vertical blank
counter is reset at that time.  Internally, the DRM snapshots
the last vblank count when the ioctl is called with the
_DRM_PRE_MODESET command, so that the counter won&#39;t go backwards
(which is dealt with when _DRM_POST_MODESET is used).

&lt;!--!Edrivers/char/drm/drm_irq.c--&gt;
&lt;!-- API reference --&gt;DRM Driver API
Include auto-generated API reference here (need to reference it
from paragraphs above too).
Linux Filesystems API
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
The Linux VFSThe Filesystem types
The Directory Cache
Inode Handling
Registration and Superblocks
File Locks
Other Functions
The proc filesystemsysctl interface
proc filesystem interface
Events based on file descriptors
The Filesystem for Exporting Kernel Objects
The debugfs filesystemdebugfs interface
The Linux Journalling APIRogerGammansrgammans@computer-surgery.co.ukStephenTweediesct@redhat.com2002Roger GammansThe Linux Journalling APIOverviewDetails
The journalling layer is  easy to use. You need to
first of all create a journal_t data structure. There are
two calls to do this dependent on how you decide to allocate the physical
media on which the journal resides. The journal_init_inode() call
is for journals stored in filesystem inodes, or the journal_init_dev()
call can be use for journal stored on a raw device (in a continuous range
of blocks). A journal_t is a typedef for a struct pointer, so when
you are finally finished make sure you call journal_destroy() on it
to free up any used kernel memory.

Once you have got your journal_t object you need to &#39;mount&#39; or load the journal
file, unless of course you haven&#39;t initialised it yet - in which case you
need to call journal_create().

Most of the time however your journal file will already have been created, but
before you load it you must call journal_wipe() to empty the journal file.
Hang on, you say , what if the filesystem wasn&#39;t cleanly umount()&#39;d . Well, it is the
job of the client file system to detect this and skip the call to journal_wipe().

In either case the next call should be to journal_load() which prepares the
journal file for use. Note that journal_wipe(..,0) calls journal_skip_recovery()
for you if it detects any outstanding transactions in the journal and similarly
journal_load() will call journal_recover() if necessary.
I would advise reading fs/ext3/super.c for examples on this stage.
[RGG: Why is the journal_wipe() call necessary - doesn&#39;t this needlessly
complicate the API. Or isn&#39;t a good idea for the journal layer to hide
dirty mounts from the client fs]

Now you can go ahead and start modifying the underlying
filesystem. Almost.


You still need to actually journal your filesystem changes, this
is done by wrapping them into transactions. Additionally you
also need to wrap the modification of each of the buffers
with calls to the journal layer, so it knows what the modifications
you are actually making are. To do this use  journal_start() which
returns a transaction handle.

journal_start()
and its counterpart journal_stop(), which indicates the end of a transaction
are nestable calls, so you can reenter a transaction if necessary,
but remember you must call journal_stop() the same number of times as
journal_start() before the transaction is completed (or more accurately
leaves the update phase). Ext3/VFS makes use of this feature to simplify
quota support.

Inside each transaction you need to wrap the modifications to the
individual buffers (blocks). Before you start to modify a buffer you
need to call journal_get_{create,write,undo}_access() as appropriate,
this allows the journalling layer to copy the unmodified data if it
needs to. After all the buffer may be part of a previously uncommitted
transaction.
At this point you are at last ready to modify a buffer, and once
you are have done so you need to call journal_dirty_{meta,}data().
Or if you&#39;ve asked for access to a buffer you now know is now longer
required to be pushed back on the device you can call journal_forget()
in much the same way as you might have used bforget() in the past.

A journal_flush() may be called at any time to commit and checkpoint
all your transactions.

Then at umount time , in your put_super() you can then call journal_destroy()
to clean up your in-core journal object.

Unfortunately there a couple of ways the journal layer can cause a deadlock.
The first thing to note is that each task can only have
a single outstanding transaction at any one time, remember nothing
commits until the outermost journal_stop(). This means
you must complete the transaction at the end of each file/inode/address
etc. operation you perform, so that the journalling system isn&#39;t re-entered
on another journal. Since transactions can&#39;t be nested/batched
across differing journals, and another filesystem other than
yours (say ext3) may be modified in a later syscall.

The second case to bear in mind is that journal_start() can
block if there isn&#39;t enough space in the journal for your transaction
(based on the passed nblocks param) - when it blocks it merely(!) needs to
wait for transactions to complete and be committed from other tasks,
so essentially we are waiting for journal_stop(). So to avoid
deadlocks you must treat journal_start/stop() as if they
were semaphores and include them in your semaphore ordering rules to prevent
deadlocks. Note that journal_extend() has similar blocking behaviour to
journal_start() so you can deadlock here just as easily as on journal_start().

Try to reserve the right number of blocks the first time. ;-). This will
be the maximum number of blocks you are going to touch in this transaction.
I advise having a look at at least ext3_jbd.h to see the basis on which
ext3 uses to make these decisions.

Another wriggle to watch out for is your on-disk block allocation strategy.
why? Because, if you undo a delete, you need to ensure you haven&#39;t reused any
of the freed blocks in a later transaction. One simple way of doing this
is make sure any blocks you allocate only have checkpointed transactions
listed against them. Ext3 does this in ext3_test_allocatable().

Lock is also providing through journal_{un,}lock_updates(),
ext3 uses this when it wants a window with a clean and stable fs for a moment.
eg.


journal_lock_updates() //stop new stuff happening..
journal_flush()        // checkpoint everything.
..do stuff on stable fs
journal_unlock_updates() // carry on with filesystem use.

The opportunities for abuse and DOS attacks with this should be obvious,
if you allow unprivileged userspace to trigger codepaths containing these
calls.

A new feature of jbd since 2.5.25 is commit callbacks with the new
journal_callback_set() function you can now ask the journalling layer
to call you back when the transaction is finally committed to disk, so that
you can do some of your own management. The key to this is the journal_callback
struct, this maintains the internal callback information but you can
extend it like this:-

struct  myfs_callback_s {
//Data structure element required by jbd..
struct journal_callback for_jbd;
// Stuff for myfs allocated together.
myfs_inode*    i_commited;

}

this would be useful if you needed to know when data was committed to a
particular inode.
Summary
Using the journal is a matter of wrapping the different context changes,
being each mount, each modification (transaction) and each changed buffer
to tell the journalling layer about them.

Here is a some pseudo code to give you an idea of how it works, as
an example.

journal_t* my_jnrl = journal_create();
journal_init_{dev,inode}(jnrl,...)
if (clean) journal_wipe();
journal_load();

foreach(transaction) { /*transactions must be
completed before
a syscall returns to
userspace*/

handle_t * xct=journal_start(my_jnrl);
foreach(bh) {
journal_get_{create,write,undo}_access(xact,bh);
if ( myfs_modify(bh) ) { /* returns true
if makes changes */
journal_dirty_{meta,}data(xact,bh);
} else {
journal_forget(bh);
}
}
journal_stop(xct);
}
journal_destroy(my_jrnl);
Data Types
The journalling layer uses typedefs to &#39;hide&#39; the concrete definitions
of the structures used. As a client of the JBD layer you can
just rely on the using the pointer as a magic cookie  of some sort.

Obviously the hiding is not enforced as this is &#39;C&#39;.
Structures
Functions
The functions here are split into two groups those that
affect a journal as a whole, and those which are used to
manage transactions
Journal Level
Transasction Level
See also
Journaling the Linux ext2fs Filesystem, LinuxExpo 98, Stephen Tweedie

Ext3 Journalling FileSystem, OLS 2000, Dr. Stephen Tweedie
splice API
splice is a method for moving blocks of data around inside the
kernel, without continually transferring them between the kernel
and user space.

pipes API
Pipe interfaces are all for in-kernel (builtin image) use.
They are not exported for use by modules.

USB Gadget API for Linux20 August 200420 August 2004
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
2003-2004David BrownellDavidBrownelldbrownell@users.sourceforge.netIntroductionThis document presents a Linux-USB &quot;Gadget&quot;
kernel mode
API, for use within peripherals and other USB devices
that embed Linux.
It provides an overview of the API structure,
and shows how that fits into a system development project.
This is the first such API released on Linux to address
a number of important problems, including: Supports USB 2.0, for high speed devices which
can stream data at several dozen megabytes per second.
Handles devices with dozens of endpoints just as
well as ones with just two fixed-function ones.  Gadget drivers
can be written so they&#39;re easy to port to new hardware.
Flexible enough to expose more complex USB device
capabilities such as multiple configurations, multiple interfaces,
composite devices,
and alternate interface settings.
USB &quot;On-The-Go&quot; (OTG) support, in conjunction
with updates to the Linux-USB host side.
Sharing data structures and API models with the
Linux-USB host side API.  This helps the OTG support, and
looks forward to more-symmetric frameworks (where the same
I/O model is used by both host and device side drivers).
Minimalist, so it&#39;s easier to support new device
controller hardware.  I/O processing doesn&#39;t imply large
demands for memory or CPU resources.
Most Linux developers will not be able to use this API, since they
have USB &quot;host&quot; hardware in a PC, workstation, or server.
Linux users with embedded systems are more likely to
have USB peripheral hardware.
To distinguish drivers running inside such hardware from the
more familiar Linux &quot;USB device drivers&quot;,
which are host side proxies for the real USB devices,
a different term is used:
the drivers inside the peripherals are &quot;USB gadget drivers&quot;.
In USB protocol interactions, the device driver is the master
(or &quot;client driver&quot;)
and the gadget driver is the slave (or &quot;function driver&quot;).
The gadget API resembles the host side Linux-USB API in that both
use queues of request objects to package I/O buffers, and those requests
may be submitted or canceled.
They share common definitions for the standard USB
Chapter 9 messages, structures, and constants.
Also, both APIs bind and unbind drivers to devices.
The APIs differ in detail, since the host side&#39;s current
URB framework exposes a number of implementation details
and assumptions that are inappropriate for a gadget API.
While the model for control transfers and configuration
management is necessarily different (one side is a hardware-neutral master,
the other is a hardware-aware slave), the endpoint I/0 API used here
should also be usable for an overhead-reduced host side API.
Structure of Gadget DriversA system running inside a USB peripheral
normally has at least three layers inside the kernel to handle
USB protocol processing, and may have additional layers in
user space code.
The &quot;gadget&quot; API is used by the middle layer to interact
with the lowest level (which directly handles hardware).
In Linux, from the bottom up, these layers are:
USB Controller DriverThis is the lowest software level.
It is the only layer that talks to hardware,
through registers, fifos, dma, irqs, and the like.
The &amp;lt;linux/usb/gadget.h&amp;gt; API abstracts
the peripheral controller endpoint hardware.
That hardware is exposed through endpoint objects, which accept
streams of IN/OUT buffers, and through callbacks that interact
with gadget drivers.
Since normal USB devices only have one upstream
port, they only have one of these drivers.
The controller driver can support any number of different
gadget drivers, but only one of them can be used at a time.
Examples of such controller hardware include
the PCI-based NetChip 2280 USB 2.0 high speed controller,
the SA-11x0 or PXA-25x UDC (found within many PDAs),
and a variety of other products.
Gadget DriverThe lower boundary of this driver implements hardware-neutral
USB functions, using calls to the controller driver.
Because such hardware varies widely in capabilities and restrictions,
and is used in embedded environments where space is at a premium,
the gadget driver is often configured at compile time
to work with endpoints supported by one particular controller.
Gadget drivers may be portable to several different controllers,
using conditional compilation.
(Recent kernels substantially simplify the work involved in
supporting new hardware, by autoconfiguring
endpoints automatically for many bulk-oriented drivers.)
Gadget driver responsibilities include:
handling setup requests (ep0 protocol responses)
possibly including class-specific functionality
returning configuration and string descriptors
(re)setting configurations and interface
altsettings, including enabling and configuring endpoints
handling life cycle events, such as managing
bindings to hardware,
USB suspend/resume, remote wakeup,
and disconnection from the USB host.
managing IN and OUT transfers on all currently
enabled endpoints

Such drivers may be modules of proprietary code, although
that approach is discouraged in the Linux community.
Upper LevelMost gadget drivers have an upper boundary that connects
to some Linux driver or framework in Linux.
Through that boundary flows the data which the gadget driver
produces and/or consumes through protocol transfers over USB.
Examples include:
user mode code, using generic (gadgetfs)
or application specific files in
/dev
networking subsystem (for network gadgets,
like the CDC Ethernet Model gadget driver)
data capture drivers, perhaps video4Linux or
a scanner driver; or test and measurement hardware.
input subsystem (for HID gadgets)
sound subsystem (for audio gadgets)
file system (for PTP gadgets)
block i/o subsystem (for usb-storage gadgets)
... and more Additional LayersOther layers may exist.
These could include kernel layers, such as network protocol stacks,
as well as user mode applications building on standard POSIX
system call APIs such as
open(), close(),
read() and write().
On newer systems, POSIX Async I/O calls may be an option.
Such user mode code will not necessarily be subject to
the GNU General Public License (GPL).
OTG-capable systems will also need to include a standard Linux-USB
host side stack,
with usbcore,
one or more Host Controller Drivers (HCDs),
USB Device Drivers to support
the OTG &quot;Targeted Peripheral List&quot;,
and so forth.
There will also be an OTG Controller Driver,
which is visible to gadget and device driver developers only indirectly.
That helps the host and device side USB controllers implement the
two new OTG protocols (HNP and SRP).
Roles switch (host to peripheral, or vice versa) using HNP
during USB suspend processing, and SRP can be viewed as a
more battery-friendly kind of device wakeup protocol.
Over time, reusable utilities are evolving to help make some
gadget driver tasks simpler.
For example, building configuration descriptors from vectors of
descriptors for the configurations interfaces and endpoints is
now automated, and many drivers now use autoconfiguration to
choose hardware endpoints and initialize their descriptors.

A potential example of particular interest
is code implementing standard USB-IF protocols for
HID, networking, storage, or audio classes.
Some developers are interested in KDB or KGDB hooks, to let
target hardware be remotely debugged.
Most such USB protocol code doesn&#39;t need to be hardware-specific,
any more than network protocols like X11, HTTP, or NFS are.
Such gadget-side interface drivers should eventually be combined,
to implement composite devices.
Kernel Mode Gadget APIGadget drivers declare themselves through a
struct usb_gadget_driver, which is responsible for
most parts of enumeration for a struct usb_gadget.
The response to a set_configuration usually involves
enabling one or more of the struct usb_ep objects
exposed by the gadget, and submitting one or more
struct usb_request buffers to transfer data.
Understand those four data types, and their operations, and
you will understand how this API works.
Incomplete Data Type DescriptionsThis documentation was prepared using the standard Linux
kernel docproc tool, which turns text
and in-code comments into SGML DocBook and then into usable
formats such as HTML or PDF.
Other than the &quot;Chapter 9&quot; data types, most of the significant
data types and functions are described here.
However, docproc does not understand all the C constructs
that are used, so some relevant information is likely omitted from
what you are reading.
One example of such information is endpoint autoconfiguration.
You&#39;ll have to read the header file, and use example source
code (such as that for &quot;Gadget Zero&quot;), to fully understand the API.
The part of the API implementing some basic
driver capabilities is specific to the version of the
Linux kernel that&#39;s in use.
The 2.6 kernel includes a driver model
framework that has no analogue on earlier kernels;
so those parts of the gadget API are not fully portable.
(They are implemented on 2.4 kernels, but in a different way.)
The driver model state is another part of this API that is
ignored by the kerneldoc tools.
The core API does not expose
every possible hardware feature, only the most widely available ones.
There are significant hardware features, such as device-to-device DMA
(without temporary storage in a memory buffer)
that would be added using hardware-specific APIs.
This API allows drivers to use conditional compilation to handle
endpoint capabilities of different hardware, but doesn&#39;t require that.
Hardware tends to have arbitrary restrictions, relating to
transfer types, addressing, packet sizes, buffering, and availability.
As a rule, such differences only matter for &quot;endpoint zero&quot; logic
that handles device configuration and management.
The API supports limited run-time
detection of capabilities, through naming conventions for endpoints.
Many drivers will be able to at least partially autoconfigure
themselves.
In particular, driver init sections will often have endpoint
autoconfiguration logic that scans the hardware&#39;s list of endpoints
to find ones matching the driver requirements
(relying on those conventions), to eliminate some of the most
common reasons for conditional compilation.
Like the Linux-USB host side API, this API exposes
the &quot;chunky&quot; nature of USB messages:  I/O requests are in terms
of one or more &quot;packets&quot;, and packet boundaries are visible to drivers.
Compared to RS-232 serial protocols, USB resembles
synchronous protocols like HDLC
(N bytes per frame, multipoint addressing, host as the primary
station and devices as secondary stations)
more than asynchronous ones
(tty style:  8 data bits per frame, no parity, one stop bit).
So for example the controller drivers won&#39;t buffer
two single byte writes into a single two-byte USB IN packet,
although gadget drivers may do so when they implement
protocols where packet boundaries (and &quot;short packets&quot;)
are not significant.
Driver Life CycleGadget drivers make endpoint I/O requests to hardware without
needing to know many details of the hardware, but driver
setup/configuration code needs to handle some differences.
Use the API like this:
Register a driver for the particular device side
usb controller hardware,
such as the net2280 on PCI (USB 2.0),
sa11x0 or pxa25x as found in Linux PDAs,
and so on.
At this point the device is logically in the USB ch9 initial state
(&quot;attached&quot;), drawing no power and not usable
(since it does not yet support enumeration).
Any host should not see the device, since it&#39;s not
activated the data line pullup used by the host to
detect a device, even if VBUS power is available.
Register a gadget driver that implements some higher level
device function.  That will then bind() to a usb_gadget, which
activates the data line pullup sometime after detecting VBUS.
The hardware driver can now start enumerating.
The steps it handles are to accept USB power and set_address requests.
Other steps are handled by the gadget driver.
If the gadget driver module is unloaded before the host starts to
enumerate, steps before step 7 are skipped.
The gadget driver&#39;s setup() call returns usb descriptors,
based both on what the bus interface hardware provides and on the
functionality being implemented.
That can involve alternate settings or configurations,
unless the hardware prevents such operation.
For OTG devices, each configuration descriptor includes
an OTG descriptor.
The gadget driver handles the last step of enumeration,
when the USB host issues a set_configuration call.
It enables all endpoints used in that configuration,
with all interfaces in their default settings.
That involves using a list of the hardware&#39;s endpoints, enabling each
endpoint according to its descriptor.
It may also involve using usb_gadget_vbus_draw
to let more power be drawn from VBUS, as allowed by that configuration.
For OTG devices, setting a configuration may also involve reporting
HNP capabilities through a user interface.
Do real work and perform data transfers, possibly involving
changes to interface settings or switching to new configurations, until the
device is disconnect()ed from the host.
Queue any number of transfer requests to each endpoint.
It may be suspended and resumed several times before being disconnected.
On disconnect, the drivers go back to step 3 (above).
When the gadget driver module is being unloaded,
the driver unbind() callback is issued.  That lets the controller
driver be unloaded.
Drivers will normally be arranged so that just loading the
gadget driver module (or statically linking it into a Linux kernel)
allows the peripheral device to be enumerated, but some drivers
will defer enumeration until some higher level component (like
a user mode daemon) enables it.
Note that at this lowest level there are no policies about how
ep0 configuration logic is implemented,
except that it should obey USB specifications.
Such issues are in the domain of gadget drivers,
including knowing about implementation constraints
imposed by some USB controllers
or understanding that composite devices might happen to
be built by integrating reusable components.
Note that the lifecycle above can be slightly different
for OTG devices.
Other than providing an additional OTG descriptor in each
configuration, only the HNP-related differences are particularly
visible to driver code.
They involve reporting requirements during the SET_CONFIGURATION
request, and the option to invoke HNP during some suspend callbacks.
Also, SRP changes the semantics of
usb_gadget_wakeup
slightly.
USB 2.0 Chapter 9 Types and ConstantsGadget drivers
rely on common USB structures and constants
defined in the
&amp;lt;linux/usb/ch9.h&amp;gt;
header file, which is standard in Linux 2.6 kernels.
These are the same types and constants used by host
side drivers (and usbcore).


Core Objects and MethodsThese are declared in
&amp;lt;linux/usb/gadget.h&amp;gt;,
and are used by gadget drivers to interact with
USB peripheral controller drivers.
&lt;!-- yeech, this is ugly in nsgmls PDF output.

the PDF bookmark and refentry output nesting is wrong,
and the member/argument documentation indents ugly.

plus something (docproc?) adds whitespace before the
descriptive paragraph text, so it can&#39;t line up right
unless the explanations are trivial.
--&gt;

Optional UtilitiesThe core API is sufficient for writing a USB Gadget Driver,
but some optional utilities are provided to simplify common tasks.
These utilities include endpoint autoconfiguration.


&lt;!-- !Edrivers/usb/gadget/epautoconf.c --&gt;
Composite Device FrameworkThe core API is sufficient for writing drivers for composite
USB devices (with more than one function in a given configuration),
and also multi-configuration devices (also more than one function,
but not necessarily sharing a given configuration).
There is however an optional framework which makes it easier to
reuse and combine functions.
Devices using this framework provide a struct
usb_composite_driver, which in turn provides one or
more struct usb_configuration instances.
Each such configuration includes at least one
struct usb_function, which packages a user
visible role such as &quot;network link&quot; or &quot;mass storage device&quot;.
Management functions may also exist, such as &quot;Device Firmware
Upgrade&quot;.



Composite Device FunctionsAt this writing, a few of the current gadget drivers have
been converted to this framework.
Near-term plans include converting all of them, except for &quot;gadgetfs&quot;.



Peripheral Controller DriversThe first hardware supporting this API was the NetChip 2280
controller, which supports USB 2.0 high speed and is based on PCI.
This is the net2280 driver module.
The driver supports Linux kernel versions 2.4 and 2.6;
contact NetChip Technologies for development boards and product
information.
Other hardware working in the &quot;gadget&quot; framework includes:
Intel&#39;s PXA 25x and IXP42x series processors
(pxa2xx_udc),
Toshiba TC86c001 &quot;Goku-S&quot; (goku_udc),
Renesas SH7705/7727 (sh_udc),
MediaQ 11xx (mq11xx_udc),
Hynix HMS30C7202 (h7202_udc),
National 9303/4 (n9604_udc),
Texas Instruments OMAP (omap_udc),
Sharp LH7A40x (lh7a40x_udc),
and more.
Most of those are full speed controllers.
At this writing, there are people at work on drivers in
this framework for several other USB device controllers,
with plans to make many of them be widely available.
&lt;!-- !Edrivers/usb/gadget/net2280.c --&gt;A partial USB simulator,
the dummy_hcd driver, is available.
It can act like a net2280, a pxa25x, or an sa11x0 in terms
of available endpoints and device speeds; and it simulates
control, bulk, and to some extent interrupt transfers.
That lets you develop some parts of a gadget driver on a normal PC,
without any special hardware, and perhaps with the assistance
of tools such as GDB running with User Mode Linux.
At least one person has expressed interest in adapting that
approach, hooking it up to a simulator for a microcontroller.
Such simulators can help debug subsystems where the runtime hardware
is unfriendly to software development, or is not yet available.
Support for other controllers is expected to be developed
and contributed
over time, as this driver framework evolves.
Gadget DriversIn addition to Gadget Zero
(used primarily for testing and development with drivers
for usb controller hardware), other gadget drivers exist.
There&#39;s an ethernet gadget
driver, which implements one of the most useful
Communications Device Class (CDC) models.
One of the standards for cable modem interoperability even
specifies the use of this ethernet model as one of two
mandatory options.
Gadgets using this code look to a USB host as if they&#39;re
an Ethernet adapter.
It provides access to a network where the gadget&#39;s CPU is one host,
which could easily be bridging, routing, or firewalling
access to other networks.
Since some hardware can&#39;t fully implement the CDC Ethernet
requirements, this driver also implements a &quot;good parts only&quot;
subset of CDC Ethernet.
(That subset doesn&#39;t advertise itself as CDC Ethernet,
to avoid creating problems.)
Support for Microsoft&#39;s RNDIS
protocol has been contributed by Pengutronix and Auerswald GmbH.
This is like CDC Ethernet, but it runs on more slightly USB hardware
(but less than the CDC subset).
However, its main claim to fame is being able to connect directly to
recent versions of Windows, using drivers that Microsoft bundles
and supports, making it much simpler to network with Windows.
There is also support for user mode gadget drivers,
using gadgetfs.
This provides a User Mode API that presents
each endpoint as a single file descriptor.  I/O is done using
normal read() and read() calls.
Familiar tools like GDB and pthreads can be used to
develop and debug user mode drivers, so that once a robust
controller driver is available many applications for it
won&#39;t require new kernel mode software.
Linux 2.6 Async I/O (AIO)
support is available, so that user mode software
can stream data with only slightly more overhead
than a kernel driver.
There&#39;s a USB Mass Storage class driver, which provides
a different solution for interoperability with systems such
as MS-Windows and MacOS.
That Mass Storage driver uses a
file or block device as backing store for a drive,
like the loop driver.
The USB host uses the BBB, CB, or CBI versions of the mass
storage class specification, using transparent SCSI commands
to access the data from the backing store.
There&#39;s a &quot;serial line&quot; driver, useful for TTY style
operation over USB.
The latest version of that driver supports CDC ACM style
operation, like a USB modem, and so on most hardware it can
interoperate easily with MS-Windows.
One interesting use of that driver is in boot firmware (like a BIOS),
which can sometimes use that model with very small systems without
real serial lines.
Support for other kinds of gadget is expected to
be developed and contributed
over time, as this driver framework evolves.
USB On-The-GO (OTG)USB OTG support on Linux 2.6 was initially developed
by Texas Instruments for
OMAP 16xx and 17xx
series processors.
Other OTG systems should work in similar ways, but the
hardware level details could be very different.
Systems need specialized hardware support to implement OTG,
notably including a special Mini-AB jack
and associated transciever to support Dual-Role
operation:
they can act either as a host, using the standard
Linux-USB host side driver stack,
or as a peripheral, using this &quot;gadget&quot; framework.
To do that, the system software relies on small additions
to those programming interfaces,
and on a new internal component (here called an &quot;OTG Controller&quot;)
affecting which driver stack connects to the OTG port.
In each role, the system can re-use the existing pool of
hardware-neutral drivers, layered on top of the controller
driver interfaces (usb_bus or
usb_gadget).
Such drivers need at most minor changes, and most of the calls
added to support OTG can also benefit non-OTG products.
Gadget drivers test the is_otg
flag, and use it to determine whether or not to include
an OTG descriptor in each of their configurations.
Gadget drivers may need changes to support the
two new OTG protocols, exposed in new gadget attributes
such as b_hnp_enable flag.
HNP support should be reported through a user interface
(two LEDs could suffice), and is triggered in some cases
when the host suspends the peripheral.
SRP support can be user-initiated just like remote wakeup,
probably by pressing the same button.
On the host side, USB device drivers need
to be taught to trigger HNP at appropriate moments, using
usb_suspend_device().
That also conserves battery power, which is useful even
for non-OTG configurations.
Also on the host side, a driver must support the
OTG &quot;Targeted Peripheral List&quot;.  That&#39;s just a whitelist,
used to reject peripherals not supported with a given
Linux OTG host.
This whitelist is product-specific;
each product must modify otg_whitelist.h
to match its interoperability specification.

Non-OTG Linux hosts, like PCs and workstations,
normally have some solution for adding drivers, so that
peripherals that aren&#39;t recognized can eventually be supported.
That approach is unreasonable for consumer products that may
never have their firmware upgraded, and where it&#39;s usually
unrealistic to expect traditional PC/workstation/server kinds
of support model to work.
For example, it&#39;s often impractical to change device firmware
once the product has been distributed, so driver bugs can&#39;t
normally be fixed if they&#39;re found after shipment.

Additional changes are needed below those hardware-neutral
usb_bus and usb_gadget
driver interfaces; those aren&#39;t discussed here in any detail.
Those affect the hardware-specific code for each USB Host or Peripheral
controller, and how the HCD initializes (since OTG can be active only
on a single port).
They also involve what may be called an OTG Controller
Driver, managing the OTG transceiver and the OTG state
machine logic as well as much of the root hub behavior for the
OTG port.
The OTG controller driver needs to activate and deactivate USB
controllers depending on the relevant device role.
Some related changes were needed inside usbcore, so that it
can identify OTG-capable devices and respond appropriately
to HNP or SRP protocols.
&lt;!--
vim:syntax=sgml:sw=4
--&gt;Linux generic IRQ handlingThomasGleixnertglx@linutronix.deIngoMolnarmingo@elte.hu2005-2010Thomas Gleixner2005-2006Ingo Molnar
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
The generic interrupt handling layer is designed to provide a
complete abstraction of interrupt handling for device drivers.
It is able to handle all the different types of interrupt controller
hardware. Device drivers use generic API functions to request, enable,
disable and free interrupts. The drivers do not have to know anything
about interrupt hardware details, so they can be used on different
platforms without code changes.

This documentation is provided to developers who want to implement
an interrupt subsystem based for their architecture, with the help
of the generic IRQ handling layer.
Rationale
The original implementation of interrupt handling in Linux uses
the __do_IRQ() super-handler, which is able to deal with every
type of interrupt logic.

Originally, Russell King identified different types of handlers to
build a quite universal set for the ARM interrupt handler
implementation in Linux 2.5/2.6. He distinguished between:
Level typeEdge typeSimple type
During the implementation we identified another type:
Fast EOI type
In the SMP world of the __do_IRQ() super-handler another type
was identified:
Per CPU type

This split implementation of high-level IRQ handlers allows us to
optimize the flow of the interrupt handling for each specific
interrupt type. This reduces complexity in that particular code path
and allows the optimized handling of a given type.

The original general IRQ implementation used hw_interrupt_type
structures and their -&amp;gt;ack(), -&amp;gt;end() [etc.] callbacks to
differentiate the flow control in the super-handler. This leads to
a mix of flow logic and low-level hardware logic, and it also leads
to unnecessary code duplication: for example in i386, there is an
ioapic_level_irq and an ioapic_edge_irq IRQ-type which share many
of the low-level details but have different flow handling.

A more natural abstraction is the clean separation of the
&#39;irq flow&#39; and the &#39;chip details&#39;.

Analysing a couple of architecture&#39;s IRQ subsystem implementations
reveals that most of them can use a generic set of &#39;irq flow&#39;
methods and only need to add the chip-level specific code.
The separation is also valuable for (sub)architectures
which need specific quirks in the IRQ flow itself but not in the
chip details - and thus provides a more transparent IRQ subsystem
design.

Each interrupt descriptor is assigned its own high-level flow
handler, which is normally one of the generic
implementations. (This high-level flow handler implementation also
makes it simple to provide demultiplexing handlers which can be
found in embedded platforms on various architectures.)

The separation makes the generic interrupt handling layer more
flexible and extensible. For example, an (sub)architecture can
use a generic IRQ-flow implementation for &#39;level type&#39; interrupts
and add a (sub)architecture specific &#39;edge type&#39; implementation.

To make the transition to the new model easier and prevent the
breakage of existing implementations, the __do_IRQ() super-handler
is still available. This leads to a kind of duality for the time
being. Over time the new model should be used in more and more
architectures, as it enables smaller and cleaner IRQ subsystems.
It&#39;s deprecated for three years now and about to be removed.
Known Bugs And Assumptions
None (knock on wood).
Abstraction layers
There are three main levels of abstraction in the interrupt code:
High-level driver APIHigh-level IRQ flow handlersChip-level hardware encapsulation
Interrupt control flow
Each interrupt is described by an interrupt descriptor structure
irq_desc. The interrupt is referenced by an &#39;unsigned int&#39; numeric
value which selects the corresponding interrupt decription structure
in the descriptor structures array.
The descriptor structure contains status information and pointers
to the interrupt flow method and the interrupt chip structure
which are assigned to this interrupt.

Whenever an interrupt triggers, the low-level architecture code calls
into the generic interrupt code by calling desc-&amp;gt;handle_irq().
This high-level IRQ handling function only uses desc-&amp;gt;irq_data.chip
primitives referenced by the assigned chip descriptor structure.
High-level Driver API
The high-level Driver API consists of following functions:
request_irq()free_irq()disable_irq()enable_irq()disable_irq_nosync() (SMP only)synchronize_irq() (SMP only)irq_set_irq_type()irq_set_irq_wake()irq_set_handler_data()irq_set_chip()irq_set_chip_data()
See the autogenerated function documentation for details.
High-level IRQ flow handlers
The generic layer provides a set of pre-defined irq-flow methods:
handle_level_irqhandle_edge_irqhandle_fasteoi_irqhandle_simple_irqhandle_percpu_irqhandle_edge_eoi_irqhandle_bad_irq
The interrupt flow handlers (either pre-defined or architecture
specific) are assigned to specific interrupts by the architecture
either during bootup or during device initialization.
Default flow implementationsHelper functions
The helper functions call the chip primitives and
are used by the default flow implementations.
The following helper functions are implemented (simplified excerpt):

default_enable(struct irq_data *data)
{
desc-&amp;gt;irq_data.chip-&amp;gt;irq_unmask(data);
}

default_disable(struct irq_data *data)
{
if (!delay_disable(data))
desc-&amp;gt;irq_data.chip-&amp;gt;irq_mask(data);
}

default_ack(struct irq_data *data)
{
chip-&amp;gt;irq_ack(data);
}

default_mask_ack(struct irq_data *data)
{
if (chip-&amp;gt;irq_mask_ack) {
chip-&amp;gt;irq_mask_ack(data);
} else {
chip-&amp;gt;irq_mask(data);
chip-&amp;gt;irq_ack(data);
}
}

noop(struct irq_data *data))
{
}


Default flow handler implementationsDefault Level IRQ flow handler
handle_level_irq provides a generic implementation
for level-triggered interrupts.

The following control flow is implemented (simplified excerpt):

desc-&amp;gt;irq_data.chip-&amp;gt;irq_mask_ack();
handle_irq_event(desc-&amp;gt;action);
desc-&amp;gt;irq_data.chip-&amp;gt;irq_unmask();

Default Fast EOI IRQ flow handler
handle_fasteoi_irq provides a generic implementation
for interrupts, which only need an EOI at the end of
the handler.

The following control flow is implemented (simplified excerpt):

handle_irq_event(desc-&amp;gt;action);
desc-&amp;gt;irq_data.chip-&amp;gt;irq_eoi();

Default Edge IRQ flow handler
handle_edge_irq provides a generic implementation
for edge-triggered interrupts.

The following control flow is implemented (simplified excerpt):

if (desc-&amp;gt;status &amp;amp; running) {
desc-&amp;gt;irq_data.chip-&amp;gt;irq_mask_ack();
desc-&amp;gt;status |= pending | masked;
return;
}
desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack();
desc-&amp;gt;status |= running;
do {
if (desc-&amp;gt;status &amp;amp; masked)
desc-&amp;gt;irq_data.chip-&amp;gt;irq_unmask();
desc-&amp;gt;status &amp;amp;= ~pending;
handle_irq_event(desc-&amp;gt;action);
} while (status &amp;amp; pending);
desc-&amp;gt;status &amp;amp;= ~running;

Default simple IRQ flow handler
handle_simple_irq provides a generic implementation
for simple interrupts.

Note: The simple flow handler does not call any
handler/chip primitives.

The following control flow is implemented (simplified excerpt):

handle_irq_event(desc-&amp;gt;action);

Default per CPU flow handler
handle_percpu_irq provides a generic implementation
for per CPU interrupts.

Per CPU interrupts are only available on SMP and
the handler provides a simplified version without
locking.

The following control flow is implemented (simplified excerpt):

if (desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack)
desc-&amp;gt;irq_data.chip-&amp;gt;irq_ack();
handle_irq_event(desc-&amp;gt;action);
if (desc-&amp;gt;irq_data.chip-&amp;gt;irq_eoi)
desc-&amp;gt;irq_data.chip-&amp;gt;irq_eoi();

EOI Edge IRQ flow handler
handle_edge_eoi_irq provides an abnomination of the edge
handler which is solely used to tame a badly wreckaged
irq controller on powerpc/cell.
Bad IRQ flow handler
handle_bad_irq is used for spurious interrupts which
have no real handler assigned..
Quirks and optimizations
The generic functions are intended for &#39;clean&#39; architectures and chips,
which have no platform-specific IRQ handling quirks. If an architecture
needs to implement quirks on the &#39;flow&#39; level then it can do so by
overriding the high-level irq-flow handler.
Delayed interrupt disable
This per interrupt selectable feature, which was introduced by Russell
King in the ARM interrupt implementation, does not mask an interrupt
at the hardware level when disable_irq() is called. The interrupt is
kept enabled and is masked in the flow handler when an interrupt event
happens. This prevents losing edge interrupts on hardware which does
not store an edge interrupt event while the interrupt is disabled at
the hardware level. When an interrupt arrives while the IRQ_DISABLED
flag is set, then the interrupt is masked at the hardware level and
the IRQ_PENDING bit is set. When the interrupt is re-enabled by
enable_irq() the pending bit is checked and if it is set, the
interrupt is resent either via hardware or by a software resend
mechanism. (It&#39;s necessary to enable CONFIG_HARDIRQS_SW_RESEND when
you want to use the delayed interrupt disable feature and your
hardware is not capable of retriggering    an interrupt.)
The delayed interrupt disable is not configurable.
Chip-level hardware encapsulation
The chip-level hardware descriptor structure irq_chip
contains all the direct chip relevant functions, which
can be utilized by the irq flow implementations.
irq_ack()irq_mask_ack() - Optional, recommended for performanceirq_mask()irq_unmask()irq_eoi() - Optional, required for EOI flow handlersirq_retrigger() - Optionalirq_set_type() - Optionalirq_set_wake() - Optional
These primitives are strictly intended to mean what they say: ack means
ACK, masking means masking of an IRQ line, etc. It is up to the flow
handler(s) to use these basic units of low-level functionality.
__do_IRQ entry point
The original implementation __do_IRQ() was an alternative entry
point for all types of interrupts. It no longer exists.

This handler turned out to be not suitable for all
interrupt hardware and was therefore reimplemented with split
functionality for edge/level/simple/percpu interrupts. This is not
only a functional optimization. It also shortens code paths for
interrupts.
Locking on SMP
The locking of chip registers is up to the architecture that
defines the chip primitives. The per-irq structure is
protected via desc-&amp;gt;lock, by the generic layer.
Generic interrupt chip
To avoid copies of identical implementations of IRQ chips the
core provides a configurable generic interrupt chip
implementation. Developers should check carefuly whether the
generic chip fits their needs before implementing the same
functionality slightly differently themselves.

Structures
This chapter contains the autogenerated documentation of the structures which are
used in the generic IRQ layer.

Public Functions Provided
This chapter contains the autogenerated documentation of the kernel API functions
which are exported.

Internal Functions Provided
This chapter contains the autogenerated documentation of the internal functions.

Credits
The following people have contributed to this document:
Thomas Gleixnertglx@linutronix.deIngo Molnarmingo@elte.hu
The Linux Kernel API
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Data TypesDoubly Linked Lists
Basic C Library Functions
When writing drivers, you cannot in general use routines which are
from the C Library.  Some of the functions have been found generally
useful and they are listed below.  The behaviour of these functions
may vary slightly from those defined by ANSI, and these deviations
are noted in the text.
String Conversions
String Manipulation&lt;!-- All functions are exported at now
X!Ilib/string.c
--&gt;
Bit Operations
Basic Kernel Library Functions
The Linux kernel provides more basic utility functions.
Bitmap Operations
Command-line Parsing
CRC Functions
idr/ida Functions
Memory Management in LinuxThe Slab Cache
User Space Memory Access
More Memory Management Functions
Kernel IPC facilitiesIPC utilities
FIFO Bufferkfifo interface
relay interface support
Relay interface support
is designed to provide an efficient mechanism for tools and
facilities to relay large amounts of data from kernel space to
user space.
relay interface
Module SupportModule Loading
Inter Module support
Refer to the file kernel/module.c for more information.
&lt;!-- FIXME: Removed for now since no structured comments in source
X!Ekernel/module.c
--&gt;Hardware InterfacesInterrupt Handling
DMA Channels
Resources Management
MTRR Handling
PCI Support Library
&lt;!-- FIXME: Removed for now since no structured comments in source
X!Edrivers/pci/hotplug.c
--&gt;
PCI Hotplug Support Library
Firmware InterfacesDMI Interfaces
EDD Interfaces
Security Framework
Audit Interfaces
Accounting Framework
Block Devices
Char devices
Miscellaneous Devices
Clock Framework
The clock framework defines programming interfaces to support
software management of the system clock tree.
This framework is widely used with System-On-Chip (SOC) platforms
to support power management and various devices which may need
custom clock rates.
Note that these &quot;clocks&quot; don&#39;t relate to timekeeping or real
time clocks (RTCs), each of which have separate frameworks.
These struct clk instances may be used
to manage for example a 96 MHz signal that is used to shift bits
into and out of peripherals or busses, or otherwise trigger
synchronous state machine transitions in system hardware.

Power management is supported by explicit software clock gating:
unused clocks are disabled, so the system doesn&#39;t waste power
changing the state of transistors that aren&#39;t in active use.
On some systems this may be backed by hardware clock gating,
where clocks are gated without being disabled in software.
Sections of chips that are powered but not clocked may be able
to retain their last state.
This low power state is often called a retention
mode.
This mode still incurs leakage currents, especially with finer
circuit geometries, but for CMOS circuits power is mostly used
by clocked state changes.

Power-aware drivers only enable their clocks when the device
they manage is in active use.  Also, system sleep states often
differ according to which clock domains are active:  while a
&quot;standby&quot; state may allow wakeup from several active domains, a
&quot;mem&quot; (suspend-to-RAM) state may require a more wholesale shutdown
of clocks derived from higher speed PLLs and oscillators, limiting
the number of possible wakeup event sources.  A driver&#39;s suspend
method may need to be aware of system-specific clock constraints
on the target sleep state.

Some platforms support programmable clock generators.  These
can be used by external chips of various kinds, such as other
CPUs, multimedia codecs, and devices with strict requirements
for interface clocking.


Unreliable Guide To Hacking The Linux KernelRustyRussellrusty@rustcorp.com.au2005Rusty Russell
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.

This is the first release of this document as part of the kernel tarball.
Introduction
Welcome, gentle reader, to Rusty&#39;s Remarkably Unreliable Guide to Linux
Kernel Hacking.  This document describes the common routines and
general requirements for kernel code: its goal is to serve as a
primer for Linux kernel development for experienced C
programmers.  I avoid implementation details: that&#39;s what the
code is for, and I ignore whole tracts of useful routines.

Before you read this, please understand that I never wanted to
write this document, being grossly under-qualified, but I always
wanted to read it, and this was the only way.  I hope it will
grow into a compendium of best practice, common starting points
and random information.
The Players
At any time each of the CPUs in a system can be:

not associated with any process, serving a hardware interrupt;

not associated with any process, serving a softirq or tasklet;

running in kernel space, associated with a process (user context);

running a process in user space.

There is an ordering between these.  The bottom two can preempt
each other, but above that is a strict hierarchy: each can only be
preempted by the ones above it.  For example, while a softirq is
running on a CPU, no other softirq will preempt it, but a hardware
interrupt can.  However, any other CPUs in the system execute
independently.

We&#39;ll see a number of ways that the user context can block
interrupts, to become truly non-preemptable.
User Context
User context is when you are coming in from a system call or other
trap: like userspace, you can be preempted by more important tasks
and by interrupts.  You can sleep, by calling
schedule().

You are always in user context on module load and unload,
and on operations on the block device layer.

In user context, the current pointer (indicating
the task we are currently executing) is valid, and
in_interrupt()
(include/linux/interrupt.h) is false
.

Beware that if you have preemption or softirqs disabled
(see below), in_interrupt() will return a
false positive.
Hardware Interrupts (Hard IRQs)
Timer ticks, network cards and
keyboard are examples of real
hardware which produce interrupts at any time.  The kernel runs
interrupt handlers, which services the hardware.  The kernel
guarantees that this handler is never re-entered: if the same
interrupt arrives, it is queued (or dropped).  Because it
disables interrupts, this handler has to be fast: frequently it
simply acknowledges the interrupt, marks a &#39;software interrupt&#39;
for execution and exits.

You can tell you are in a hardware interrupt, because
in_irq() returns true.

Beware that this will return a false positive if interrupts are disabled
(see below).
Software Interrupt Context: Softirqs and Tasklets
Whenever a system call is about to return to userspace, or a
hardware interrupt handler exits, any &#39;software interrupts&#39;
which are marked pending (usually by hardware interrupts) are
run (kernel/softirq.c).

Much of the real interrupt handling work is done here.  Early in
the transition to SMP, there were only &#39;bottom
halves&#39; (BHs), which didn&#39;t take advantage of multiple CPUs.  Shortly
after we switched from wind-up computers made of match-sticks and snot,
we abandoned this limitation and switched to &#39;softirqs&#39;.
include/linux/interrupt.h lists the
different softirqs.  A very important softirq is the
timer softirq (include/linux/timer.h): you can
register to have it call functions for you in a given length of
time.

Softirqs are often a pain to deal with, since the same softirq
will run simultaneously on more than one CPU.  For this reason,
tasklets (include/linux/interrupt.h) are more
often used: they are dynamically-registrable (meaning you can have
as many as you want), and they also guarantee that any tasklet
will only run on one CPU at any time, although different tasklets
can run simultaneously.

The name &#39;tasklet&#39; is misleading: they have nothing to do with &#39;tasks&#39;,
and probably more to do with some bad vodka Alexey Kuznetsov had at the
time.

You can tell you are in a softirq (or tasklet)
using the in_softirq() macro
(include/linux/interrupt.h).

Beware that this will return a false positive if a bh lock (see below)
is held.
Some Basic RulesNo memory protection
If you corrupt memory, whether in user context or
interrupt context, the whole machine will crash.  Are you
sure you can&#39;t do what you want in userspace?
No floating point or MMX
The FPU context is not saved; even in user
context the FPU state probably won&#39;t
correspond with the current process: you would mess with some
user process&#39; FPU state.  If you really want
to do this, you would have to explicitly save/restore the full
FPU state (and avoid context switches).  It
is generally a bad idea; use fixed point arithmetic first.
A rigid stack limit
Depending on configuration options the kernel stack is about 3K to 6K for most 32-bit architectures: it&#39;s
about 14K on most 64-bit archs, and often shared with interrupts
so you can&#39;t use it all.  Avoid deep recursion and huge local
arrays on the stack (allocate them dynamically instead).
The Linux kernel is portable
Let&#39;s keep it that way.  Your code should be 64-bit clean,
and endian-independent.  You should also minimize CPU
specific stuff, e.g. inline assembly should be cleanly
encapsulated and minimized to ease porting.  Generally it
should be restricted to the architecture-dependent part of
the kernel tree.
ioctls: Not writing a new system call
A system call generally looks like this

asmlinkage long sys_mycall(int arg)
{
return 0;
}

First, in most cases you don&#39;t want to create a new system call.
You create a character device and implement an appropriate ioctl
for it.  This is much more flexible than system calls, doesn&#39;t have
to be entered in every architecture&#39;s
include/asm/unistd.h and
arch/kernel/entry.S file, and is much more
likely to be accepted by Linus.

If all your routine does is read or write some parameter, consider
implementing a sysfs interface instead.

Inside the ioctl you&#39;re in user context to a process.  When a
error occurs you return a negated errno (see
include/linux/errno.h),
otherwise you return 0.

After you slept you should check if a signal occurred: the
Unix/Linux way of handling signals is to temporarily exit the
system call with the -ERESTARTSYS error.  The
system call entry code will switch back to user context, process
the signal handler and then your system call will be restarted
(unless the user disabled that).  So you should be prepared to
process the restart, e.g. if you&#39;re in the middle of manipulating
some data structure.

if (signal_pending(current))
return -ERESTARTSYS;

If you&#39;re doing longer computations: first think userspace. If you
really want to do it in kernel you should
regularly check if you need to give up the CPU (remember there is
cooperative multitasking per CPU).  Idiom:

cond_resched(); /* Will sleep */

A short note on interface design: the UNIX system call motto is
&quot;Provide mechanism not policy&quot;.
Recipes for Deadlock
You cannot call any routines which may sleep, unless:

You are in user context.

You do not own any spinlocks.

You have interrupts enabled (actually, Andi Kleen says
that the scheduling code will enable them for you, but
that&#39;s probably not what you wanted).

Note that some functions may sleep implicitly: common ones are
the user space access functions (*_user) and memory allocation
functions without GFP_ATOMIC.

You should always compile your kernel
CONFIG_DEBUG_ATOMIC_SLEEP on, and it will warn
you if you break these rules.  If you do break
the rules, you will eventually lock up your box.

Really.
Common Routinesprintk()include/linux/kernel.hprintk() feeds kernel messages to the
console, dmesg, and the syslog daemon.  It is useful for debugging
and reporting errors, and can be used inside interrupt context,
but use with caution: a machine which has its console flooded with
printk messages is unusable.  It uses a format string mostly
compatible with ANSI C printf, and C string concatenation to give
it a first &quot;priority&quot; argument:

printk(KERN_INFO &quot;i = %u\n&quot;, i);

See include/linux/kernel.h;
for other KERN_ values; these are interpreted by syslog as the
level.  Special case: for printing an IP address use

__be32 ipaddress;
printk(KERN_INFO &quot;my ip: %pI4\n&quot;, &amp;amp;ipaddress);
printk() internally uses a 1K buffer and does
not catch overruns.  Make sure that will be enough.

You will know when you are a real kernel hacker
when you start typoing printf as printk in your user programs :)
&lt;!--- From the Lions book reader department --&gt;
Another sidenote: the original Unix Version 6 sources had a
comment on top of its printf function: &quot;Printf should not be
used for chit-chat&quot;.  You should follow that advice.
copy_[to/from]_user()
/
get_user()
/
put_user()
include/asm/uaccess.h
[SLEEPS]put_user() and get_user()
are used to get and put single values (such as an int, char, or
long) from and to userspace.  A pointer into userspace should
never be simply dereferenced: data should be copied using these
routines.  Both return -EFAULT or 0.
copy_to_user() and
copy_from_user() are more general: they copy
an arbitrary amount of data to and from userspace.

Unlike put_user() and
get_user(), they return the amount of
uncopied data (ie. 0 still means
success).

[Yes, this moronic interface makes me cringe.  The flamewar comes up every year or so. --RR.]

The functions may sleep implicitly. This should never be called
outside user context (it makes no sense), with interrupts
disabled, or a spinlock held.
kmalloc()/kfree()include/linux/slab.h[MAY SLEEP: SEE BELOW]
These routines are used to dynamically request pointer-aligned
chunks of memory, like malloc and free do in userspace, but
kmalloc() takes an extra flag word.
Important values:

GFP_KERNEL

May sleep and swap to free memory. Only allowed in user
context, but is the most reliable way to allocate memory.

GFP_ATOMIC

Don&#39;t sleep. Less reliable than GFP_KERNEL,
but may be called from interrupt context. You should
really have a good out-of-memory
error-handling strategy.

GFP_DMA

Allocate ISA DMA lower than 16MB. If you don&#39;t know what that
is you don&#39;t need it.  Very unreliable.

If you see a sleeping function called from invalid
context warning message, then maybe you called a
sleeping allocation function from interrupt context without
GFP_ATOMIC.  You should really fix that.
Run, don&#39;t walk.

If you are allocating at least PAGE_SIZE
(include/asm/page.h) bytes,
consider using __get_free_pages()

(include/linux/mm.h).  It
takes an order argument (0 for page sized, 1 for double page, 2
for four pages etc.) and the same memory priority flag word as
above.

If you are allocating more than a page worth of bytes you can use
vmalloc().  It&#39;ll allocate virtual memory in
the kernel map.  This block is not contiguous in physical memory,
but the MMU makes it look like it is for you
(so it&#39;ll only look contiguous to the CPUs, not to external device
drivers).  If you really need large physically contiguous memory
for some weird device, you have a problem: it is poorly supported
in Linux because after some time memory fragmentation in a running
kernel makes it hard.  The best way is to allocate the block early
in the boot process via the alloc_bootmem()
routine.

Before inventing your own cache of often-used objects consider
using a slab cache in
include/linux/slab.h
currentinclude/asm/current.h
This global variable (really a macro) contains a pointer to
the current task structure, so is only valid in user context.
For example, when a process makes a system call, this will
point to the task structure of the calling process.  It is
not NULL in interrupt context.
mdelay()/udelay()include/asm/delay.hinclude/linux/delay.h
The udelay() and ndelay() functions can be used for small pauses.
Do not use large values with them as you risk
overflow - the helper function mdelay() is useful
here, or consider msleep().
cpu_to_be32()/be32_to_cpu()/cpu_to_le32()/le32_to_cpu()include/asm/byteorder.h
The cpu_to_be32() family (where the &quot;32&quot; can
be replaced by 64 or 16, and the &quot;be&quot; can be replaced by &quot;le&quot;) are
the general way to do endian conversions in the kernel: they
return the converted value.  All variations supply the reverse as
well: be32_to_cpu(), etc.

There are two major variations of these functions: the pointer
variation, such as cpu_to_be32p(), which take
a pointer to the given type, and return the converted value.  The
other variation is the &quot;in-situ&quot; family, such as
cpu_to_be32s(), which convert value referred
to by the pointer, and return void.
local_irq_save()/local_irq_restore()include/asm/system.h
These routines disable hard interrupts on the local CPU, and
restore them.  They are reentrant; saving the previous state in
their one unsigned long flags argument.  If you
know that interrupts are enabled, you can simply use
local_irq_disable() and
local_irq_enable().
local_bh_disable()/local_bh_enable()include/linux/interrupt.h
These routines disable soft interrupts on the local CPU, and
restore them.  They are reentrant; if soft interrupts were
disabled before, they will still be disabled after this pair
of functions has been called.  They prevent softirqs and tasklets
from running on the current CPU.
smp_processor_id()
include/asm/smp.hget_cpu() disables preemption (so you won&#39;t
suddenly get moved to another CPU) and returns the current
processor number, between 0 and NR_CPUS.  Note
that the CPU numbers are not necessarily continuous.  You return
it again with put_cpu() when you are done.

If you know you cannot be preempted by another task (ie. you are
in interrupt context, or have preemption disabled) you can use
smp_processor_id().
__init/__exit/__initdatainclude/linux/init.h
After boot, the kernel frees up a special section; functions
marked with __init and data structures marked with
__initdata are dropped after boot is complete: similarly
modules discard this memory after initialization.  __exit
is used to declare a function which is only required on exit: the
function will be dropped if this file is not compiled as a module.
See the header file for use. Note that it makes no sense for a function
marked with __init to be exported to modules with
EXPORT_SYMBOL() - this will break.
__initcall()/module_init()include/linux/init.h
Many parts of the kernel are well served as a module
(dynamically-loadable parts of the kernel).  Using the
module_init() and
module_exit() macros it is easy to write code
without #ifdefs which can operate both as a module or built into
the kernel.

The module_init() macro defines which
function is to be called at module insertion time (if the file is
compiled as a module), or at boot time: if the file is not
compiled as a module the module_init() macro
becomes equivalent to __initcall(), which
through linker magic ensures that the function is called on boot.

The function can return a negative error number to cause
module loading to fail (unfortunately, this has no effect if
the module is compiled into the kernel).  This function is
called in user context with interrupts enabled, so it can sleep.
module_exit()include/linux/init.h
This macro defines the function to be called at module removal
time (or never, in the case of the file compiled into the
kernel).  It will only be called if the module usage count has
reached zero.  This function can also sleep, but cannot fail:
everything must be cleaned up by the time it returns.

Note that this macro is optional: if it is not present, your
module will not be removable (except for &#39;rmmod -f&#39;).
try_module_get()/module_put()include/linux/module.h
These manipulate the module usage count, to protect against
removal (a module also can&#39;t be removed if another module uses one
of its exported symbols: see below).  Before calling into module
code, you should call try_module_get() on
that module: if it fails, then the module is being removed and you
should act as if it wasn&#39;t there.  Otherwise, you can safely enter
the module, and call module_put() when you&#39;re
finished.

Most registerable structures have an
owner field, such as in the
file_operations structure. Set this field
to the macro THIS_MODULE.
&lt;!-- add info on new-style module refcounting here --&gt;Wait Queues
include/linux/wait.h
[SLEEPS]
A wait queue is used to wait for someone to wake you up when a
certain condition is true.  They must be used carefully to ensure
there is no race condition.  You declare a
wait_queue_head_t, and then processes which want to
wait for that condition declare a wait_queue_t
referring to themselves, and place that in the queue.
Declaring
You declare a wait_queue_head_t using the
DECLARE_WAIT_QUEUE_HEAD() macro, or using the
init_waitqueue_head() routine in your
initialization code.
Queuing
Placing yourself in the waitqueue is fairly complex, because you
must put yourself in the queue before checking the condition.
There is a macro to do this:
wait_event_interruptible()

include/linux/wait.h The
first argument is the wait queue head, and the second is an
expression which is evaluated; the macro returns
0 when this expression is true, or
-ERESTARTSYS if a signal is received.
The wait_event() version ignores signals.

Do not use the sleep_on() function family -
it is very easy to accidentally introduce races; almost certainly
one of the wait_event() family will do, or a
loop around schedule_timeout(). If you choose
to loop around schedule_timeout() remember
you must set the task state (with
set_current_state()) on each iteration to avoid
busy-looping.
Waking Up Queued Tasks
Call wake_up()

include/linux/wait.h;,
which will wake up every process in the queue.  The exception is
if one has TASK_EXCLUSIVE set, in which case
the remainder of the queue will not be woken.  There are other variants
of this basic function available in the same header.
Atomic Operations
Certain operations are guaranteed atomic on all platforms.  The
first class of operations work on atomic_t

include/asm/atomic.h; this
contains a signed integer (at least 32 bits long), and you must use
these functions to manipulate or read atomic_t variables.
atomic_read() and
atomic_set() get and set the counter,
atomic_add(),
atomic_sub(),
atomic_inc(),
atomic_dec(), and
atomic_dec_and_test() (returns
true if it was decremented to zero).

Yes.  It returns true (i.e. != 0) if the
atomic variable is zero.

Note that these functions are slower than normal arithmetic, and
so should not be used unnecessarily.

The second class of atomic operations is atomic bit operations on an
unsigned long, defined in

include/linux/bitops.h.  These
operations generally take a pointer to the bit pattern, and a bit
number: 0 is the least significant bit.
set_bit(), clear_bit()
and change_bit() set, clear, and flip the
given bit.  test_and_set_bit(),
test_and_clear_bit() and
test_and_change_bit() do the same thing,
except return true if the bit was previously set; these are
particularly useful for atomically setting flags.

It is possible to call these operations with bit indices greater
than BITS_PER_LONG.  The resulting behavior is strange on big-endian
platforms though so it is a good idea not to do this.
Symbols
Within the kernel proper, the normal linking rules apply
(ie. unless a symbol is declared to be file scope with the
static keyword, it can be used anywhere in the
kernel).  However, for modules, a special exported symbol table is
kept which limits the entry points to the kernel proper.  Modules
can also export symbols.
EXPORT_SYMBOL()include/linux/export.h
This is the classic method of exporting a symbol: dynamically
loaded modules will be able to use the symbol as normal.
EXPORT_SYMBOL_GPL()include/linux/export.h
Similar to EXPORT_SYMBOL() except that the
symbols exported by EXPORT_SYMBOL_GPL() can
only be seen by modules with a
MODULE_LICENSE() that specifies a GPL
compatible license.  It implies that the function is considered
an internal implementation issue, and not really an interface.
Routines and ConventionsDouble-linked lists
include/linux/list.h
There used to be three sets of linked-list routines in the kernel
headers, but this one is the winner.  If you don&#39;t have some
particular pressing need for a single list, it&#39;s a good choice.

In particular, list_for_each_entry is useful.
Return Conventions
For code called in user context, it&#39;s very common to defy C
convention, and return 0 for success,
and a negative error number
(eg. -EFAULT) for failure.  This can be
unintuitive at first, but it&#39;s fairly widespread in the kernel.

Using ERR_PTR()

include/linux/err.h; to
encode a negative error number into a pointer, and
IS_ERR() and PTR_ERR()
to get it back out again: avoids a separate pointer parameter for
the error number.  Icky, but in a good way.
Breaking Compilation
Linus and the other developers sometimes change function or
structure names in development kernels; this is not done just to
keep everyone on their toes: it reflects a fundamental change
(eg. can no longer be called with interrupts on, or does extra
checks, or doesn&#39;t do checks which were caught before).  Usually
this is accompanied by a fairly complete note to the linux-kernel
mailing list; search the archive.  Simply doing a global replace
on the file usually makes things worse.
Initializing structure members
The preferred method of initializing structures is to use
designated initialisers, as defined by ISO C99, eg:

static struct block_device_operations opt_fops = {
.open               = opt_open,
.release            = opt_release,
.ioctl              = opt_ioctl,
.check_media_change = opt_media_change,
};

This makes it easy to grep for, and makes it clear which
structure fields are set.  You should do this because it looks
cool.
GNU Extensions
GNU Extensions are explicitly allowed in the Linux kernel.
Note that some of the more complex ones are not very well
supported, due to lack of general use, but the following are
considered standard (see the GCC info page section &quot;C
Extensions&quot; for more details - Yes, really the info page, the
man page is only a short summary of the stuff in info).

Inline functions

Statement expressions (ie. the ({ and }) constructs).

Declaring attributes of a function / variable / type
(__attribute__)

typeof

Zero length arrays

Macro varargs

Arithmetic on void pointers

Non-Constant initializers

Assembler Instructions (not outside arch/ and include/asm/)

Function names as strings (__func__).

__builtin_constant_p()

Be wary when using long long in the kernel, the code gcc generates for
it is horrible and worse: division and multiplication does not work
on i386 because the GCC runtime functions for it are missing from
the kernel environment.
&lt;!-- FIXME: add a note about ANSI aliasing cleanness --&gt;C++
Using C++ in the kernel is usually a bad idea, because the
kernel does not provide the necessary runtime environment
and the include files are not tested for it.  It is still
possible, but not recommended.  If you really want to do
this, forget about exceptions at least.
&amp;num;if
It is generally considered cleaner to use macros in header files
(or at the top of .c files) to abstract away functions rather than
using `#if&#39; pre-processor statements throughout the source code.
Putting Your Stuff in the Kernel
In order to get your stuff into shape for official inclusion, or
even to make a neat patch, there&#39;s administrative work to be
done:

Figure out whose pond you&#39;ve been pissing in.  Look at the top of
the source files, inside the MAINTAINERS
file, and last of all in the CREDITS file.
You should coordinate with this person to make sure you&#39;re not
duplicating effort, or trying something that&#39;s already been
rejected.

Make sure you put your name and EMail address at the top of
any files you create or mangle significantly.  This is the
first place people will look when they find a bug, or when
they want to make a change.

Usually you want a configuration option for your kernel hack.
Edit Kconfig in the appropriate directory.
The Config language is simple to use by cut and paste, and there&#39;s
complete documentation in
Documentation/kbuild/kconfig-language.txt.

In your description of the option, make sure you address both the
expert user and the user who knows nothing about your feature.  Mention
incompatibilities and issues here.   Definitely
end your description with  if in doubt, say N
(or, occasionally, `Y&#39;); this is for people who have no
idea what you are talking about.

Edit the Makefile: the CONFIG variables are
exported here so you can usually just add a &quot;obj-$(CONFIG_xxx) +=
xxx.o&quot; line.  The syntax is documented in
Documentation/kbuild/makefiles.txt.

Put yourself in CREDITS if you&#39;ve done
something noteworthy, usually beyond a single file (your name
should be at the top of the source files anyway).
MAINTAINERS means you want to be consulted
when changes are made to a subsystem, and hear about bugs; it
implies a more-than-passing commitment to some part of the code.

Finally, don&#39;t forget to read Documentation/SubmittingPatches
and possibly Documentation/SubmittingDrivers.
Kernel Cantrips
Some favorites from browsing the source.  Feel free to add to this
list.
arch/x86/include/asm/delay.h:
#define ndelay(n) (__builtin_constant_p(n) ? \
((n) &amp;gt; 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
__ndelay(n))
include/linux/fs.h:

/*
* Kernel pointers have redundant information, so we can use a
* scheme where we can return either an error code or a dentry
* pointer with the same return value.
*
* This should be a per-architecture thing, to allow different
* error and pointer decisions.
*/
#define ERR_PTR(err)    ((void *)((long)(err)))
#define PTR_ERR(ptr)    ((long)(ptr))
#define IS_ERR(ptr)     ((unsigned long)(ptr) &amp;gt; (unsigned long)(-1000))
arch/x86/include/asm/uaccess_32.h:
#define copy_to_user(to,from,n)                         \
(__builtin_constant_p(n) ?                      \
__constant_copy_to_user((to),(from),(n)) :     \
__generic_copy_to_user((to),(from),(n)))
arch/sparc/kernel/head.S:
/*
* Sun people can&#39;t spell worth damn. &quot;compatability&quot; indeed.
* At least we *know* we can&#39;t spell, and use a spell-checker.
*/

/* Uh, actually Linus it is I who cannot spell. Too much murky
* Sparc assembly will do this to ya.
*/
C_LABEL(cputypvar):
.asciz &quot;compatibility&quot;

/* Tested on SS-5, SS-10. Probably someone at Sun applied a spell-checker. */
.align 4
C_LABEL(cputypvar_sun4m):
.asciz &quot;compatible&quot;
arch/sparc/lib/checksum.S:
/* Sun, you just can&#39;t beat me, you just can&#39;t.  Stop trying,
* give up.  I&#39;m serious, I am going to kick the living shit
* out of you, game over, lights out.
*/
Thanks
Thanks to Andi Kleen for the idea, answering my questions, fixing
my mistakes, filling content, etc.  Philipp Rumpf for more spelling
and clarity fixes, and some excellent non-obvious points.  Werner
Almesberger for giving me a great summary of
disable_irq(), and Jes Sorensen and Andrea
Arcangeli added caveats. Michael Elizabeth Chastain for checking
and adding to the Configure section. &lt;!-- Rusty insisted on this
bit; I didn&#39;t do it! --&gt; Telsa Gwynne for teaching me DocBook.
Unreliable Guide To LockingRustyRussellrusty@rustcorp.com.au2003Rusty Russell
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
Welcome, to Rusty&#39;s Remarkably Unreliable Guide to Kernel
Locking issues.  This document describes the locking systems in
the Linux Kernel in 2.6.

With the wide availability of HyperThreading, and preemption  in the Linux
Kernel, everyone hacking on the kernel needs to know the
fundamentals of concurrency and locking for
SMP.
The Problem With Concurrency
(Skip this if you know what a Race Condition is).

In a normal program, you can increment a counter like so:

very_important_count++;

This is what they would expect to happen:
Expected ResultsInstance 1Instance 2read very_important_count (5)add 1 (6)write very_important_count (6)read very_important_count (6)add 1 (7)write very_important_count (7)
This is what might happen:
Possible ResultsInstance 1Instance 2read very_important_count (5)read very_important_count (5)add 1 (6)add 1 (6)write very_important_count (6)write very_important_count (6)Race Conditions and Critical Regions
This overlap, where the result depends on the
relative timing of multiple tasks, is called a race condition.
The piece of code containing the concurrency issue is called a
critical region.  And especially since Linux starting running
on SMP machines, they became one of the major issues in kernel
design and implementation.

Preemption can have the same effect, even if there is only one
CPU: by preempting one task during the critical region, we have
exactly the same race condition.  In this case the thread which
preempts might run the critical region itself.

The solution is to recognize when these simultaneous accesses
occur, and use locks to make sure that only one instance can
enter the critical region at any time.  There are many
friendly primitives in the Linux kernel to help you do this.
And then there are the unfriendly primitives, but I&#39;ll pretend
they don&#39;t exist.
Locking in the Linux Kernel
If I could give you one piece of advice: never sleep with anyone
crazier than yourself.  But if I had to give you advice on
locking: keep it simple.

Be reluctant to introduce new locks.

Strangely enough, this last one is the exact reverse of my advice when
you have slept with someone crazier than yourself.
And you should think about getting a big dog.
Two Main Types of Kernel Locks: Spinlocks and Mutexes
There are two main types of kernel locks.  The fundamental type
is the spinlock
(include/asm/spinlock.h),
which is a very simple single-holder lock: if you can&#39;t get the
spinlock, you keep trying (spinning) until you can.  Spinlocks are
very small and fast, and can be used anywhere.

The second type is a mutex
(include/linux/mutex.h): it
is like a spinlock, but you may block holding a mutex.
If you can&#39;t lock a mutex, your task will suspend itself, and be woken
up when the mutex is released.  This means the CPU can do something
else while you are waiting.  There are many cases when you simply
can&#39;t sleep (see ), and so have to
use a spinlock instead.

Neither type of lock is recursive: see
.
Locks and Uniprocessor Kernels
For kernels compiled without CONFIG_SMP, and
without CONFIG_PREEMPT spinlocks do not exist at
all.  This is an excellent design decision: when no-one else can
run at the same time, there is no reason to have a lock.

If the kernel is compiled without CONFIG_SMP,
but CONFIG_PREEMPT is set, then spinlocks
simply disable preemption, which is sufficient to prevent any
races.  For most purposes, we can think of preemption as
equivalent to SMP, and not worry about it separately.

You should always test your locking code with CONFIG_SMP
and CONFIG_PREEMPT enabled, even if you don&#39;t have an SMP test box, because it
will still catch some kinds of locking bugs.

Mutexes still exist, because they are required for
synchronization between user
contexts, as we will see below.
Locking Only In User Context
If you have a data structure which is only ever accessed from
user context, then you can use a simple mutex
(include/linux/mutex.h) to protect it.  This
is the most trivial case: you initialize the mutex.  Then you can
call mutex_lock_interruptible() to grab the mutex,
and mutex_unlock() to release it.  There is also a
mutex_lock(), which should be avoided, because it
will not return if a signal is received.

Example: net/netfilter/nf_sockopt.c allows
registration of new setsockopt() and
getsockopt() calls, with
nf_register_sockopt().  Registration and
de-registration are only done on module load and unload (and boot
time, where there is no concurrency), and the list of registrations
is only consulted for an unknown setsockopt()
or getsockopt() system call.  The
nf_sockopt_mutex is perfect to protect this,
especially since the setsockopt and getsockopt calls may well
sleep.
Locking Between User Context and Softirqs
If a softirq shares
data with user context, you have two problems.  Firstly, the current
user context can be interrupted by a softirq, and secondly, the
critical region could be entered from another CPU.  This is where
spin_lock_bh()
(include/linux/spinlock.h) is
used.  It disables softirqs on that CPU, then grabs the lock.
spin_unlock_bh() does the reverse.  (The
&#39;_bh&#39; suffix is a historical reference to &quot;Bottom Halves&quot;, the
old name for software interrupts.  It should really be
called spin_lock_softirq()&#39; in a perfect world).

Note that you can also use spin_lock_irq()
or spin_lock_irqsave() here, which stop
hardware interrupts as well: see .

This works perfectly for UP
as well: the spin lock vanishes, and this macro
simply becomes local_bh_disable()
(include/linux/interrupt.h), which
protects you from the softirq being run.
Locking Between User Context and Tasklets
This is exactly the same as above, because tasklets are actually run
from a softirq.
Locking Between User Context and Timers
This, too, is exactly the same as above, because timers are actually run from
a softirq.  From a locking point of view, tasklets and timers
are identical.
Locking Between Tasklets/Timers
Sometimes a tasklet or timer might want to share data with
another tasklet or timer.
The Same Tasklet/Timer
Since a tasklet is never run on two CPUs at once, you don&#39;t
need to worry about your tasklet being reentrant (running
twice at once), even on SMP.
Different Tasklets/Timers
If another tasklet/timer wants
to share data with your tasklet or timer , you will both need to use
spin_lock() and
spin_unlock() calls.
spin_lock_bh() is
unnecessary here, as you are already in a tasklet, and
none will be run on the same CPU.
Locking Between Softirqs
Often a softirq might
want to share data with itself or a tasklet/timer.
The Same Softirq
The same softirq can run on the other CPUs: you can use a
per-CPU array (see ) for better
performance.  If you&#39;re going so far as to use a softirq,
you probably care about scalable performance enough
to justify the extra complexity.

You&#39;ll need to use spin_lock() and
spin_unlock() for shared data.
Different Softirqs
You&#39;ll need to use spin_lock() and
spin_unlock() for shared data, whether it
be a timer, tasklet, different softirq or the same or another
softirq: any of them could be running on a different CPU.
Hard IRQ Context
Hardware interrupts usually communicate with a
tasklet or softirq.  Frequently this involves putting work in a
queue, which the softirq will take out.
Locking Between Hard IRQ and Softirqs/Tasklets
If a hardware irq handler shares data with a softirq, you have
two concerns.  Firstly, the softirq processing can be
interrupted by a hardware interrupt, and secondly, the
critical region could be entered by a hardware interrupt on
another CPU.  This is where spin_lock_irq() is
used.  It is defined to disable interrupts on that cpu, then grab
the lock. spin_unlock_irq() does the reverse.

The irq handler does not to use
spin_lock_irq(), because the softirq cannot
run while the irq handler is running: it can use
spin_lock(), which is slightly faster.  The
only exception would be if a different hardware irq handler uses
the same lock: spin_lock_irq() will stop
that from interrupting us.

This works perfectly for UP as well: the spin lock vanishes,
and this macro simply becomes local_irq_disable()
(include/asm/smp.h), which
protects you from the softirq/tasklet/BH being run.
spin_lock_irqsave()
(include/linux/spinlock.h) is a variant
which saves whether interrupts were on or off in a flags word,
which is passed to spin_unlock_irqrestore().  This
means that the same code can be used inside an hard irq handler (where
interrupts are already off) and in softirqs (where the irq
disabling is required).

Note that softirqs (and hence tasklets and timers) are run on
return from hardware interrupts, so
spin_lock_irq() also stops these.  In that
sense, spin_lock_irqsave() is the most
general and powerful locking function.
Locking Between Two Hard IRQ Handlers
It is rare to have to share data between two IRQ handlers, but
if you do, spin_lock_irqsave() should be
used: it is architecture-specific whether all interrupts are
disabled inside irq handlers themselves.
Cheat Sheet For Locking
Pete Zaitcev gives the following summary:

If you are in a process context (any syscall) and want to
lock other process out, use a mutex.  You can take a mutex
and sleep (copy_from_user*( or
kmalloc(x,GFP_KERNEL)).

Otherwise (== data can be touched in an interrupt), use
spin_lock_irqsave() and
spin_unlock_irqrestore().

Avoid holding spinlock for more than 5 lines of code and
across any function call (except accessors like
readb).
Table of Minimum Requirements The following table lists the minimum
locking requirements between various contexts.  In some cases,
the same context can only be running on one CPU at a time, so
no locking is required for that context (eg. a particular
thread can only run on one CPU at a time, but if it needs
shares data with another thread, locking is required).

Remember the advice above: you can always use
spin_lock_irqsave(), which is a superset
of all other spinlock primitives.
Table of Locking RequirementsIRQ Handler AIRQ Handler BSoftirq ASoftirq BTasklet ATasklet BTimer ATimer BUser Context AUser Context BIRQ Handler ANoneIRQ Handler BSLISNoneSoftirq ASLISLISLSoftirq BSLISLISLSLTasklet ASLISLISLSLNoneTasklet BSLISLISLSLSLNoneTimer ASLISLISLSLSLSLNoneTimer BSLISLISLSLSLSLSLNoneUser Context ASLISLISLBHSLBHSLBHSLBHSLBHSLBHNoneUser Context BSLISLISLBHSLBHSLBHSLBHSLBHSLBHMLINoneLegend for Locking Requirements TableSLISspin_lock_irqsaveSLIspin_lock_irqSLspin_lockSLBHspin_lock_bhMLImutex_lock_interruptibleThe trylock Functions
There are functions that try to acquire a lock only once and immediately
return a value telling about success or failure to acquire the lock.
They can be used if you need no access to the data protected with the lock
when some other thread is holding the lock. You should acquire the lock
later if you then need access to the data protected with the lock.
spin_trylock() does not spin but returns non-zero if
it acquires the spinlock on the first try or 0 if not. This function can
be used in all contexts like spin_lock: you must have
disabled the contexts that might interrupt you and acquire the spin lock.
mutex_trylock() does not suspend your task
but returns non-zero if it could lock the mutex on the first try
or 0 if not. This function cannot be safely used in hardware or software
interrupt contexts despite not sleeping.
Common Examples
Let&#39;s step through a simple example: a cache of number to name
mappings.  The cache keeps a count of how often each of the objects is
used, and when it gets full, throws out the least used one.

All In User Context
For our first example, we assume that all operations are in user
context (ie. from system calls), so we can sleep.  This means we can
use a mutex to protect the cache and all the objects within
it.  Here&#39;s the code:

#include &amp;lt;linux/list.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;linux/string.h&amp;gt;
#include &amp;lt;linux/mutex.h&amp;gt;
#include &amp;lt;asm/errno.h&amp;gt;

struct object
{
struct list_head list;
int id;
char name[32];
int popularity;
};

/* Protects the cache, cache_num, and the objects within it */
static DEFINE_MUTEX(cache_lock);
static LIST_HEAD(cache);
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10

/* Must be holding cache_lock */
static struct object *__cache_find(int id)
{
struct object *i;

list_for_each_entry(i, &amp;amp;cache, list)
if (i-&amp;gt;id == id) {
i-&amp;gt;popularity++;
return i;
}
return NULL;
}

/* Must be holding cache_lock */
static void __cache_delete(struct object *obj)
{
BUG_ON(!obj);
list_del(&amp;amp;obj-&amp;gt;list);
kfree(obj);
cache_num--;
}

/* Must be holding cache_lock */
static void __cache_add(struct object *obj)
{
list_add(&amp;amp;obj-&amp;gt;list, &amp;amp;cache);
if (++cache_num &amp;gt; MAX_CACHE_SIZE) {
struct object *i, *outcast = NULL;
list_for_each_entry(i, &amp;amp;cache, list) {
if (!outcast || i-&amp;gt;popularity &amp;lt; outcast-&amp;gt;popularity)
outcast = i;
}
__cache_delete(outcast);
}
}

int cache_add(int id, const char *name)
{
struct object *obj;

if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
return -ENOMEM;

strlcpy(obj-&amp;gt;name, name, sizeof(obj-&amp;gt;name));
obj-&amp;gt;id = id;
obj-&amp;gt;popularity = 0;

mutex_lock(&amp;amp;cache_lock);
__cache_add(obj);
mutex_unlock(&amp;amp;cache_lock);
return 0;
}

void cache_delete(int id)
{
mutex_lock(&amp;amp;cache_lock);
__cache_delete(__cache_find(id));
mutex_unlock(&amp;amp;cache_lock);
}

int cache_find(int id, char *name)
{
struct object *obj;
int ret = -ENOENT;

mutex_lock(&amp;amp;cache_lock);
obj = __cache_find(id);
if (obj) {
ret = 0;
strcpy(name, obj-&amp;gt;name);
}
mutex_unlock(&amp;amp;cache_lock);
return ret;
}

Note that we always make sure we have the cache_lock when we add,
delete, or look up the cache: both the cache infrastructure itself and
the contents of the objects are protected by the lock.  In this case
it&#39;s easy, since we copy the data for the user, and never let them
access the objects directly.

There is a slight (and common) optimization here: in
cache_add we set up the fields of the object
before grabbing the lock.  This is safe, as no-one else can access it
until we put it in cache.
Accessing From Interrupt Context
Now consider the case where cache_find can be
called from interrupt context: either a hardware interrupt or a
softirq.  An example would be a timer which deletes object from the
cache.

The change is shown below, in standard patch format: the
- are lines which are taken away, and the
+ are lines which are added.

--- cache.c.usercontext    2003-12-09 13:58:54.000000000 +1100
+++ cache.c.interrupt    2003-12-09 14:07:49.000000000 +1100
@@ -12,7 +12,7 @@
int popularity;
};

-static DEFINE_MUTEX(cache_lock);
+static DEFINE_SPINLOCK(cache_lock);
static LIST_HEAD(cache);
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10
@@ -55,6 +55,7 @@
int cache_add(int id, const char *name)
{
struct object *obj;
+        unsigned long flags;

if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
return -ENOMEM;
@@ -63,30 +64,33 @@
obj-&amp;gt;id = id;
obj-&amp;gt;popularity = 0;

-        mutex_lock(&amp;amp;cache_lock);
+        spin_lock_irqsave(&amp;amp;cache_lock, flags);
__cache_add(obj);
-        mutex_unlock(&amp;amp;cache_lock);
+        spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
return 0;
}

void cache_delete(int id)
{
-        mutex_lock(&amp;amp;cache_lock);
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;amp;cache_lock, flags);
__cache_delete(__cache_find(id));
-        mutex_unlock(&amp;amp;cache_lock);
+        spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
}

int cache_find(int id, char *name)
{
struct object *obj;
int ret = -ENOENT;
+        unsigned long flags;

-        mutex_lock(&amp;amp;cache_lock);
+        spin_lock_irqsave(&amp;amp;cache_lock, flags);
obj = __cache_find(id);
if (obj) {
ret = 0;
strcpy(name, obj-&amp;gt;name);
}
-        mutex_unlock(&amp;amp;cache_lock);
+        spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
return ret;
}

Note that the spin_lock_irqsave will turn off
interrupts if they are on, otherwise does nothing (if we are already
in an interrupt handler), hence these functions are safe to call from
any context.

Unfortunately, cache_add calls
kmalloc with the GFP_KERNEL
flag, which is only legal in user context.  I have assumed that
cache_add is still only called in user context,
otherwise this should become a parameter to
cache_add.
Exposing Objects Outside This File
If our objects contained more information, it might not be sufficient
to copy the information in and out: other parts of the code might want
to keep pointers to these objects, for example, rather than looking up
the id every time.  This produces two problems.

The first problem is that we use the cache_lock to
protect objects: we&#39;d need to make this non-static so the rest of the
code can use it.  This makes locking trickier, as it is no longer all
in one place.

The second problem is the lifetime problem: if another structure keeps
a pointer to an object, it presumably expects that pointer to remain
valid.  Unfortunately, this is only guaranteed while you hold the
lock, otherwise someone might call cache_delete
and even worse, add another object, re-using the same address.

As there is only one lock, you can&#39;t hold it forever: no-one else would
get any work done.

The solution to this problem is to use a reference count: everyone who
has a pointer to the object increases it when they first get the
object, and drops the reference count when they&#39;re finished with it.
Whoever drops it to zero knows it is unused, and can actually delete it.

Here is the code:

--- cache.c.interrupt    2003-12-09 14:25:43.000000000 +1100
+++ cache.c.refcnt    2003-12-09 14:33:05.000000000 +1100
@@ -7,6 +7,7 @@
struct object
{
struct list_head list;
+        unsigned int refcnt;
int id;
char name[32];
int popularity;
@@ -17,6 +18,35 @@
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10

+static void __object_put(struct object *obj)
+{
+        if (--obj-&amp;gt;refcnt == 0)
+                kfree(obj);
+}
+
+static void __object_get(struct object *obj)
+{
+        obj-&amp;gt;refcnt++;
+}
+
+void object_put(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;amp;cache_lock, flags);
+        __object_put(obj);
+        spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
+}
+
+void object_get(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;amp;cache_lock, flags);
+        __object_get(obj);
+        spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
+}
+
/* Must be holding cache_lock */
static struct object *__cache_find(int id)
{
@@ -35,6 +65,7 @@
{
BUG_ON(!obj);
list_del(&amp;amp;obj-&amp;gt;list);
+        __object_put(obj);
cache_num--;
}

@@ -63,6 +94,7 @@
strlcpy(obj-&amp;gt;name, name, sizeof(obj-&amp;gt;name));
obj-&amp;gt;id = id;
obj-&amp;gt;popularity = 0;
+        obj-&amp;gt;refcnt = 1; /* The cache holds a reference */

spin_lock_irqsave(&amp;amp;cache_lock, flags);
__cache_add(obj);
@@ -79,18 +111,15 @@
spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
}

-int cache_find(int id, char *name)
+struct object *cache_find(int id)
{
struct object *obj;
-        int ret = -ENOENT;
unsigned long flags;

spin_lock_irqsave(&amp;amp;cache_lock, flags);
obj = __cache_find(id);
-        if (obj) {
-                ret = 0;
-                strcpy(name, obj-&amp;gt;name);
-        }
+        if (obj)
+                __object_get(obj);
spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
-        return ret;
+        return obj;
}

We encapsulate the reference counting in the standard &#39;get&#39; and &#39;put&#39;
functions.  Now we can return the object itself from
cache_find which has the advantage that the user
can now sleep holding the object (eg. to
copy_to_user to name to userspace).

The other point to note is that I said a reference should be held for
every pointer to the object: thus the reference count is 1 when first
inserted into the cache.  In some versions the framework does not hold
a reference count, but they are more complicated.
Using Atomic Operations For The Reference Count
In practice, atomic_t would usually be used for
refcnt.  There are a number of atomic
operations defined in

include/asm/atomic.h: these are
guaranteed to be seen atomically from all CPUs in the system, so no
lock is required.  In this case, it is simpler than using spinlocks,
although for anything non-trivial using spinlocks is clearer.  The
atomic_inc and
atomic_dec_and_test are used instead of the
standard increment and decrement operators, and the lock is no longer
used to protect the reference count itself.

--- cache.c.refcnt    2003-12-09 15:00:35.000000000 +1100
+++ cache.c.refcnt-atomic    2003-12-11 15:49:42.000000000 +1100
@@ -7,7 +7,7 @@
struct object
{
struct list_head list;
-        unsigned int refcnt;
+        atomic_t refcnt;
int id;
char name[32];
int popularity;
@@ -18,33 +18,15 @@
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10

-static void __object_put(struct object *obj)
-{
-        if (--obj-&amp;gt;refcnt == 0)
-                kfree(obj);
-}
-
-static void __object_get(struct object *obj)
-{
-        obj-&amp;gt;refcnt++;
-}
-
void object_put(struct object *obj)
{
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;amp;cache_lock, flags);
-        __object_put(obj);
-        spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
+        if (atomic_dec_and_test(&amp;amp;obj-&amp;gt;refcnt))
+                kfree(obj);
}

void object_get(struct object *obj)
{
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;amp;cache_lock, flags);
-        __object_get(obj);
-        spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
+        atomic_inc(&amp;amp;obj-&amp;gt;refcnt);
}

/* Must be holding cache_lock */
@@ -65,7 +47,7 @@
{
BUG_ON(!obj);
list_del(&amp;amp;obj-&amp;gt;list);
-        __object_put(obj);
+        object_put(obj);
cache_num--;
}

@@ -94,7 +76,7 @@
strlcpy(obj-&amp;gt;name, name, sizeof(obj-&amp;gt;name));
obj-&amp;gt;id = id;
obj-&amp;gt;popularity = 0;
-        obj-&amp;gt;refcnt = 1; /* The cache holds a reference */
+        atomic_set(&amp;amp;obj-&amp;gt;refcnt, 1); /* The cache holds a reference */

spin_lock_irqsave(&amp;amp;cache_lock, flags);
__cache_add(obj);
@@ -119,7 +101,7 @@
spin_lock_irqsave(&amp;amp;cache_lock, flags);
obj = __cache_find(id);
if (obj)
-                __object_get(obj);
+                object_get(obj);
spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
return obj;
}
Protecting The Objects Themselves
In these examples, we assumed that the objects (except the reference
counts) never changed once they are created.  If we wanted to allow
the name to change, there are three possibilities:

You can make cache_lock non-static, and tell people
to grab that lock before changing the name in any object.

You can provide a cache_obj_rename which grabs
this lock and changes the name for the caller, and tell everyone to
use that function.

You can make the cache_lock protect only the cache
itself, and use another lock to protect the name.

Theoretically, you can make the locks as fine-grained as one lock for
every field, for every object.  In practice, the most common variants
are:

One lock which protects the infrastructure (the cache
list in this example) and all the objects.  This is what we have done
so far.

One lock which protects the infrastructure (including the list
pointers inside the objects), and one lock inside the object which
protects the rest of that object.

Multiple locks to protect the infrastructure (eg. one lock per hash
chain), possibly with a separate per-object lock.

Here is the &quot;lock-per-object&quot; implementation:

--- cache.c.refcnt-atomic    2003-12-11 15:50:54.000000000 +1100
+++ cache.c.perobjectlock    2003-12-11 17:15:03.000000000 +1100
@@ -6,11 +6,17 @@

struct object
{
+        /* These two protected by cache_lock. */
struct list_head list;
+        int popularity;
+
atomic_t refcnt;
+
+        /* Doesn&#39;t change once created. */
int id;
+
+        spinlock_t lock; /* Protects the name */
char name[32];
-        int popularity;
};

static DEFINE_SPINLOCK(cache_lock);
@@ -77,6 +84,7 @@
obj-&amp;gt;id = id;
obj-&amp;gt;popularity = 0;
atomic_set(&amp;amp;obj-&amp;gt;refcnt, 1); /* The cache holds a reference */
+        spin_lock_init(&amp;amp;obj-&amp;gt;lock);

spin_lock_irqsave(&amp;amp;cache_lock, flags);
__cache_add(obj);

Note that I decide that the popularity
count should be protected by the cache_lock rather
than the per-object lock: this is because it (like the
struct list_head inside the object) is
logically part of the infrastructure.  This way, I don&#39;t need to grab
the lock of every object in __cache_add when
seeking the least popular.

I also decided that the id member is
unchangeable, so I don&#39;t need to grab each object lock in
__cache_find() to examine the
id: the object lock is only used by a
caller who wants to read or write the name
field.

Note also that I added a comment describing what data was protected by
which locks.  This is extremely important, as it describes the runtime
behavior of the code, and can be hard to gain from just reading.  And
as Alan Cox says, Lock data, not code.
Common ProblemsDeadlock: Simple and Advanced
There is a coding bug where a piece of code tries to grab a
spinlock twice: it will spin forever, waiting for the lock to
be released (spinlocks, rwlocks and mutexes are not
recursive in Linux).  This is trivial to diagnose: not a
stay-up-five-nights-talk-to-fluffy-code-bunnies kind of
problem.

For a slightly more complex case, imagine you have a region
shared by a softirq and user context.  If you use a
spin_lock() call to protect it, it is
possible that the user context will be interrupted by the softirq
while it holds the lock, and the softirq will then spin
forever trying to get the same lock.

Both of these are called deadlock, and as shown above, it can
occur even with a single CPU (although not on UP compiles,
since spinlocks vanish on kernel compiles with
CONFIG_SMP=n. You&#39;ll still get data corruption
in the second example).

This complete lockup is easy to diagnose: on SMP boxes the
watchdog timer or compiling with DEBUG_SPINLOCK set
(include/linux/spinlock.h) will show this up
immediately when it happens.

A more complex problem is the so-called &#39;deadly embrace&#39;,
involving two or more locks.  Say you have a hash table: each
entry in the table is a spinlock, and a chain of hashed
objects.  Inside a softirq handler, you sometimes want to
alter an object from one place in the hash to another: you
grab the spinlock of the old hash chain and the spinlock of
the new hash chain, and delete the object from the old one,
and insert it in the new one.

There are two problems here.  First, if your code ever
tries to move the object to the same chain, it will deadlock
with itself as it tries to lock it twice.  Secondly, if the
same softirq on another CPU is trying to move another object
in the reverse direction, the following could happen:
ConsequencesCPU 1CPU 2Grab lock A -&amp;gt; OKGrab lock B -&amp;gt; OKGrab lock B -&amp;gt; spinGrab lock A -&amp;gt; spin
The two CPUs will spin forever, waiting for the other to give up
their lock.  It will look, smell, and feel like a crash.
Preventing Deadlock
Textbooks will tell you that if you always lock in the same
order, you will never get this kind of deadlock.  Practice
will tell you that this approach doesn&#39;t scale: when I
create a new lock, I don&#39;t understand enough of the kernel
to figure out where in the 5000 lock hierarchy it will fit.

The best locks are encapsulated: they never get exposed in
headers, and are never held around calls to non-trivial
functions outside the same file.  You can read through this
code and see that it will never deadlock, because it never
tries to grab another lock while it has that one.  People
using your code don&#39;t even need to know you are using a
lock.

A classic problem here is when you provide callbacks or
hooks: if you call these with the lock held, you risk simple
deadlock, or a deadly embrace (who knows what the callback
will do?).  Remember, the other programmers are out to get
you, so don&#39;t do this.
Overzealous Prevention Of Deadlocks
Deadlocks are problematic, but not as bad as data
corruption.  Code which grabs a read lock, searches a list,
fails to find what it wants, drops the read lock, grabs a
write lock and inserts the object has a race condition.

If you don&#39;t see why, please stay the fuck away from my code.
Racing Timers: A Kernel Pastime
Timers can produce their own special problems with races.
Consider a collection of objects (list, hash, etc) where each
object has a timer which is due to destroy it.

If you want to destroy the entire collection (say on module
removal), you might do the following:

/* THIS CODE BAD BAD BAD BAD: IF IT WAS ANY WORSE IT WOULD USE
HUNGARIAN NOTATION */
spin_lock_bh(&amp;amp;list_lock);

while (list) {
struct foo *next = list-&amp;gt;next;
del_timer(&amp;amp;list-&amp;gt;timer);
kfree(list);
list = next;
}

spin_unlock_bh(&amp;amp;list_lock);

Sooner or later, this will crash on SMP, because a timer can
have just gone off before the spin_lock_bh(),
and it will only get the lock after we
spin_unlock_bh(), and then try to free
the element (which has already been freed!).

This can be avoided by checking the result of
del_timer(): if it returns
1, the timer has been deleted.
If 0, it means (in this
case) that it is currently running, so we can do:

retry:
spin_lock_bh(&amp;amp;list_lock);

while (list) {
struct foo *next = list-&amp;gt;next;
if (!del_timer(&amp;amp;list-&amp;gt;timer)) {
/* Give timer a chance to delete this */
spin_unlock_bh(&amp;amp;list_lock);
goto retry;
}
kfree(list);
list = next;
}

spin_unlock_bh(&amp;amp;list_lock);

Another common problem is deleting timers which restart
themselves (by calling add_timer() at the end
of their timer function).  Because this is a fairly common case
which is prone to races, you should use del_timer_sync()
(include/linux/timer.h)
to handle this case.  It returns the number of times the timer
had to be deleted before we finally stopped it from adding itself back
in.
Locking Speed
There are three main things to worry about when considering speed of
some code which does locking.  First is concurrency: how many things
are going to be waiting while someone else is holding a lock.  Second
is the time taken to actually acquire and release an uncontended lock.
Third is using fewer, or smarter locks.  I&#39;m assuming that the lock is
used fairly often: otherwise, you wouldn&#39;t be concerned about
efficiency.

Concurrency depends on how long the lock is usually held: you should
hold the lock for as long as needed, but no longer.  In the cache
example, we always create the object without the lock held, and then
grab the lock only when we are ready to insert it in the list.

Acquisition times depend on how much damage the lock operations do to
the pipeline (pipeline stalls) and how likely it is that this CPU was
the last one to grab the lock (ie. is the lock cache-hot for this
CPU): on a machine with more CPUs, this likelihood drops fast.
Consider a 700MHz Intel Pentium III: an instruction takes about 0.7ns,
an atomic increment takes about 58ns, a lock which is cache-hot on
this CPU takes 160ns, and a cacheline transfer from another CPU takes
an additional 170 to 360ns.  (These figures from Paul McKenney&#39;s
Linux
Journal RCU article).

These two aims conflict: holding a lock for a short time might be done
by splitting locks into parts (such as in our final per-object-lock
example), but this increases the number of lock acquisitions, and the
results are often slower than having a single lock.  This is another
reason to advocate locking simplicity.

The third concern is addressed below: there are some methods to reduce
the amount of locking which needs to be done.
Read/Write Lock Variants
Both spinlocks and mutexes have read/write variants:
rwlock_t and struct rw_semaphore.
These divide users into two classes: the readers and the writers.  If
you are only reading the data, you can get a read lock, but to write to
the data you need the write lock.  Many people can hold a read lock,
but a writer must be sole holder.

If your code divides neatly along reader/writer lines (as our
cache code does), and the lock is held by readers for
significant lengths of time, using these locks can help.  They
are slightly slower than the normal locks though, so in practice
rwlock_t is not usually worthwhile.
Avoiding Locks: Read Copy Update
There is a special method of read/write locking called Read Copy
Update.  Using RCU, the readers can avoid taking a lock
altogether: as we expect our cache to be read more often than
updated (otherwise the cache is a waste of time), it is a
candidate for this optimization.

How do we get rid of read locks?  Getting rid of read locks
means that writers may be changing the list underneath the
readers.  That is actually quite simple: we can read a linked
list while an element is being added if the writer adds the
element very carefully.  For example, adding
new to a single linked list called
list:

new-&amp;gt;next = list-&amp;gt;next;
wmb();
list-&amp;gt;next = new;

The wmb() is a write memory barrier.  It
ensures that the first operation (setting the new element&#39;s
next pointer) is complete and will be seen by
all CPUs, before the second operation is (putting the new
element into the list).  This is important, since modern
compilers and modern CPUs can both reorder instructions unless
told otherwise: we want a reader to either not see the new
element at all, or see the new element with the
next pointer correctly pointing at the rest of
the list.

Fortunately, there is a function to do this for standard
struct list_head lists:
list_add_rcu()
(include/linux/list.h).

Removing an element from the list is even simpler: we replace
the pointer to the old element with a pointer to its successor,
and readers will either see it, or skip over it.

list-&amp;gt;next = old-&amp;gt;next;

There is list_del_rcu()
(include/linux/list.h) which does this (the
normal version poisons the old object, which we don&#39;t want).

The reader must also be careful: some CPUs can look through the
next pointer to start reading the contents of
the next element early, but don&#39;t realize that the pre-fetched
contents is wrong when the next pointer changes
underneath them.  Once again, there is a
list_for_each_entry_rcu()
(include/linux/list.h) to help you.  Of
course, writers can just use
list_for_each_entry(), since there cannot
be two simultaneous writers.

Our final dilemma is this: when can we actually destroy the
removed element?  Remember, a reader might be stepping through
this element in the list right now: if we free this element and
the next pointer changes, the reader will jump
off into garbage and crash.  We need to wait until we know that
all the readers who were traversing the list when we deleted the
element are finished.  We use call_rcu() to
register a callback which will actually destroy the object once
all pre-existing readers are finished.  Alternatively,
synchronize_rcu() may be used to block until
all pre-existing are finished.

But how does Read Copy Update know when the readers are
finished?  The method is this: firstly, the readers always
traverse the list inside
rcu_read_lock()/rcu_read_unlock()
pairs: these simply disable preemption so the reader won&#39;t go to
sleep while reading the list.

RCU then waits until every other CPU has slept at least once:
since readers cannot sleep, we know that any readers which were
traversing the list during the deletion are finished, and the
callback is triggered.  The real Read Copy Update code is a
little more optimized than this, but this is the fundamental
idea.

--- cache.c.perobjectlock    2003-12-11 17:15:03.000000000 +1100
+++ cache.c.rcupdate    2003-12-11 17:55:14.000000000 +1100
@@ -1,15 +1,18 @@
#include &amp;lt;linux/list.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;linux/string.h&amp;gt;
+#include &amp;lt;linux/rcupdate.h&amp;gt;
#include &amp;lt;linux/mutex.h&amp;gt;
#include &amp;lt;asm/errno.h&amp;gt;

struct object
{
-        /* These two protected by cache_lock. */
+        /* This is protected by RCU */
struct list_head list;
int popularity;

+        struct rcu_head rcu;
+
atomic_t refcnt;

/* Doesn&#39;t change once created. */
@@ -40,7 +43,7 @@
{
struct object *i;

-        list_for_each_entry(i, &amp;amp;cache, list) {
+        list_for_each_entry_rcu(i, &amp;amp;cache, list) {
if (i-&amp;gt;id == id) {
i-&amp;gt;popularity++;
return i;
@@ -49,19 +52,25 @@
return NULL;
}

+/* Final discard done once we know no readers are looking. */
+static void cache_delete_rcu(void *arg)
+{
+        object_put(arg);
+}
+
/* Must be holding cache_lock */
static void __cache_delete(struct object *obj)
{
BUG_ON(!obj);
-        list_del(&amp;amp;obj-&amp;gt;list);
-        object_put(obj);
+        list_del_rcu(&amp;amp;obj-&amp;gt;list);
cache_num--;
+        call_rcu(&amp;amp;obj-&amp;gt;rcu, cache_delete_rcu);
}

/* Must be holding cache_lock */
static void __cache_add(struct object *obj)
{
-        list_add(&amp;amp;obj-&amp;gt;list, &amp;amp;cache);
+        list_add_rcu(&amp;amp;obj-&amp;gt;list, &amp;amp;cache);
if (++cache_num &amp;gt; MAX_CACHE_SIZE) {
struct object *i, *outcast = NULL;
list_for_each_entry(i, &amp;amp;cache, list) {
@@ -104,12 +114,11 @@
struct object *cache_find(int id)
{
struct object *obj;
-        unsigned long flags;

-        spin_lock_irqsave(&amp;amp;cache_lock, flags);
+        rcu_read_lock();
obj = __cache_find(id);
if (obj)
object_get(obj);
-        spin_unlock_irqrestore(&amp;amp;cache_lock, flags);
+        rcu_read_unlock();
return obj;
}

Note that the reader will alter the
popularity member in
__cache_find(), and now it doesn&#39;t hold a lock.
One solution would be to make it an atomic_t, but for
this usage, we don&#39;t really care about races: an approximate result is
good enough, so I didn&#39;t change it.

The result is that cache_find() requires no
synchronization with any other functions, so is almost as fast on SMP
as it would be on UP.

There is a furthur optimization possible here: remember our original
cache code, where there were no reference counts and the caller simply
held the lock whenever using the object?  This is still possible: if
you hold the lock, no one can delete the object, so you don&#39;t need to
get and put the reference count.

Now, because the &#39;read lock&#39; in RCU is simply disabling preemption, a
caller which always has preemption disabled between calling
cache_find() and
object_put() does not need to actually get and
put the reference count: we could expose
__cache_find() by making it non-static, and
such callers could simply call that.

The benefit here is that the reference count is not written to: the
object is not altered in any way, which is much faster on SMP
machines due to caching.
Per-CPU Data
Another technique for avoiding locking which is used fairly
widely is to duplicate information for each CPU.  For example,
if you wanted to keep a count of a common condition, you could
use a spin lock and a single counter.  Nice and simple.

If that was too slow (it&#39;s usually not, but if you&#39;ve got a
really big machine to test on and can show that it is), you
could instead use a counter for each CPU, then none of them need
an exclusive lock.  See DEFINE_PER_CPU(),
get_cpu_var() and
put_cpu_var()
(include/linux/percpu.h).

Of particular use for simple per-cpu counters is the
local_t type, and the
cpu_local_inc() and related functions,
which are more efficient than simple code on some architectures
(include/asm/local.h).

Note that there is no simple, reliable way of getting an exact
value of such a counter, without introducing more locks.  This
is not a problem for some uses.
Data Which Mostly Used By An IRQ Handler
If data is always accessed from within the same IRQ handler, you
don&#39;t need a lock at all: the kernel already guarantees that the
irq handler will not run simultaneously on multiple CPUs.

Manfred Spraul points out that you can still do this, even if
the data is very occasionally accessed in user context or
softirqs/tasklets.  The irq handler doesn&#39;t use a lock, and
all other accesses are done as so:

spin_lock(&amp;amp;lock);
disable_irq(irq);
...
enable_irq(irq);
spin_unlock(&amp;amp;lock);

The disable_irq() prevents the irq handler
from running (and waits for it to finish if it&#39;s currently
running on other CPUs).  The spinlock prevents any other
accesses happening at the same time.  Naturally, this is slower
than just a spin_lock_irq() call, so it
only makes sense if this type of access happens extremely
rarely.
What Functions Are Safe To Call From Interrupts?
Many functions in the kernel sleep (ie. call schedule())
directly or indirectly: you can never call them while holding a
spinlock, or with preemption disabled.  This also means you need
to be in user context: calling them from an interrupt is illegal.
Some Functions Which Sleep
The most common ones are listed below, but you usually have to
read the code to find out if other calls are safe.  If everyone
else who calls it can sleep, you probably need to be able to
sleep, too.  In particular, registration and deregistration
functions usually expect to be called from user context, and can
sleep.

Accesses to
userspace:
copy_from_user()copy_to_user()get_user()put_user()kmalloc(GFP_KERNEL)mutex_lock_interruptible() and
mutex_lock()

There is a mutex_trylock() which does not
sleep.  Still, it must not be used inside interrupt context since
its implementation is not safe for that.
mutex_unlock() will also never sleep.
It cannot be used in interrupt context either since a mutex
must be released by the same task that acquired it.
Some Functions Which Don&#39;t Sleep
Some functions are safe to call from any context, or holding
almost any lock.
printk()kfree()add_timer() and del_timer()
Mutex API reference
Futex API reference
Further readingDocumentation/spinlocks.txt:
Linus Torvalds&#39; spinlocking tutorial in the kernel sources.

Unix Systems for Modern Architectures: Symmetric
Multiprocessing and Caching for Kernel Programmers:

Curt Schimmel&#39;s very good introduction to kernel level
locking (not written for Linux, but nearly everything
applies).  The book is expensive, but really worth every
penny to understand SMP locking. [ISBN: 0201633388]
Thanks
Thanks to Telsa Gwynne for DocBooking, neatening and adding
style.

Thanks to Martin Pool, Philipp Rumpf, Stephen Rothwell, Paul
Mackerras, Ruedi Aschwanden, Alan Cox, Manfred Spraul, Tim
Waugh, Pete Zaitcev, James Morris, Robert Love, Paul McKenney,
John Ashby for proofreading, correcting, flaming, commenting.

Thanks to the cabal for having no influence on this document.
Glossarypreemption
Prior to 2.5, or when CONFIG_PREEMPT is
unset, processes in user context inside the kernel would not
preempt each other (ie. you had that CPU until you gave it up,
except for interrupts).  With the addition of
CONFIG_PREEMPT in 2.5.4, this changed: when
in user context, higher priority tasks can &quot;cut in&quot;: spinlocks
were changed to disable preemption, even on UP.
bh
Bottom Half: for historical reasons, functions with
&#39;_bh&#39; in them often now refer to any software interrupt, e.g.
spin_lock_bh() blocks any software interrupt
on the current CPU.  Bottom halves are deprecated, and will
eventually be replaced by tasklets.  Only one bottom half will be
running at any time.
Hardware Interrupt / Hardware IRQ
Hardware interrupt request.  in_irq() returns
true in a hardware interrupt handler.
Interrupt Context
Not user context: processing a hardware irq or software irq.
Indicated by the in_interrupt() macro
returning true.
SMP
Symmetric Multi-Processor: kernels compiled for multiple-CPU
machines.  (CONFIG_SMP=y).
Software Interrupt / softirq
Software interrupt handler.  in_irq() returns
false; in_softirq()
returns true.  Tasklets and softirqs
both fall into the category of &#39;software interrupts&#39;.

Strictly speaking a softirq is one of up to 32 enumerated software
interrupts which can run on multiple CPUs at once.
Sometimes used to refer to tasklets as
well (ie. all software interrupts).
tasklet
A dynamically-registrable software interrupt,
which is guaranteed to only run on one CPU at a time.
timer
A dynamically-registrable software interrupt, which is run at
(or close to) a given time.  When running, it is just like a
tasklet (in fact, they are called from the TIMER_SOFTIRQ).
UP
Uni-Processor: Non-SMP.  (CONFIG_SMP=n).
User Context
The kernel executing on behalf of a particular process (ie. a
system call or trap) or kernel thread.  You can tell which
process with the current macro.)  Not to
be confused with userspace.  Can be interrupted by software or
hardware interrupts.
Userspace
A process executing its own code outside the kernel.
Using kgdb, kdb and the kernel debugger internalsJasonWesseljason.wessel@windriver.com2008,2010Wind River Systems, Inc.2004-2005MontaVista Software, Inc.2004Amit S. Kale
This file is licensed under the terms of the GNU General Public License
version 2. This program is licensed &quot;as is&quot; without any warranty of any
kind, whether express or implied.
Introduction
The kernel has two different debugger front ends (kdb and kgdb)
which interface to the debug core.  It is possible to use either
of the debugger front ends and dynamically transition between them
if you configure the kernel properly at compile and runtime.

Kdb is simplistic shell-style interface which you can use on a
system console with a keyboard or serial console.  You can use it
to inspect memory, registers, process lists, dmesg, and even set
breakpoints to stop in a certain location.  Kdb is not a source
level debugger, although you can set breakpoints and execute some
basic kernel run control.  Kdb is mainly aimed at doing some
analysis to aid in development or diagnosing kernel problems.  You
can access some symbols by name in kernel built-ins or in kernel
modules if the code was built
with CONFIG_KALLSYMS.

Kgdb is intended to be used as a source level debugger for the
Linux kernel. It is used along with gdb to debug a Linux kernel.
The expectation is that gdb can be used to &quot;break in&quot; to the
kernel to inspect memory, variables and look through call stack
information similar to the way an application developer would use
gdb to debug an application.  It is possible to place breakpoints
in kernel code and perform some limited execution stepping.

Two machines are required for using kgdb. One of these machines is
a development machine and the other is the target machine.  The
kernel to be debugged runs on the target machine. The development
machine runs an instance of gdb against the vmlinux file which
contains the symbols (not boot image such as bzImage, zImage,
uImage...).  In gdb the developer specifies the connection
parameters and connects to kgdb.  The type of connection a
developer makes with gdb depends on the availability of kgdb I/O
modules compiled as built-ins or loadable kernel modules in the test
machine&#39;s kernel.
Compiling a kernelIn order to enable compilation of kdb, you must first enable kgdb.The kgdb test compile options are described in the kgdb test suite chapter.Kernel config options for kgdb
To enable CONFIG_KGDB you should look under
&quot;Kernel debugging&quot; and select &quot;KGDB: kernel debugger&quot;.

While it is not a hard requirement that you have symbols in your
vmlinux file, gdb tends not to be very useful without the symbolic
data, so you will want to turn
on CONFIG_DEBUG_INFO which is called &quot;Compile the
kernel with debug info&quot; in the config menu.

It is advised, but not required that you turn on the
CONFIG_FRAME_POINTER kernel option which is called &quot;Compile the
kernel with frame pointers&quot; in the config menu.  This option
inserts code to into the compiled executable which saves the frame
information in registers or on the stack at different points which
allows a debugger such as gdb to more accurately construct
stack back traces while debugging the kernel.

If the architecture that you are using supports the kernel option
CONFIG_DEBUG_RODATA, you should consider turning it off.  This
option will prevent the use of software breakpoints because it
marks certain regions of the kernel&#39;s memory space as read-only.
If kgdb supports it for the architecture you are using, you can
use hardware breakpoints if you desire to run with the
CONFIG_DEBUG_RODATA option turned on, else you need to turn off
this option.

Next you should choose one of more I/O drivers to interconnect
debugging host and debugged target.  Early boot debugging requires
a KGDB I/O driver that supports early debugging and the driver
must be built into the kernel directly. Kgdb I/O driver
configuration takes place via kernel or module parameters which
you can learn more about in the in the section that describes the
parameter &quot;kgdboc&quot;.
Here is an example set of .config symbols to enable or
disable for kgdb:
# CONFIG_DEBUG_RODATA is not setCONFIG_FRAME_POINTER=yCONFIG_KGDB=yCONFIG_KGDB_SERIAL_CONSOLE=y
Kernel config options for kdbKdb is quite a bit more complex than the simple gdbstub
sitting on top of the kernel&#39;s debug core.  Kdb must implement a
shell, and also adds some helper functions in other parts of the
kernel, responsible for printing out interesting data such as what
you would see if you ran &quot;lsmod&quot;, or &quot;ps&quot;.  In order to build kdb
into the kernel you follow the same steps as you would for kgdb.
The main config option for kdb
is CONFIG_KGDB_KDB which is called &quot;KGDB_KDB:
include kdb frontend for kgdb&quot; in the config menu.  In theory you
would have already also selected an I/O driver such as the
CONFIG_KGDB_SERIAL_CONSOLE interface if you plan on using kdb on a
serial port, when you were configuring kgdb.
If you want to use a PS/2-style keyboard with kdb, you would
select CONFIG_KDB_KEYBOARD which is called &quot;KGDB_KDB: keyboard as
input device&quot; in the config menu.  The CONFIG_KDB_KEYBOARD option
is not used for anything in the gdb interface to kgdb.  The
CONFIG_KDB_KEYBOARD option only works with kdb.
Here is an example set of .config symbols to enable/disable kdb:
# CONFIG_DEBUG_RODATA is not setCONFIG_FRAME_POINTER=yCONFIG_KGDB=yCONFIG_KGDB_SERIAL_CONSOLE=yCONFIG_KGDB_KDB=yCONFIG_KDB_KEYBOARD=y
Kernel Debugger Boot ArgumentsThis section describes the various runtime kernel
parameters that affect the configuration of the kernel debugger.
The following chapter covers using kdb and kgdb as well as
provides some examples of the configuration parameters.Kernel parameter: kgdbocThe kgdboc driver was originally an abbreviation meant to
stand for &quot;kgdb over console&quot;.  Today it is the primary mechanism
to configure how to communicate from gdb to kgdb as well as the
devices you want to use to interact with the kdb shell.
For kgdb/gdb, kgdboc is designed to work with a single serial
port. It is intended to cover the circumstance where you want to
use a serial console as your primary console as well as using it to
perform kernel debugging.  It is also possible to use kgdb on a
serial port which is not designated as a system console.  Kgdboc
may be configured as a kernel built-in or a kernel loadable module.
You can only make use of kgdbwait and early
debugging if you build kgdboc into the kernel as a built-in.
Optionally you can elect to activate kms (Kernel Mode
Setting) integration.  When you use kms with kgdboc and you have a
video driver that has atomic mode setting hooks, it is possible to
enter the debugger on the graphics console.  When the kernel
execution is resumed, the previous graphics mode will be restored.
This integration can serve as a useful tool to aid in diagnosing
crashes or doing analysis of memory with kdb while allowing the
full graphics console applications to run.

kgdboc argumentsUsage: kgdboc=[kms][[,]kbd][[,]serial_device][,baud]The order listed above must be observed if you use any of the
optional configurations together.
Abbreviations:
kms = Kernel Mode Settingkbd = Keyboard
You can configure kgdboc to use the keyboard, and or a serial
device depending on if you are using kdb and or kgdb, in one of the
following scenarios.  The order listed above must be observed if
you use any of the optional configurations together.  Using kms +
only gdb is generally not a useful combination.Using loadable module or built-inAs a kernel built-in:Use the kernel boot argument: kgdboc=&amp;lt;tty-device&amp;gt;,[baud]As a kernel loadable module:Use the command: modprobe kgdboc kgdboc=&amp;lt;tty-device&amp;gt;,[baud]Here are two examples of how you might format the kgdboc
string. The first is for an x86 target using the first serial port.
The second example is for the ARM Versatile AB using the second
serial port.
kgdboc=ttyS0,115200kgdboc=ttyAMA1,115200
Configure kgdboc at runtime with sysfsAt run time you can enable or disable kgdboc by echoing a
parameters into the sysfs.  Here are two examples:Enable kgdboc on ttyS0echo ttyS0 &amp;gt; /sys/module/kgdboc/parameters/kgdbocDisable kgdbocecho &quot;&quot; &amp;gt; /sys/module/kgdboc/parameters/kgdbocNOTE: You do not need to specify the baud if you are
configuring the console on tty which is already configured or
open.More examplesYou can configure kgdboc to use the keyboard, and or a serial
device depending on if you are using kdb and or kgdb, in one of the
following scenarios.You can configure kgdboc to use the keyboard, and or a serial device
depending on if you are using kdb and or kgdb, in one of the
following scenarios.
kdb and kgdb over only a serial portkgdboc=&amp;lt;serial_device&amp;gt;[,baud]Example: kgdboc=ttyS0,115200kdb and kgdb with keyboard and a serial portkgdboc=kbd,&amp;lt;serial_device&amp;gt;[,baud]Example: kgdboc=kbd,ttyS0,115200kdb with a keyboardkgdboc=kbdkdb with kernel mode settingkgdboc=kms,kbdkdb with kernel mode setting and kgdb over a serial portkgdboc=kms,kbd,ttyS0,115200
NOTE: Kgdboc does not support interrupting the target via the
gdb remote protocol.  You must manually send a sysrq-g unless you
have a proxy that splits console output to a terminal program.
A console proxy has a separate TCP port for the debugger and a separate
TCP port for the &quot;human&quot; console.  The proxy can take care of sending
the sysrq-g for you.
When using kgdboc with no debugger proxy, you can end up
connecting the debugger at one of two entry points.  If an
exception occurs after you have loaded kgdboc, a message should
print on the console stating it is waiting for the debugger.  In
this case you disconnect your terminal program and then connect the
debugger in its place.  If you want to interrupt the target system
and forcibly enter a debug session you have to issue a Sysrq
sequence and then type the letter g.  Then
you disconnect the terminal session and connect gdb.  Your options
if you don&#39;t like this are to hack gdb to send the sysrq-g for you
as well as on the initial connect, or to use a debugger proxy that
allows an unmodified gdb to do the debugging.
Kernel parameter: kgdbwait
The Kernel command line option kgdbwait makes
kgdb wait for a debugger connection during booting of a kernel.  You
can only use this option you compiled a kgdb I/O driver into the
kernel and you specified the I/O driver configuration as a kernel
command line option.  The kgdbwait parameter should always follow the
configuration parameter for the kgdb I/O driver in the kernel
command line else the I/O driver will not be configured prior to
asking the kernel to use it to wait.

The kernel will stop and wait as early as the I/O driver and
architecture allows when you use this option.  If you build the
kgdb I/O driver as a loadable kernel module kgdbwait will not do
anything.
Kernel parameter: kgdbcon The kgdbcon feature allows you to see printk() messages
inside gdb while gdb is connected to the kernel.  Kdb does not make
use of the kgdbcon feature.
Kgdb supports using the gdb serial protocol to send console
messages to the debugger when the debugger is connected and running.
There are two ways to activate this feature.
Activate with the kernel command line option:kgdbconUse sysfs before configuring an I/O driverecho 1 &amp;gt; /sys/module/kgdb/parameters/kgdb_use_con
NOTE: If you do this after you configure the kgdb I/O driver, the
setting will not take effect until the next point the I/O is
reconfigured.

IMPORTANT NOTE: You cannot use kgdboc + kgdbcon on a tty that is an
active system console.  An example incorrect usage is console=ttyS0,115200 kgdboc=ttyS0 kgdbcon

It is possible to use this option with kgdboc on a tty that is not a system console.

Run time parameter: kgdbreboot The kgdbreboot feature allows you to change how the debugger
deals with the reboot notification.  You have 3 choices for the
behavior.  The default behavior is always set to 0.echo -1 &amp;gt; /sys/module/debug_core/parameters/kgdbrebootIgnore the reboot notification entirely.echo 0 &amp;gt; /sys/module/debug_core/parameters/kgdbrebootSend the detach message to any attached debugger client.echo 1 &amp;gt; /sys/module/debug_core/parameters/kgdbrebootEnter the debugger on reboot notify.Using kdb
Quick start for kdb on a serial portThis is a quick example of how to use kdb.Boot kernel with arguments:
console=ttyS0,115200 kgdboc=ttyS0,115200ORConfigure kgdboc after the kernel booted; assuming you are using a serial port console:
echo ttyS0 &amp;gt; /sys/module/kgdboc/parameters/kgdboc
Enter the kernel debugger manually or by waiting for an oops or fault.  There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g, which means you must have enabled CONFIG_MAGIC_SYSRQ=y in your kernel config.When logged in as root or with a super user session you can run:echo g &amp;gt; /proc/sysrq-triggerExample using minicom 2.2Press: Control-aPress: fPress: gWhen you have telneted to a terminal server that supports sending a remote breakPress: Control-]Type in:send breakPress: EnterPress: gFrom the kdb prompt you can run the &quot;help&quot; command to see a complete list of the commands that are available.Some useful commands in kdb include:
lsmod  -- Shows where kernel modules are loadedps -- Displays only the active processesps A -- Shows all the processessummary -- Shows kernel version info and memory usagebt -- Get a backtrace of the current process using dump_stack()dmesg -- View the kernel syslog buffergo -- Continue the system
When you are done using kdb you need to consider rebooting the
system or using the &quot;go&quot; command to resuming normal kernel
execution.  If you have paused the kernel for a lengthy period of
time, applications that rely on timely networking or anything to do
with real wall clock time could be adversely affected, so you
should take this into consideration when using the kernel
debugger.Quick start for kdb using a keyboard connected consoleThis is a quick example of how to use kdb with a keyboard.Boot kernel with arguments:
kgdboc=kbdORConfigure kgdboc after the kernel booted:
echo kbd &amp;gt; /sys/module/kgdboc/parameters/kgdboc
Enter the kernel debugger manually or by waiting for an oops or fault.  There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g, which means you must have enabled CONFIG_MAGIC_SYSRQ=y in your kernel config.When logged in as root or with a super user session you can run:echo g &amp;gt; /proc/sysrq-triggerExample using a laptop keyboardPress and hold down: AltPress and hold down: FnPress and release the key with the label: SysRqRelease: FnPress and release: gRelease: AltExample using a PS/2 101-key keyboardPress and hold down: AltPress and release the key with the label: SysRqPress and release: gRelease: AltNow type in a kdb command such as &quot;help&quot;, &quot;dmesg&quot;, &quot;bt&quot; or &quot;go&quot; to continue kernel execution.Using kgdb / gdbIn order to use kgdb you must activate it by passing
configuration information to one of the kgdb I/O drivers.  If you
do not pass any configuration information kgdb will not do anything
at all.  Kgdb will only actively hook up to the kernel trap hooks
if a kgdb I/O driver is loaded and configured.  If you unconfigure
a kgdb I/O driver, kgdb will unregister all the kernel hook points.
All kgdb I/O drivers can be reconfigured at run time, if
CONFIG_SYSFS and CONFIG_MODULES
are enabled, by echo&#39;ing a new config string to
/sys/module/&amp;lt;driver&amp;gt;/parameter/&amp;lt;option&amp;gt;.
The driver can be unconfigured by passing an empty string.  You cannot
change the configuration while the debugger is attached.  Make sure
to detach the debugger with the detach command
prior to trying to unconfigure a kgdb I/O driver.
Connecting with gdb to a serial portConfigure kgdbocBoot kernel with arguments:
kgdboc=ttyS0,115200ORConfigure kgdboc after the kernel booted:
echo ttyS0 &amp;gt; /sys/module/kgdboc/parameters/kgdbocStop kernel execution (break into the debugger)In order to connect to gdb via kgdboc, the kernel must
first be stopped.  There are several ways to stop the kernel which
include using kgdbwait as a boot argument, via a sysrq-g, or running
the kernel until it takes an exception where it waits for the
debugger to attach.
When logged in as root or with a super user session you can run:echo g &amp;gt; /proc/sysrq-triggerExample using minicom 2.2Press: Control-aPress: fPress: gWhen you have telneted to a terminal server that supports sending a remote breakPress: Control-]Type in:send breakPress: EnterPress: g
Connect from from gdb
Example (using a directly connected port):

% gdb ./vmlinux
(gdb) set remotebaud 115200
(gdb) target remote /dev/ttyS0

Example (kgdb to a terminal server on TCP port 2012):

% gdb ./vmlinux
(gdb) target remote 192.168.2.2:2012

Once connected, you can debug a kernel the way you would debug an
application program.

If you are having problems connecting or something is going
seriously wrong while debugging, it will most often be the case
that you want to enable gdb to be verbose about its target
communications.  You do this prior to issuing the target
remote command by typing in: set debug remote 1
Remember if you continue in gdb, and need to &quot;break in&quot; again,
you need to issue an other sysrq-g.  It is easy to create a simple
entry point by putting a breakpoint at sys_sync
and then you can run &quot;sync&quot; from a shell or script to break into the
debugger.kgdb and kdb interoperabilityIt is possible to transition between kdb and kgdb dynamically.
The debug core will remember which you used the last time and
automatically start in the same mode.Switching between kdb and kgdbSwitching from kgdb to kdb
There are two ways to switch from kgdb to kdb: you can use gdb to
issue a maintenance packet, or you can blindly type the command $3#33.
Whenever kernel debugger stops in kgdb mode it will print the
message KGDB or $3#33 for KDB.  It is important
to note that you have to type the sequence correctly in one pass.
You cannot type a backspace or delete because kgdb will interpret
that as part of the debug stream.
Change from kgdb to kdb by blindly typing:$3#33Change from kgdb to kdb with gdbmaintenance packet 3NOTE: Now you must kill gdb. Typically you press control-z and
issue the command: kill -9 %
Change from kdb to kgdbThere are two ways you can change from kdb to kgdb.  You can
manually enter kgdb mode by issuing the kgdb command from the kdb
shell prompt, or you can connect gdb while the kdb shell prompt is
active.  The kdb shell looks for the typical first commands that gdb
would issue with the gdb remote protocol and if it sees one of those
commands it automatically changes into kgdb mode.From kdb issue the command:kgdbNow disconnect your terminal program and connect gdb in its placeAt the kdb prompt, disconnect the terminal program and connect gdb in its place.Running kdb commands from gdbIt is possible to run a limited set of kdb commands from gdb,
using the gdb monitor command.  You don&#39;t want to execute any of the
run control or breakpoint operations, because it can disrupt the
state of the kernel debugger.  You should be using gdb for
breakpoints and run control operations if you have gdb connected.
The more useful commands to run are things like lsmod, dmesg, ps or
possibly some of the memory information commands.  To see all the kdb
commands you can run monitor help.Example:

(gdb) monitor ps
1 idle process (state I) and
27 sleeping system daemon (state M) processes suppressed,
use &#39;ps A&#39; to see all.
Task Addr       Pid   Parent [*] cpu State Thread     Command

0xc78291d0        1        0  0    0   S  0xc7829404  init
0xc7954150      942        1  0    0   S  0xc7954384  dropbear
0xc78789c0      944        1  0    0   S  0xc7878bf4  sh
(gdb)

kgdb Test Suite
When kgdb is enabled in the kernel config you can also elect to
enable the config parameter KGDB_TESTS.  Turning this on will
enable a special kgdb I/O module which is designed to test the
kgdb internal functions.

The kgdb tests are mainly intended for developers to test the kgdb
internals as well as a tool for developing a new kgdb architecture
specific implementation.  These tests are not really for end users
of the Linux kernel.  The primary source of documentation would be
to look in the drivers/misc/kgdbts.c file.

The kgdb test suite can also be configured at compile time to run
the core set of tests by setting the kernel config parameter
KGDB_TESTS_ON_BOOT.  This particular option is aimed at automated
regression testing and does not require modifying the kernel boot
config arguments.  If this is turned on, the kgdb test suite can
be disabled by specifying &quot;kgdbts=&quot; as a kernel boot argument.
Kernel Debugger InternalsArchitecture Specifics
The kernel debugger is organized into a number of components:
The debug core
The debug core is found in kernel/debugger/debug_core.c.  It contains:
A generic OS exception handler which includes
sync&#39;ing the processors into a stopped state on an multi-CPU
system.The API to talk to the kgdb I/O driversThe API to make calls to the arch-specific kgdb implementationThe logic to perform safe memory reads and writes to memory while using the debuggerA full implementation for software breakpoints unless overridden by the archThe API to invoke either the kdb or kgdb frontend to the debug core.The structures and callback API for atomic kernel mode setting.NOTE: kgdboc is where the kms callbacks are invoked.
kgdb arch-specific implementation
This implementation is generally found in arch/*/kernel/kgdb.c.
As an example, arch/x86/kernel/kgdb.c contains the specifics to
implement HW breakpoint as well as the initialization to
dynamically register and unregister for the trap handlers on
this architecture.  The arch-specific portion implements:
contains an arch-specific trap catcher which
invokes kgdb_handle_exception() to start kgdb about doing its
worktranslation to and from gdb specific packet format to pt_regsRegistration and unregistration of architecture specific trap hooksAny special exception handling and cleanupNMI exception handling and cleanup(optional)HW breakpoints
gdbstub frontend (aka kgdb)The gdbstub is located in kernel/debug/gdbstub.c. It contains:All the logic to implement the gdb serial protocolkdb frontendThe kdb debugger shell is broken down into a number of
components.  The kdb core is located in kernel/debug/kdb.  There
are a number of helper functions in some of the other kernel
components to make it possible for kdb to examine and report
information about the kernel without taking locks that could
cause a kernel deadlock.  The kdb core contains implements the following functionality.A simple shellThe kdb core command setA registration API to register additional kdb shell commands.A good example of a self-contained kdb module
is the &quot;ftdump&quot; command for dumping the ftrace buffer.  See:
kernel/trace/trace_kdb.cFor an example of how to dynamically register
a new kdb command you can build the kdb_hello.ko kernel module
from samples/kdb/kdb_hello.c.  To build this example you can
set CONFIG_SAMPLES=y and CONFIG_SAMPLE_KDB=m in your kernel
config.  Later run &quot;modprobe kdb_hello&quot; and the next time you
enter the kdb shell, you can run the &quot;hello&quot;
command.The implementation for kdb_printf() which
emits messages directly to I/O drivers, bypassing the kernel
log.SW / HW breakpoint management for the kdb shellkgdb I/O driver
Each kgdb I/O driver has to provide an implementation for the following:
configuration via built-in or moduledynamic configuration and kgdb hook registration callsread and write character interfaceA cleanup handler for unconfiguring from the kgdb core(optional) Early debug methodology
Any given kgdb I/O driver has to operate very closely with the
hardware and must do it in such a way that does not enable
interrupts or change other parts of the system context without
completely restoring them. The kgdb core will repeatedly &quot;poll&quot;
a kgdb I/O driver for characters when it needs input.  The I/O
driver is expected to return immediately if there is no data
available.  Doing so allows for the future possibility to touch
watch dog hardware in such a way as to have a target system not
reset when these are enabled.


If you are intent on adding kgdb architecture specific support
for a new architecture, the architecture should define
HAVE_ARCH_KGDB in the architecture specific
Kconfig file.  This will enable kgdb for the architecture, and
at that point you must create an architecture specific kgdb
implementation.

There are a few flags which must be set on every architecture in
their &amp;lt;asm/kgdb.h&amp;gt; file.  These are:

NUMREGBYTES: The size in bytes of all of the registers, so
that we can ensure they will all fit into a packet.

BUFMAX: The size in bytes of the buffer GDB will read into.
This must be larger than NUMREGBYTES.

CACHE_FLUSH_IS_SAFE: Set to 1 if it is always safe to call
flush_cache_range or flush_icache_range.  On some architectures,
these functions may not be safe to call on SMP since we keep other
CPUs in a holding pattern.


There are also the following functions for the common backend,
found in kernel/kgdb.c, that must be supplied by the
architecture-specific backend unless marked as (optional), in
which case a default function maybe used if the architecture
does not need to provide a specific implementation.

kgdboc internalskgdboc and uarts
The kgdboc driver is actually a very thin driver that relies on the
underlying low level to the hardware driver having &quot;polling hooks&quot;
which the to which the tty driver is attached.  In the initial
implementation of kgdboc it the serial_core was changed to expose a
low level UART hook for doing polled mode reading and writing of a
single character while in an atomic context.  When kgdb makes an I/O
request to the debugger, kgdboc invokes a callback in the serial
core which in turn uses the callback in the UART driver.
When using kgdboc with a UART, the UART driver must implement two callbacks in the struct uart_ops. Example from drivers/8250.c:
#ifdef CONFIG_CONSOLE_POLL
.poll_get_char = serial8250_get_poll_char,
.poll_put_char = serial8250_put_poll_char,
#endif

Any implementation specifics around creating a polling driver use the
#ifdef CONFIG_CONSOLE_POLL, as shown above.
Keep in mind that polling hooks have to be implemented in such a way
that they can be called from an atomic context and have to restore
the state of the UART chip on return such that the system can return
to normal when the debugger detaches.  You need to be very careful
with any kind of lock you consider, because failing here is most likely
going to mean pressing the reset button.
kgdboc and keyboardsThe kgdboc driver contains logic to configure communications
with an attached keyboard.  The keyboard infrastructure is only
compiled into the kernel when CONFIG_KDB_KEYBOARD=y is set in the
kernel configuration.The core polled keyboard driver driver for PS/2 type keyboards
is in drivers/char/kdb_keyboard.c.  This driver is hooked into the
debug core when kgdboc populates the callback in the array
called kdb_poll_funcs[].  The
kdb_get_kbd_char() is the top-level function which polls hardware
for single character input.
kgdboc and kmsThe kgdboc driver contains logic to request the graphics
display to switch to a text context when you are using
&quot;kgdboc=kms,kbd&quot;, provided that you have a video driver which has a
frame buffer console and atomic kernel mode setting support.
Every time the kernel
debugger is entered it calls kgdboc_pre_exp_handler() which in turn
calls con_debug_enter() in the virtual console layer.  On resuming kernel
execution, the kernel debugger calls kgdboc_post_exp_handler() which
in turn calls con_debug_leave().Any video driver that wants to be compatible with the kernel
debugger and the atomic kms callbacks must implement the
mode_set_base_atomic, fb_debug_enter and fb_debug_leave operations.
For the fb_debug_enter and fb_debug_leave the option exists to use
the generic drm fb helper functions or implement something custom for
the hardware.  The following example shows the initialization of the
.mode_set_base_atomic operation in
drivers/gpu/drm/i915/intel_display.c:

static const struct drm_crtc_helper_funcs intel_helper_funcs = {
[...]
.mode_set_base_atomic = intel_pipe_set_base_atomic,
[...]
};

Here is an example of how the i915 driver initializes the fb_debug_enter and fb_debug_leave functions to use the generic drm helpers in
drivers/gpu/drm/i915/intel_fb.c:

static struct fb_ops intelfb_ops = {
[...]
.fb_debug_enter = drm_fb_helper_debug_enter,
.fb_debug_leave = drm_fb_helper_debug_leave,
[...]
};

Credits
The following people have contributed to this document:
Amit Kaleamitkale@linsyssoft.comTom Rinitrini@kernel.crashing.org
In March 2008 this document was completely rewritten by:
Jason Wesseljason.wessel@windriver.com
In Jan 2010 this document was updated to include kdb.
Jason Wesseljason.wessel@windriver.com
libATA Developer&#39;s GuideJeffGarzik2003-2006Jeff Garzik
The contents of this file are subject to the Open
Software License version 1.1 that can be found at
http://fedoraproject.org/wiki/Licensing:OSL1.1
and is included herein by reference.

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License version 2 (the &quot;GPL&quot;) as distributed
in the kernel source COPYING file, in which case the provisions of
the GPL are applicable instead of the above.  If you wish to allow
the use of your version of this file only under the terms of the
GPL and not to allow others to use your version of this file under
the OSL, indicate your decision by deleting the provisions above and
replace them with the notice and other provisions required by the GPL.
If you do not delete the provisions above, a recipient may use your
version of this file under either the OSL or the GPL.
Introduction
libATA is a library used inside the Linux kernel to support ATA host
controllers and devices.  libATA provides an ATA driver API, class
transports for ATA and ATAPI devices, and SCSI&amp;lt;-&amp;gt;ATA translation
for ATA devices according to the T10 SAT specification.

This Guide documents the libATA driver API, library functions, library
internals, and a couple sample ATA low-level drivers.
libata Driver API
struct ata_port_operations is defined for every low-level libata
hardware driver, and it controls how the low-level driver
interfaces with the ATA and SCSI layers.

FIS-based drivers will hook into the system with -&amp;gt;qc_prep() and
-&amp;gt;qc_issue() high-level hooks.  Hardware which behaves in a manner
similar to PCI IDE hardware may utilize several generic helpers,
defining at a bare minimum the bus I/O addresses of the ATA shadow
register blocks.
struct ata_port_operationsDisable ATA port
void (*port_disable) (struct ata_port *);

Called from ata_bus_probe() error path, as well as when
unregistering from the SCSI module (rmmod, hot unplug).
This function should do whatever needs to be done to take the
port out of use.  In most cases, ata_port_disable() can be used
as this hook.

Called from ata_bus_probe() on a failed probe.
Called from ata_scsi_release().
Post-IDENTIFY device configuration
void (*dev_config) (struct ata_port *, struct ata_device *);

Called after IDENTIFY [PACKET] DEVICE is issued to each device
found.  Typically used to apply device-specific fixups prior to
issue of SET FEATURES - XFER MODE, and prior to operation.

This entry may be specified as NULL in ata_port_operations.
Set PIO/DMA mode
void (*set_piomode) (struct ata_port *, struct ata_device *);
void (*set_dmamode) (struct ata_port *, struct ata_device *);
void (*post_set_mode) (struct ata_port *);
unsigned int (*mode_filter) (struct ata_port *, struct ata_device *, unsigned int);

Hooks called prior to the issue of SET FEATURES - XFER MODE
command.  The optional -&amp;gt;mode_filter() hook is called when libata
has built a mask of the possible modes. This is passed to the
-&amp;gt;mode_filter() function which should return a mask of valid modes
after filtering those unsuitable due to hardware limits. It is not
valid to use this interface to add modes.

dev-&amp;gt;pio_mode and dev-&amp;gt;dma_mode are guaranteed to be valid when
-&amp;gt;set_piomode() and when -&amp;gt;set_dmamode() is called. The timings for
any other drive sharing the cable will also be valid at this point.
That is the library records the decisions for the modes of each
drive on a channel before it attempts to set any of them.

-&amp;gt;post_set_mode() is
called unconditionally, after the SET FEATURES - XFER MODE
command completes successfully.

-&amp;gt;set_piomode() is always called (if present), but
-&amp;gt;set_dma_mode() is only called if DMA is possible.
Taskfile read/write
void (*sff_tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
void (*sff_tf_read) (struct ata_port *ap, struct ata_taskfile *tf);

-&amp;gt;tf_load() is called to load the given taskfile into hardware
registers / DMA buffers.  -&amp;gt;tf_read() is called to read the
hardware registers / DMA buffers, to obtain the current set of
taskfile register values.
Most drivers for taskfile-based hardware (PIO or MMIO) use
ata_sff_tf_load() and ata_sff_tf_read() for these hooks.
PIO data read/write
void (*sff_data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);

All bmdma-style drivers must implement this hook.  This is the low-level
operation that actually copies the data bytes during a PIO data
transfer.
Typically the driver will choose one of ata_sff_data_xfer_noirq(),
ata_sff_data_xfer(), or ata_sff_data_xfer32().
ATA command execute
void (*sff_exec_command)(struct ata_port *ap, struct ata_taskfile *tf);

causes an ATA command, previously loaded with
-&amp;gt;tf_load(), to be initiated in hardware.
Most drivers for taskfile-based hardware use ata_sff_exec_command()
for this hook.
Per-cmd ATAPI DMA capabilities filter
int (*check_atapi_dma) (struct ata_queued_cmd *qc);

Allow low-level driver to filter ATA PACKET commands, returning a status
indicating whether or not it is OK to use DMA for the supplied PACKET
command.

This hook may be specified as NULL, in which case libata will
assume that atapi dma can be supported.
Read specific ATA shadow registers
u8   (*sff_check_status)(struct ata_port *ap);
u8   (*sff_check_altstatus)(struct ata_port *ap);

Reads the Status/AltStatus ATA shadow register from
hardware.  On some hardware, reading the Status register has
the side effect of clearing the interrupt condition.
Most drivers for taskfile-based hardware use
ata_sff_check_status() for this hook.
Write specific ATA shadow register
void (*sff_set_devctl)(struct ata_port *ap, u8 ctl);

Write the device control ATA shadow register to the hardware.
Most drivers don&#39;t need to define this.
Select ATA device on bus
void (*sff_dev_select)(struct ata_port *ap, unsigned int device);

Issues the low-level hardware command(s) that causes one of N
hardware devices to be considered &#39;selected&#39; (active and
available for use) on the ATA bus.  This generally has no
meaning on FIS-based devices.

Most drivers for taskfile-based hardware use
ata_sff_dev_select() for this hook.
Private tuning method
void (*set_mode) (struct ata_port *ap);

By default libata performs drive and controller tuning in
accordance with the ATA timing rules and also applies blacklists
and cable limits. Some controllers need special handling and have
custom tuning rules, typically raid controllers that use ATA
commands but do not actually do drive timing.

This hook should not be used to replace the standard controller
tuning logic when a controller has quirks. Replacing the default
tuning logic in that case would bypass handling for drive and
bridge quirks that may be important to data reliability. If a
controller needs to filter the mode selection it should use the
mode_filter hook instead.
Control PCI IDE BMDMA engine
void (*bmdma_setup) (struct ata_queued_cmd *qc);
void (*bmdma_start) (struct ata_queued_cmd *qc);
void (*bmdma_stop) (struct ata_port *ap);
u8   (*bmdma_status) (struct ata_port *ap);

When setting up an IDE BMDMA transaction, these hooks arm
(-&amp;gt;bmdma_setup), fire (-&amp;gt;bmdma_start), and halt (-&amp;gt;bmdma_stop)
the hardware&#39;s DMA engine.  -&amp;gt;bmdma_status is used to read the standard
PCI IDE DMA Status register.

These hooks are typically either no-ops, or simply not implemented, in
FIS-based drivers.

Most legacy IDE drivers use ata_bmdma_setup() for the bmdma_setup()
hook.  ata_bmdma_setup() will write the pointer to the PRD table to
the IDE PRD Table Address register, enable DMA in the DMA Command
register, and call exec_command() to begin the transfer.

Most legacy IDE drivers use ata_bmdma_start() for the bmdma_start()
hook.  ata_bmdma_start() will write the ATA_DMA_START flag to the DMA
Command register.

Many legacy IDE drivers use ata_bmdma_stop() for the bmdma_stop()
hook.  ata_bmdma_stop() clears the ATA_DMA_START flag in the DMA
command register.

Many legacy IDE drivers use ata_bmdma_status() as the bmdma_status() hook.
High-level taskfile hooks
void (*qc_prep) (struct ata_queued_cmd *qc);
int (*qc_issue) (struct ata_queued_cmd *qc);

Higher-level hooks, these two hooks can potentially supercede
several of the above taskfile/DMA engine hooks.  -&amp;gt;qc_prep is
called after the buffers have been DMA-mapped, and is typically
used to populate the hardware&#39;s DMA scatter-gather table.
Most drivers use the standard ata_qc_prep() helper function, but
more advanced drivers roll their own.

-&amp;gt;qc_issue is used to make a command active, once the hardware
and S/G tables have been prepared.  IDE BMDMA drivers use the
helper function ata_qc_issue_prot() for taskfile protocol-based
dispatch.  More advanced drivers implement their own -&amp;gt;qc_issue.

ata_qc_issue_prot() calls -&amp;gt;tf_load(), -&amp;gt;bmdma_setup(), and
-&amp;gt;bmdma_start() as necessary to initiate a transfer.
Exception and probe handling (EH)
void (*eng_timeout) (struct ata_port *ap);
void (*phy_reset) (struct ata_port *ap);

Deprecated.  Use -&amp;gt;error_handler() instead.

void (*freeze) (struct ata_port *ap);
void (*thaw) (struct ata_port *ap);

ata_port_freeze() is called when HSM violations or some other
condition disrupts normal operation of the port.  A frozen port
is not allowed to perform any operation until the port is
thawed, which usually follows a successful reset.

The optional -&amp;gt;freeze() callback can be used for freezing the port
hardware-wise (e.g. mask interrupt and stop DMA engine).  If a
port cannot be frozen hardware-wise, the interrupt handler
must ack and clear interrupts unconditionally while the port
is frozen.

The optional -&amp;gt;thaw() callback is called to perform the opposite of -&amp;gt;freeze():
prepare the port for normal operation once again.  Unmask interrupts,
start DMA engine, etc.

void (*error_handler) (struct ata_port *ap);

-&amp;gt;error_handler() is a driver&#39;s hook into probe, hotplug, and recovery
and other exceptional conditions.  The primary responsibility of an
implementation is to call ata_do_eh() or ata_bmdma_drive_eh() with a set
of EH hooks as arguments:

&#39;prereset&#39; hook (may be NULL) is called during an EH reset, before any other actions
are taken.

&#39;postreset&#39; hook (may be NULL) is called after the EH reset is performed.  Based on
existing conditions, severity of the problem, and hardware capabilities,

Either &#39;softreset&#39; (may be NULL) or &#39;hardreset&#39; (may be NULL) will be
called to perform the low-level EH reset.

void (*post_internal_cmd) (struct ata_queued_cmd *qc);

Perform any hardware-specific actions necessary to finish processing
after executing a probe-time or EH-time command via ata_exec_internal().
Hardware interrupt handling
irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);
void (*irq_clear) (struct ata_port *);

-&amp;gt;irq_handler is the interrupt handling routine registered with
the system, by libata.  -&amp;gt;irq_clear is called during probe just
before the interrupt handler is registered, to be sure hardware
is quiet.

The second argument, dev_instance, should be cast to a pointer
to struct ata_host_set.

Most legacy IDE drivers use ata_sff_interrupt() for the
irq_handler hook, which scans all ports in the host_set,
determines which queued command was active (if any), and calls
ata_sff_host_intr(ap,qc).

Most legacy IDE drivers use ata_sff_irq_clear() for the
irq_clear() hook, which simply clears the interrupt and error
flags in the DMA status register.
SATA phy read/write
int (*scr_read) (struct ata_port *ap, unsigned int sc_reg,
u32 *val);
int (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
u32 val);

Read and write standard SATA phy registers.  Currently only used
if -&amp;gt;phy_reset hook called the sata_phy_reset() helper function.
sc_reg is one of SCR_STATUS, SCR_CONTROL, SCR_ERROR, or SCR_ACTIVE.
Init and shutdown
int (*port_start) (struct ata_port *ap);
void (*port_stop) (struct ata_port *ap);
void (*host_stop) (struct ata_host_set *host_set);

-&amp;gt;port_start() is called just after the data structures for each
port are initialized.  Typically this is used to alloc per-port
DMA buffers / tables / rings, enable DMA engines, and similar
tasks.  Some drivers also use this entry point as a chance to
allocate driver-private memory for ap-&amp;gt;private_data.

Many drivers use ata_port_start() as this hook or call
it from their own port_start() hooks.  ata_port_start()
allocates space for a legacy IDE PRD table and returns.

-&amp;gt;port_stop() is called after -&amp;gt;host_stop().  Its sole function
is to release DMA/memory resources, now that they are no longer
actively being used.  Many drivers also free driver-private
data from port at this time.

-&amp;gt;host_stop() is called after all -&amp;gt;port_stop() calls
have completed.  The hook must finalize hardware shutdown, release DMA
and other resources, etc.
This hook may be specified as NULL, in which case it is not called.
Error handling
This chapter describes how errors are handled under libata.
Readers are advised to read SCSI EH
(Documentation/scsi/scsi_eh.txt) and ATA exceptions doc first.
Origins of commands
In libata, a command is represented with struct ata_queued_cmd
or qc.  qc&#39;s are preallocated during port initialization and
repetitively used for command executions.  Currently only one
qc is allocated per port but yet-to-be-merged NCQ branch
allocates one for each tag and maps each qc to NCQ tag 1-to-1.

libata commands can originate from two sources - libata itself
and SCSI midlayer.  libata internal commands are used for
initialization and error handling.  All normal blk requests
and commands for SCSI emulation are passed as SCSI commands
through queuecommand callback of SCSI host template.
How commands are issuedInternal commands
First, qc is allocated and initialized using
ata_qc_new_init().  Although ata_qc_new_init() doesn&#39;t
implement any wait or retry mechanism when qc is not
available, internal commands are currently issued only during
initialization and error recovery, so no other command is
active and allocation is guaranteed to succeed.

Once allocated qc&#39;s taskfile is initialized for the command to
be executed.  qc currently has two mechanisms to notify
completion.  One is via qc-&amp;gt;complete_fn() callback and the
other is completion qc-&amp;gt;waiting.  qc-&amp;gt;complete_fn() callback
is the asynchronous path used by normal SCSI translated
commands and qc-&amp;gt;waiting is the synchronous (issuer sleeps in
process context) path used by internal commands.

Once initialization is complete, host_set lock is acquired
and the qc is issued.
SCSI commands
All libata drivers use ata_scsi_queuecmd() as
hostt-&amp;gt;queuecommand callback.  scmds can either be simulated
or translated.  No qc is involved in processing a simulated
scmd.  The result is computed right away and the scmd is
completed.

For a translated scmd, ata_qc_new_init() is invoked to
allocate a qc and the scmd is translated into the qc.  SCSI
midlayer&#39;s completion notification function pointer is stored
into qc-&amp;gt;scsidone.

qc-&amp;gt;complete_fn() callback is used for completion
notification.  ATA commands use ata_scsi_qc_complete() while
ATAPI commands use atapi_qc_complete().  Both functions end up
calling qc-&amp;gt;scsidone to notify upper layer when the qc is
finished.  After translation is completed, the qc is issued
with ata_qc_issue().

Note that SCSI midlayer invokes hostt-&amp;gt;queuecommand while
holding host_set lock, so all above occur while holding
host_set lock.
How commands are processed
Depending on which protocol and which controller are used,
commands are processed differently.  For the purpose of
discussion, a controller which uses taskfile interface and all
standard callbacks is assumed.

Currently 6 ATA command protocols are used.  They can be
sorted into the following four categories according to how
they are processed.
ATA NO DATA or DMA
ATA_PROT_NODATA and ATA_PROT_DMA fall into this category.
These types of commands don&#39;t require any software
intervention once issued.  Device will raise interrupt on
completion.
ATA PIO
ATA_PROT_PIO is in this category.  libata currently
implements PIO with polling.  ATA_NIEN bit is set to turn
off interrupt and pio_task on ata_wq performs polling and
IO.
ATAPI NODATA or DMA
ATA_PROT_ATAPI_NODATA and ATA_PROT_ATAPI_DMA are in this
category.  packet_task is used to poll BSY bit after
issuing PACKET command.  Once BSY is turned off by the
device, packet_task transfers CDB and hands off processing
to interrupt handler.
ATAPI PIO
ATA_PROT_ATAPI is in this category.  ATA_NIEN bit is set
and, as in ATAPI NODATA or DMA, packet_task submits cdb.
However, after submitting cdb, further processing (data
transfer) is handed off to pio_task.
How commands are completed
Once issued, all qc&#39;s are either completed with
ata_qc_complete() or time out.  For commands which are handled
by interrupts, ata_host_intr() invokes ata_qc_complete(), and,
for PIO tasks, pio_task invokes ata_qc_complete().  In error
cases, packet_task may also complete commands.

ata_qc_complete() does the following.

DMA memory is unmapped.

ATA_QCFLAG_ACTIVE is clared from qc-&amp;gt;flags.

qc-&amp;gt;complete_fn() callback is invoked.  If the return value of
the callback is not zero.  Completion is short circuited and
ata_qc_complete() returns.

__ata_qc_complete() is called, which does

qc-&amp;gt;flags is cleared to zero.

ap-&amp;gt;active_tag and qc-&amp;gt;tag are poisoned.

qc-&amp;gt;waiting is claread &amp;amp; completed (in that order).

qc is deallocated by clearing appropriate bit in ap-&amp;gt;qactive.


So, it basically notifies upper layer and deallocates qc.  One
exception is short-circuit path in #3 which is used by
atapi_qc_complete().

For all non-ATAPI commands, whether it fails or not, almost
the same code path is taken and very little error handling
takes place.  A qc is completed with success status if it
succeeded, with failed status otherwise.

However, failed ATAPI commands require more handling as
REQUEST SENSE is needed to acquire sense data.  If an ATAPI
command fails, ata_qc_complete() is invoked with error status,
which in turn invokes atapi_qc_complete() via
qc-&amp;gt;complete_fn() callback.

This makes atapi_qc_complete() set scmd-&amp;gt;result to
SAM_STAT_CHECK_CONDITION, complete the scmd and return 1.  As
the sense data is empty but scmd-&amp;gt;result is CHECK CONDITION,
SCSI midlayer will invoke EH for the scmd, and returning 1
makes ata_qc_complete() to return without deallocating the qc.
This leads us to ata_scsi_error() with partially completed qc.
ata_scsi_error()
ata_scsi_error() is the current transportt-&amp;gt;eh_strategy_handler()
for libata.  As discussed above, this will be entered in two
cases - timeout and ATAPI error completion.  This function
calls low level libata driver&#39;s eng_timeout() callback, the
standard callback for which is ata_eng_timeout().  It checks
if a qc is active and calls ata_qc_timeout() on the qc if so.
Actual error handling occurs in ata_qc_timeout().

If EH is invoked for timeout, ata_qc_timeout() stops BMDMA and
completes the qc.  Note that as we&#39;re currently in EH, we
cannot call scsi_done.  As described in SCSI EH doc, a
recovered scmd should be either retried with
scsi_queue_insert() or finished with scsi_finish_command().
Here, we override qc-&amp;gt;scsidone with scsi_finish_command() and
calls ata_qc_complete().

If EH is invoked due to a failed ATAPI qc, the qc here is
completed but not deallocated.  The purpose of this
half-completion is to use the qc as place holder to make EH
code reach this place.  This is a bit hackish, but it works.

Once control reaches here, the qc is deallocated by invoking
__ata_qc_complete() explicitly.  Then, internal qc for REQUEST
SENSE is issued.  Once sense data is acquired, scmd is
finished by directly invoking scsi_finish_command() on the
scmd.  Note that as we already have completed and deallocated
the qc which was associated with the scmd, we don&#39;t need
to/cannot call ata_qc_complete() again.
Problems with the current EH
Error representation is too crude.  Currently any and all
error conditions are represented with ATA STATUS and ERROR
registers.  Errors which aren&#39;t ATA device errors are treated
as ATA device errors by setting ATA_ERR bit.  Better error
descriptor which can properly represent ATA and other
errors/exceptions is needed.

When handling timeouts, no action is taken to make device
forget about the timed out command and ready for new commands.

EH handling via ata_scsi_error() is not properly protected
from usual command processing.  On EH entrance, the device is
not in quiescent state.  Timed out commands may succeed or
fail any time.  pio_task and atapi_task may still be running.

Too weak error recovery.  Devices / controllers causing HSM
mismatch errors and other errors quite often require reset to
return to known state.  Also, advanced error handling is
necessary to support features like NCQ and hotplug.

ATA errors are directly handled in the interrupt handler and
PIO errors in pio_task.  This is problematic for advanced
error handling for the following reasons.

First, advanced error handling often requires context and
internal qc execution.

Second, even a simple failure (say, CRC error) needs
information gathering and could trigger complex error handling
(say, resetting &amp;amp; reconfiguring).  Having multiple code
paths to gather information, enter EH and trigger actions
makes life painful.

Third, scattered EH code makes implementing low level drivers
difficult.  Low level drivers override libata callbacks.  If
EH is scattered over several places, each affected callbacks
should perform its part of error handling.  This can be error
prone and painful.
libata Library
libata Core Internals
libata SCSI translation/emulation
ATA errors and exceptions
This chapter tries to identify what error/exception conditions exist
for ATA/ATAPI devices and describe how they should be handled in
implementation-neutral way.

The term &#39;error&#39; is used to describe conditions where either an
explicit error condition is reported from device or a command has
timed out.

The term &#39;exception&#39; is either used to describe exceptional
conditions which are not errors (say, power or hotplug events), or
to describe both errors and non-error exceptional conditions.  Where
explicit distinction between error and exception is necessary, the
term &#39;non-error exception&#39; is used.
Exception categories
Exceptions are described primarily with respect to legacy
taskfile + bus master IDE interface.  If a controller provides
other better mechanism for error reporting, mapping those into
categories described below shouldn&#39;t be difficult.

In the following sections, two recovery actions - reset and
reconfiguring transport - are mentioned.  These are described
further in .
HSM violation
This error is indicated when STATUS value doesn&#39;t match HSM
requirement during issuing or execution any ATA/ATAPI command.
Examples
ATA_STATUS doesn&#39;t contain !BSY &amp;amp;&amp;amp; DRDY &amp;amp;&amp;amp; !DRQ while trying
to issue a command.

!BSY &amp;amp;&amp;amp; !DRQ during PIO data transfer.

DRQ on command completion.

!BSY &amp;amp;&amp;amp; ERR after CDB transfer starts but before the
last byte of CDB is transferred.  ATA/ATAPI standard states
that &quot;The device shall not terminate the PACKET command
with an error before the last byte of the command packet has
been written&quot; in the error outputs description of PACKET
command and the state diagram doesn&#39;t include such
transitions.

In these cases, HSM is violated and not much information
regarding the error can be acquired from STATUS or ERROR
register.  IOW, this error can be anything - driver bug,
faulty device, controller and/or cable.

As HSM is violated, reset is necessary to restore known state.
Reconfiguring transport for lower speed might be helpful too
as transmission errors sometimes cause this kind of errors.
ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)
These are errors detected and reported by ATA/ATAPI devices
indicating device problems.  For this type of errors, STATUS
and ERROR register values are valid and describe error
condition.  Note that some of ATA bus errors are detected by
ATA/ATAPI devices and reported using the same mechanism as
device errors.  Those cases are described later in this
section.

For ATA commands, this type of errors are indicated by !BSY
&amp;amp;&amp;amp; ERR during command execution and on completion.
For ATAPI commands,
!BSY &amp;amp;&amp;amp; ERR &amp;amp;&amp;amp; ABRT right after issuing PACKET
indicates that PACKET command is not supported and falls in
this category.

!BSY &amp;amp;&amp;amp; ERR(==CHK) &amp;amp;&amp;amp; !ABRT after the last
byte of CDB is transferred indicates CHECK CONDITION and
doesn&#39;t fall in this category.

!BSY &amp;amp;&amp;amp; ERR(==CHK) &amp;amp;&amp;amp; ABRT after the last byte
of CDB is transferred *probably* indicates CHECK CONDITION and
doesn&#39;t fall in this category.

Of errors detected as above, the followings are not ATA/ATAPI
device errors but ATA bus errors and should be handled
according to .
CRC error during data transfer
This is indicated by ICRC bit in the ERROR register and
means that corruption occurred during data transfer.  Up to
ATA/ATAPI-7, the standard specifies that this bit is only
applicable to UDMA transfers but ATA/ATAPI-8 draft revision
1f says that the bit may be applicable to multiword DMA and
PIO.
ABRT error during data transfer or on completion
Up to ATA/ATAPI-7, the standard specifies that ABRT could be
set on ICRC errors and on cases where a device is not able
to complete a command.  Combined with the fact that MWDMA
and PIO transfer errors aren&#39;t allowed to use ICRC bit up to
ATA/ATAPI-7, it seems to imply that ABRT bit alone could
indicate transfer errors.

However, ATA/ATAPI-8 draft revision 1f removes the part
that ICRC errors can turn on ABRT.  So, this is kind of
gray area.  Some heuristics are needed here.

ATA/ATAPI device errors can be further categorized as follows.
Media errors
This is indicated by UNC bit in the ERROR register.  ATA
devices reports UNC error only after certain number of
retries cannot recover the data, so there&#39;s nothing much
else to do other than notifying upper layer.

READ and WRITE commands report CHS or LBA of the first
failed sector but ATA/ATAPI standard specifies that the
amount of transferred data on error completion is
indeterminate, so we cannot assume that sectors preceding
the failed sector have been transferred and thus cannot
complete those sectors successfully as SCSI does.
Media changed / media change requested error
&amp;lt;&amp;lt;TODO: fill here&amp;gt;&amp;gt;
Address error
This is indicated by IDNF bit in the ERROR register.
Report to upper layer.
Other errors
This can be invalid command or parameter indicated by ABRT
ERROR bit or some other error condition.  Note that ABRT
bit can indicate a lot of things including ICRC and Address
errors.  Heuristics needed.

Depending on commands, not all STATUS/ERROR bits are
applicable.  These non-applicable bits are marked with
&quot;na&quot; in the output descriptions but up to ATA/ATAPI-7
no definition of &quot;na&quot; can be found.  However,
ATA/ATAPI-8 draft revision 1f describes &quot;N/A&quot; as
follows.
3.2.3.3a N/A
A keyword the indicates a field has no defined value in
this standard and should not be checked by the host or
device. N/A fields should be cleared to zero.

So, it seems reasonable to assume that &quot;na&quot; bits are
cleared to zero by devices and thus need no explicit masking.
ATAPI device CHECK CONDITION
ATAPI device CHECK CONDITION error is indicated by set CHK bit
(ERR bit) in the STATUS register after the last byte of CDB is
transferred for a PACKET command.  For this kind of errors,
sense data should be acquired to gather information regarding
the errors.  REQUEST SENSE packet command should be used to
acquire sense data.

Once sense data is acquired, this type of errors can be
handled similary to other SCSI errors.  Note that sense data
may indicate ATA bus error (e.g. Sense Key 04h HARDWARE ERROR
&amp;amp;&amp;amp; ASC/ASCQ 47h/00h SCSI PARITY ERROR).  In such
cases, the error should be considered as an ATA bus error and
handled according to .
ATA device error (NCQ)
NCQ command error is indicated by cleared BSY and set ERR bit
during NCQ command phase (one or more NCQ commands
outstanding).  Although STATUS and ERROR registers will
contain valid values describing the error, READ LOG EXT is
required to clear the error condition, determine which command
has failed and acquire more information.

READ LOG EXT Log Page 10h reports which tag has failed and
taskfile register values describing the error.  With this
information the failed command can be handled as a normal ATA
command error as in  and all
other in-flight commands must be retried.  Note that this
retry should not be counted - it&#39;s likely that commands
retried this way would have completed normally if it were not
for the failed command.

Note that ATA bus errors can be reported as ATA device NCQ
errors.  This should be handled as described in .

If READ LOG EXT Log Page 10h fails or reports NQ, we&#39;re
thoroughly screwed.  This condition should be treated
according to .
ATA bus error
ATA bus error means that data corruption occurred during
transmission over ATA bus (SATA or PATA).  This type of errors
can be indicated by

ICRC or ABRT error as described in .

Controller-specific error completion with error information
indicating transmission error.

On some controllers, command timeout.  In this case, there may
be a mechanism to determine that the timeout is due to
transmission error.

Unknown/random errors, timeouts and all sorts of weirdities.

As described above, transmission errors can cause wide variety
of symptoms ranging from device ICRC error to random device
lockup, and, for many cases, there is no way to tell if an
error condition is due to transmission error or not;
therefore, it&#39;s necessary to employ some kind of heuristic
when dealing with errors and timeouts.  For example,
encountering repetitive ABRT errors for known supported
command is likely to indicate ATA bus error.

Once it&#39;s determined that ATA bus errors have possibly
occurred, lowering ATA bus transmission speed is one of
actions which may alleviate the problem.  See  for more information.
PCI bus error
Data corruption or other failures during transmission over PCI
(or other system bus).  For standard BMDMA, this is indicated
by Error bit in the BMDMA Status register.  This type of
errors must be logged as it indicates something is very wrong
with the system.  Resetting host controller is recommended.
Late completion
This occurs when timeout occurs and the timeout handler finds
out that the timed out command has completed successfully or
with error.  This is usually caused by lost interrupts.  This
type of errors must be logged.  Resetting host controller is
recommended.
Unknown error (timeout)
This is when timeout occurs and the command is still
processing or the host and device are in unknown state.  When
this occurs, HSM could be in any valid or invalid state.  To
bring the device to known state and make it forget about the
timed out command, resetting is necessary.  The timed out
command may be retried.

Timeouts can also be caused by transmission errors.  Refer to
for more details.
Hotplug and power management exceptions
&amp;lt;&amp;lt;TODO: fill here&amp;gt;&amp;gt;
EH recovery actions
This section discusses several important recovery actions.
Clearing error condition
Many controllers require its error registers to be cleared by
error handler.  Different controllers may have different
requirements.

For SATA, it&#39;s strongly recommended to clear at least SError
register during error handling.
Reset
During EH, resetting is necessary in the following cases.

HSM is in unknown or invalid state

HBA is in unknown or invalid state

EH needs to make HBA/device forget about in-flight commands

HBA/device behaves weirdly

Resetting during EH might be a good idea regardless of error
condition to improve EH robustness.  Whether to reset both or
either one of HBA and device depends on situation but the
following scheme is recommended.

When it&#39;s known that HBA is in ready state but ATA/ATAPI
device is in unknown state, reset only device.

If HBA is in unknown state, reset both HBA and device.

HBA resetting is implementation specific.  For a controller
complying to taskfile/BMDMA PCI IDE, stopping active DMA
transaction may be sufficient iff BMDMA state is the only HBA
context.  But even mostly taskfile/BMDMA PCI IDE complying
controllers may have implementation specific requirements and
mechanism to reset themselves.  This must be addressed by
specific drivers.

OTOH, ATA/ATAPI standard describes in detail ways to reset
ATA/ATAPI devices.
PATA hardware reset
This is hardware initiated device reset signalled with
asserted PATA RESET- signal.  There is no standard way to
initiate hardware reset from software although some
hardware provides registers that allow driver to directly
tweak the RESET- signal.
Software reset
This is achieved by turning CONTROL SRST bit on for at
least 5us.  Both PATA and SATA support it but, in case of
SATA, this may require controller-specific support as the
second Register FIS to clear SRST should be transmitted
while BSY bit is still set.  Note that on PATA, this resets
both master and slave devices on a channel.
EXECUTE DEVICE DIAGNOSTIC command
Although ATA/ATAPI standard doesn&#39;t describe exactly, EDD
implies some level of resetting, possibly similar level
with software reset.  Host-side EDD protocol can be handled
with normal command processing and most SATA controllers
should be able to handle EDD&#39;s just like other commands.
As in software reset, EDD affects both devices on a PATA
bus.

Although EDD does reset devices, this doesn&#39;t suit error
handling as EDD cannot be issued while BSY is set and it&#39;s
unclear how it will act when device is in unknown/weird
state.
ATAPI DEVICE RESET command
This is very similar to software reset except that reset
can be restricted to the selected device without affecting
the other device sharing the cable.
SATA phy reset
This is the preferred way of resetting a SATA device.  In
effect, it&#39;s identical to PATA hardware reset.  Note that
this can be done with the standard SCR Control register.
As such, it&#39;s usually easier to implement than software
reset.

One more thing to consider when resetting devices is that
resetting clears certain configuration parameters and they
need to be set to their previous or newly adjusted values
after reset.

Parameters affected are.

CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)

Parameters set with SET FEATURES including transfer mode setting

Block count set with SET MULTIPLE MODE

Other parameters (SET MAX, MEDIA LOCK...)

ATA/ATAPI standard specifies that some parameters must be
maintained across hardware or software reset, but doesn&#39;t
strictly specify all of them.  Always reconfiguring needed
parameters after reset is required for robustness.  Note that
this also applies when resuming from deep sleep (power-off).

Also, ATA/ATAPI standard requires that IDENTIFY DEVICE /
IDENTIFY PACKET DEVICE is issued after any configuration
parameter is updated or a hardware reset and the result used
for further operation.  OS driver is required to implement
revalidation mechanism to support this.
Reconfigure transport
For both PATA and SATA, a lot of corners are cut for cheap
connectors, cables or controllers and it&#39;s quite common to see
high transmission error rate.  This can be mitigated by
lowering transmission speed.

The following is a possible scheme Jeff Garzik suggested.

If more than $N (3?) transmission errors happen in 15 minutes,

if SATA, decrease SATA PHY speed.  if speed cannot be decreased,

decrease UDMA xfer speed.  if at UDMA0, switch to PIO4,

decrease PIO xfer speed.  if at PIO3, complain, but continue
ata_piix Internals
sata_sil Internals
Thanks
The bulk of the ATA knowledge comes thanks to long conversations with
Andre Hedrick (www.linux-ide.org), and long hours pondering the ATA
and SCSI specifications.

Thanks to Alan Cox for pointing out similarities
between SATA and SCSI, and in general for motivation to hack on
libata.

libata&#39;s device detection
method, ata_pio_devchk, and in general all the early probing was
based on extensive study of Hale Landis&#39;s probe/reset code in his
ATADRVR driver (www.ata-atapi.com).
Reed-Solomon Library Programming InterfaceThomasGleixnertglx@linutronix.de2004Thomas Gleixner
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
The generic Reed-Solomon Library provides encoding, decoding
and error correction functions.

Reed-Solomon codes are used in communication and storage
applications to ensure data integrity.

This documentation is provided for developers who want to utilize
the functions provided by the library.
Known Bugs And Assumptions
None.
Usage
This chapter provides examples of how to use the library.
Initializing
The init function init_rs returns a pointer to an
rs decoder structure, which holds the necessary
information for encoding, decoding and error correction
with the given polynomial. It either uses an existing
matching decoder or creates a new one. On creation all
the lookup tables for fast en/decoding are created.
The function may take a while, so make sure not to
call it in critical code paths.

/* the Reed Solomon control structure */
static struct rs_control *rs_decoder;

/* Symbolsize is 10 (bits)
* Primitive polynomial is x^10+x^3+1
* first consecutive root is 0
* primitive element to generate roots = 1
* generator polynomial degree (number of roots) = 6
*/
rs_decoder = init_rs (10, 0x409, 0, 1, 6);
Encoding
The encoder calculates the Reed-Solomon code over
the given data length and stores the result in
the parity buffer. Note that the parity buffer must
be initialized before calling the encoder.

The expanded data can be inverted on the fly by
providing a non-zero inversion mask. The expanded data is
XOR&#39;ed with the mask. This is used e.g. for FLASH
ECC, where the all 0xFF is inverted to an all 0x00.
The Reed-Solomon code for all 0x00 is all 0x00. The
code is inverted before storing to FLASH so it is 0xFF
too. This prevents that reading from an erased FLASH
results in ECC errors.

The databytes are expanded to the given symbol size
on the fly. There is no support for encoding continuous
bitstreams with a symbol size != 8 at the moment. If
it is necessary it should be not a big deal to implement
such functionality.

/* Parity buffer. Size = number of roots */
uint16_t par[6];
/* Initialize the parity buffer */
memset(par, 0, sizeof(par));
/* Encode 512 byte in data8. Store parity in buffer par */
encode_rs8 (rs_decoder, data8, 512, par, 0);
Decoding
The decoder calculates the syndrome over
the given data length and the received parity symbols
and corrects errors in the data.

If a syndrome is available from a hardware decoder
then the syndrome calculation is skipped.

The correction of the data buffer can be suppressed
by providing a correction pattern buffer and an error
location buffer to the decoder. The decoder stores the
calculated error location and the correction bitmask
in the given buffers. This is useful for hardware
decoders which use a weird bit ordering scheme.

The databytes are expanded to the given symbol size
on the fly. There is no support for decoding continuous
bitstreams with a symbolsize != 8 at the moment. If
it is necessary it should be not a big deal to implement
such functionality.

Decoding with syndrome calculation, direct data correction

/* Parity buffer. Size = number of roots */
uint16_t par[6];
uint8_t  data[512];
int numerr;
/* Receive data */
.....
/* Receive parity */
.....
/* Decode 512 byte in data8.*/
numerr = decode_rs8 (rs_decoder, data8, par, 512, NULL, 0, NULL, 0, NULL);

Decoding with syndrome given by hardware decoder, direct data correction

/* Parity buffer. Size = number of roots */
uint16_t par[6], syn[6];
uint8_t  data[512];
int numerr;
/* Receive data */
.....
/* Receive parity */
.....
/* Get syndrome from hardware decoder */
.....
/* Decode 512 byte in data8.*/
numerr = decode_rs8 (rs_decoder, data8, par, 512, syn, 0, NULL, 0, NULL);

Decoding with syndrome given by hardware decoder, no direct data correction.

Note: It&#39;s not necessary to give data and received parity to the decoder.

/* Parity buffer. Size = number of roots */
uint16_t par[6], syn[6], corr[8];
uint8_t  data[512];
int numerr, errpos[8];
/* Receive data */
.....
/* Receive parity */
.....
/* Get syndrome from hardware decoder */
.....
/* Decode 512 byte in data8.*/
numerr = decode_rs8 (rs_decoder, NULL, NULL, 512, syn, 0, errpos, 0, corr);
for (i = 0; i &amp;lt; numerr; i++) {
do_error_correction_in_your_buffer(errpos[i], corr[i]);
}
Cleanup
The function free_rs frees the allocated resources,
if the caller is the last user of the decoder.

/* Release resources */
free_rs(rs_decoder);
Structures
This chapter contains the autogenerated documentation of the structures which are
used in the Reed-Solomon Library and are relevant for a developer.

Public Functions Provided
This chapter contains the autogenerated documentation of the Reed-Solomon functions
which are exported.

Credits
The library code for encoding and decoding was written by Phil Karn.

Copyright 2002, Phil Karn, KA9Q
May be used under the terms of the GNU General Public License (GPL)

The wrapper functions and interfaces are written by Thomas Gleixner.

Many users have provided bugfixes, improvements and helping hands for testing.
Thanks a lot.

The following people have contributed to this document:

Thomas Gleixnertglx@linutronix.de
Linux Security Modules:  General Security Hooks for LinuxStephenSmalleyNAI Labsssmalley@nai.comTimothyFraserNAI Labstfraser@nai.comChrisVanceNAI Labscvance@nai.comIntroduction
In March 2001, the National Security Agency (NSA) gave a presentation
about Security-Enhanced Linux (SELinux) at the 2.5 Linux Kernel
Summit.  SELinux is an implementation of flexible and fine-grained
nondiscretionary access controls in the Linux kernel, originally
implemented as its own particular kernel patch.  Several other
security projects (e.g. RSBAC, Medusa) have also developed flexible
access control architectures for the Linux kernel, and various
projects have developed particular access control models for Linux
(e.g. LIDS, DTE, SubDomain).  Each project has developed and
maintained its own kernel patch to support its security needs.

In response to the NSA presentation, Linus Torvalds made a set of
remarks that described a security framework he would be willing to
consider for inclusion in the mainstream Linux kernel.  He described a
general framework that would provide a set of security hooks to
control operations on kernel objects and a set of opaque security
fields in kernel data structures for maintaining security attributes.
This framework could then be used by loadable kernel modules to
implement any desired model of security.  Linus also suggested the
possibility of migrating the Linux capabilities code into such a
module.

The Linux Security Modules (LSM) project was started by WireX to
develop such a framework.  LSM is a joint development effort by
several security projects, including Immunix, SELinux, SGI and Janus,
and several individuals, including Greg Kroah-Hartman and James
Morris, to develop a Linux kernel patch that implements this
framework.  The patch is currently tracking the 2.4 series and is
targeted for integration into the 2.5 development series.  This
technical report provides an overview of the framework and the example
capabilities security module provided by the LSM kernel patch.
LSM Framework
The LSM kernel patch provides a general kernel framework to support
security modules.  In particular, the LSM framework is primarily
focused on supporting access control modules, although future
development is likely to address other security needs such as
auditing.  By itself, the framework does not provide any additional
security; it merely provides the infrastructure to support security
modules.  The LSM kernel patch also moves most of the capabilities
logic into an optional security module, with the system defaulting
to the traditional superuser logic.  This capabilities module
is discussed further in .

The LSM kernel patch adds security fields to kernel data structures
and inserts calls to hook functions at critical points in the kernel
code to manage the security fields and to perform access control.  It
also adds functions for registering and unregistering security
modules, and adds a general security system call
to support new system calls for security-aware applications.

The LSM security fields are simply void* pointers.  For
process and program execution security information, security fields
were added to struct task_struct and
struct linux_binprm.  For filesystem security
information, a security field was added to
struct super_block.  For pipe, file, and socket
security information, security fields were added to
struct inode and
struct file.  For packet and network device security
information, security fields were added to
struct sk_buff and
struct net_device.  For System V IPC security
information, security fields were added to
struct kern_ipc_perm and
struct msg_msg; additionally, the definitions
for struct msg_msg, struct
msg_queue, and struct
shmid_kernel were moved to header files
(include/linux/msg.h and
include/linux/shm.h as appropriate) to allow
the security modules to use these definitions.

Each LSM hook is a function pointer in a global table,
security_ops. This table is a
security_operations structure as defined by
include/linux/security.h.  Detailed documentation
for each hook is included in this header file.  At present, this
structure consists of a collection of substructures that group related
hooks based on the kernel object (e.g. task, inode, file, sk_buff,
etc) as well as some top-level hook function pointers for system
operations.  This structure is likely to be flattened in the future
for performance.  The placement of the hook calls in the kernel code
is described by the &quot;called:&quot; lines in the per-hook documentation in
the header file.  The hook calls can also be easily found in the
kernel code by looking for the string &quot;security_ops-&amp;gt;&quot;.


Linus mentioned per-process security hooks in his original remarks as a
possible alternative to global security hooks.  However, if LSM were
to start from the perspective of per-process hooks, then the base
framework would have to deal with how to handle operations that
involve multiple processes (e.g. kill), since each process might have
its own hook for controlling the operation.  This would require a
general mechanism for composing hooks in the base framework.
Additionally, LSM would still need global hooks for operations that
have no process context (e.g. network input operations).
Consequently, LSM provides global security hooks, but a security
module is free to implement per-process hooks (where that makes sense)
by storing a security_ops table in each process&#39; security field and
then invoking these per-process hooks from the global hooks.
The problem of composition is thus deferred to the module.

The global security_ops table is initialized to a set of hook
functions provided by a dummy security module that provides
traditional superuser logic.  A register_security
function (in security/security.c) is provided to
allow a security module to set security_ops to refer to its own hook
functions, and an unregister_security function is
provided to revert security_ops to the dummy module hooks.  This
mechanism is used to set the primary security module, which is
responsible for making the final decision for each hook.

LSM also provides a simple mechanism for stacking additional security
modules with the primary security module.  It defines
register_security and
unregister_security hooks in the
security_operations structure and provides
mod_reg_security and
mod_unreg_security functions that invoke these
hooks after performing some sanity checking.  A security module can
call these functions in order to stack with other modules.  However,
the actual details of how this stacking is handled are deferred to the
module, which can implement these hooks in any way it wishes
(including always returning an error if it does not wish to support
stacking).  In this manner, LSM again defers the problem of
composition to the module.

Although the LSM hooks are organized into substructures based on
kernel object, all of the hooks can be viewed as falling into two
major categories: hooks that are used to manage the security fields
and hooks that are used to perform access control.  Examples of the
first category of hooks include the
alloc_security and
free_security hooks defined for each kernel data
structure that has a security field.  These hooks are used to allocate
and free security structures for kernel objects.  The first category
of hooks also includes hooks that set information in the security
field after allocation, such as the post_lookup
hook in struct inode_security_ops.  This hook
is used to set security information for inodes after successful lookup
operations.  An example of the second category of hooks is the
permission hook in
struct inode_security_ops.  This hook checks
permission when accessing an inode.
LSM Capabilities Module
The LSM kernel patch moves most of the existing POSIX.1e capabilities
logic into an optional security module stored in the file
security/capability.c.  This change allows
users who do not want to use capabilities to omit this code entirely
from their kernel, instead using the dummy module for traditional
superuser logic or any other module that they desire.  This change
also allows the developers of the capabilities logic to maintain and
enhance their code more freely, without needing to integrate patches
back into the base kernel.

In addition to moving the capabilities logic, the LSM kernel patch
could move the capability-related fields from the kernel data
structures into the new security fields managed by the security
modules.  However, at present, the LSM kernel patch leaves the
capability fields in the kernel data structures.  In his original
remarks, Linus suggested that this might be preferable so that other
security modules can be easily stacked with the capabilities module
without needing to chain multiple security structures on the security field.
It also avoids imposing extra overhead on the capabilities module
to manage the security fields.  However, the LSM framework could
certainly support such a move if it is determined to be desirable,
with only a few additional changes described below.

At present, the capabilities logic for computing process capabilities
on execve and set*uid,
checking capabilities for a particular process, saving and checking
capabilities for netlink messages, and handling the
capget and capset system
calls have been moved into the capabilities module.  There are still a
few locations in the base kernel where capability-related fields are
directly examined or modified, but the current version of the LSM
patch does allow a security module to completely replace the
assignment and testing of capabilities.  These few locations would
need to be changed if the capability-related fields were moved into
the security field.  The following is a list of known locations that
still perform such direct examination or modification of
capability-related fields:
fs/open.c:sys_accessfs/lockd/host.c:nlm_bind_hostfs/nfsd/auth.c:nfsd_setuserfs/proc/array.c:task_cap
LINUX MEDIA INFRASTRUCTURE API2009-2012LinuxTV DevelopersPermission is granted to copy, distribute and/or modify
this document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation. A copy of the license is included in the chapter entitled
&quot;GNU Free Documentation License&quot;&lt;!-- autogenerated --&gt;IntroductionThis document covers the Linux Kernel to Userspace API&#39;s used by
video and radio straming devices, including video cameras,
analog and digital TV receiver cards, AM/FM receiver cards,
streaming capture devices.It is divided into four parts.The first part covers radio, capture,
cameras and analog TV devices.The second part covers the
API used for digital TV and Internet reception via one of the
several digital tv standards. While it is called as DVB API,
in fact it covers several different video standards including
DVB-T, DVB-S, DVB-C and ATSC. The API is currently being updated
to documment support also for DVB-S2, ISDB-T and ISDB-S.The third part covers the Remote Controller API.The fourth part covers the Media Controller API.For additional information and for the latest development code,
see: http://linuxtv.org.For discussing improvements, reporting troubles, sending new drivers, etc, please mail to: Linux Media Mailing List (LMML)..
&amp;sub-v4l2;

&amp;sub-dvbapi;
MauroChehabCarvalhomchehab@redhat.comInitial version.2009-2012Mauro Carvalho Chehab&lt;!-- Put document revisions here, newest first. --&gt;1.0.02009-09-06mccInitial revisionRemote Controller API
&amp;sub-remote_controllers;

&amp;sub-media-controller;

&amp;sub-gen-errors;



&amp;sub-fdl-appendix;

MTD NAND Driver Programming InterfaceThomasGleixnertglx@linutronix.de2004Thomas Gleixner
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
The generic NAND driver supports almost all NAND and AG-AND based
chips and connects them to the Memory Technology Devices (MTD)
subsystem of the Linux Kernel.

This documentation is provided for developers who want to implement
board drivers or filesystem drivers suitable for NAND devices.
Known Bugs And Assumptions
None.
Documentation hints
The function and structure docs are autogenerated. Each function and
struct member has a short description which is marked with an [XXX] identifier.
The following chapters explain the meaning of those identifiers.
Function identifiers [XXX]
The functions are marked with [XXX] identifiers in the short
comment. The identifiers explain the usage and scope of the
functions. Following identifiers are used:

[MTD Interface]
These functions provide the interface to the MTD kernel API.
They are not replacable and provide functionality
which is complete hardware independent.

[NAND Interface]
These functions are exported and provide the interface to the NAND kernel API.

[GENERIC]
Generic functions are not replacable and provide functionality
which is complete hardware independent.

[DEFAULT]
Default functions provide hardware related functionality which is suitable
for most of the implementations. These functions can be replaced by the
board driver if neccecary. Those functions are called via pointers in the
NAND chip description structure. The board driver can set the functions which
should be replaced by board dependent functions before calling nand_scan().
If the function pointer is NULL on entry to nand_scan() then the pointer
is set to the default function which is suitable for the detected chip type.
Struct member identifiers [XXX]
The struct members are marked with [XXX] identifiers in the
comment. The identifiers explain the usage and scope of the
members. Following identifiers are used:

[INTERN]
These members are for NAND driver internal use only and must not be
modified. Most of these values are calculated from the chip geometry
information which is evaluated during nand_scan().

[REPLACEABLE]
Replaceable members hold hardware related functions which can be
provided by the board driver. The board driver can set the functions which
should be replaced by board dependent functions before calling nand_scan().
If the function pointer is NULL on entry to nand_scan() then the pointer
is set to the default function which is suitable for the detected chip type.

[BOARDSPECIFIC]
Board specific members hold hardware related information which must
be provided by the board driver. The board driver must set the function
pointers and datafields before calling nand_scan().

[OPTIONAL]
Optional members can hold information relevant for the board driver. The
generic NAND driver code does not use this information.
Basic board driver
For most boards it will be sufficient to provide just the
basic functions and fill out some really board dependent
members in the nand chip description structure.
Basic defines
At least you have to provide a mtd structure and
a storage for the ioremap&#39;ed chip address.
You can allocate the mtd structure using kmalloc
or you can allocate it statically.
In case of static allocation you have to allocate
a nand_chip structure too.

Kmalloc based example

static struct mtd_info *board_mtd;
static void __iomem *baseaddr;

Static example

static struct mtd_info board_mtd;
static struct nand_chip board_chip;
static void __iomem *baseaddr;
Partition defines
If you want to divide your device into partitions, then
define a partitioning scheme suitable to your board.

#define NUM_PARTITIONS 2
static struct mtd_partition partition_info[] = {
{ .name = &quot;Flash partition 1&quot;,
.offset =  0,
.size =    8 * 1024 * 1024 },
{ .name = &quot;Flash partition 2&quot;,
.offset =  MTDPART_OFS_NEXT,
.size =    MTDPART_SIZ_FULL },
};
Hardware control function
The hardware control function provides access to the
control pins of the NAND chip(s).
The access can be done by GPIO pins or by address lines.
If you use address lines, make sure that the timing
requirements are met.
GPIO based example
static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
switch(cmd){
case NAND_CTL_SETCLE: /* Set CLE pin high */ break;
case NAND_CTL_CLRCLE: /* Set CLE pin low */ break;
case NAND_CTL_SETALE: /* Set ALE pin high */ break;
case NAND_CTL_CLRALE: /* Set ALE pin low */ break;
case NAND_CTL_SETNCE: /* Set nCE pin low */ break;
case NAND_CTL_CLRNCE: /* Set nCE pin high */ break;
}
}
Address lines based example. It&#39;s assumed that the
nCE pin is driven by a chip select decoder.

static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
struct nand_chip *this = (struct nand_chip *) mtd-&amp;gt;priv;
switch(cmd){
case NAND_CTL_SETCLE: this-&amp;gt;IO_ADDR_W |= CLE_ADRR_BIT;  break;
case NAND_CTL_CLRCLE: this-&amp;gt;IO_ADDR_W &amp;amp;= ~CLE_ADRR_BIT; break;
case NAND_CTL_SETALE: this-&amp;gt;IO_ADDR_W |= ALE_ADRR_BIT;  break;
case NAND_CTL_CLRALE: this-&amp;gt;IO_ADDR_W &amp;amp;= ~ALE_ADRR_BIT; break;
}
}
Device ready function
If the hardware interface has the ready busy pin of the NAND chip connected to a
GPIO or other accessible I/O pin, this function is used to read back the state of the
pin. The function has no arguments and should return 0, if the device is busy (R/B pin
is low) and 1, if the device is ready (R/B pin is high).
If the hardware interface does not give access to the ready busy pin, then
the function must not be defined and the function pointer this-&amp;gt;dev_ready is set to NULL.
Init function
The init function allocates memory and sets up all the board
specific parameters and function pointers. When everything
is set up nand_scan() is called. This function tries to
detect and identify then chip. If a chip is found all the
internal data fields are initialized accordingly.
The structure(s) have to be zeroed out first and then filled with the neccecary
information about the device.

static int __init board_init (void)
{
struct nand_chip *this;
int err = 0;

/* Allocate memory for MTD device structure and private data */
board_mtd = kzalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);
if (!board_mtd) {
printk (&quot;Unable to allocate NAND MTD device structure.\n&quot;);
err = -ENOMEM;
goto out;
}

/* map physical address */
baseaddr = ioremap(CHIP_PHYSICAL_ADDRESS, 1024);
if (!baseaddr) {
printk(&quot;Ioremap to access NAND chip failed\n&quot;);
err = -EIO;
goto out_mtd;
}

/* Get pointer to private data */
this = (struct nand_chip *) ();
/* Link the private data with the MTD structure */
board_mtd-&amp;gt;priv = this;

/* Set address of NAND IO lines */
this-&amp;gt;IO_ADDR_R = baseaddr;
this-&amp;gt;IO_ADDR_W = baseaddr;
/* Reference hardware control function */
this-&amp;gt;hwcontrol = board_hwcontrol;
/* Set command delay time, see datasheet for correct value */
this-&amp;gt;chip_delay = CHIP_DEPENDEND_COMMAND_DELAY;
/* Assign the device ready function, if available */
this-&amp;gt;dev_ready = board_dev_ready;
this-&amp;gt;eccmode = NAND_ECC_SOFT;

/* Scan to find existence of the device */
if (nand_scan (board_mtd, 1)) {
err = -ENXIO;
goto out_ior;
}

add_mtd_partitions(board_mtd, partition_info, NUM_PARTITIONS);
goto out;

out_ior:
iounmap(baseaddr);
out_mtd:
kfree (board_mtd);
out:
return err;
}
module_init(board_init);
Exit function
The exit function is only neccecary if the driver is
compiled as a module. It releases all resources which
are held by the chip driver and unregisters the partitions
in the MTD layer.

#ifdef MODULE
static void __exit board_cleanup (void)
{
/* Release resources, unregister device */
nand_release (board_mtd);

/* unmap physical address */
iounmap(baseaddr);

/* Free the MTD device structure */
kfree (board_mtd);
}
module_exit(board_cleanup);
#endif
Advanced board driver functions
This chapter describes the advanced functionality of the NAND
driver. For a list of functions which can be overridden by the board
driver see the documentation of the nand_chip structure.
Multiple chip control
The nand driver can control chip arrays. Therefore the
board driver must provide an own select_chip function. This
function must (de)select the requested chip.
The function pointer in the nand_chip structure must
be set before calling nand_scan(). The maxchip parameter
of nand_scan() defines the maximum number of chips to
scan for. Make sure that the select_chip function can
handle the requested number of chips.

The nand driver concatenates the chips to one virtual
chip and provides this virtual chip to the MTD layer.
Note: The driver can only handle linear chip arrays
of equally sized chips. There is no support for
parallel arrays which extend the buswidth.GPIO based example
static void board_select_chip (struct mtd_info *mtd, int chip)
{
/* Deselect all chips, set all nCE pins high */
GPIO(BOARD_NAND_NCE) |= 0xff;
if (chip &amp;gt;= 0)
GPIO(BOARD_NAND_NCE) &amp;amp;= ~ (1 &amp;lt;&amp;lt; chip);
}
Address lines based example.
Its assumed that the nCE pins are connected to an
address decoder.

static void board_select_chip (struct mtd_info *mtd, int chip)
{
struct nand_chip *this = (struct nand_chip *) mtd-&amp;gt;priv;

/* Deselect all chips */
this-&amp;gt;IO_ADDR_R &amp;amp;= ~BOARD_NAND_ADDR_MASK;
this-&amp;gt;IO_ADDR_W &amp;amp;= ~BOARD_NAND_ADDR_MASK;
switch (chip) {
case 0:
this-&amp;gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIP0;
this-&amp;gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIP0;
break;
....
case n:
this-&amp;gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIPn;
this-&amp;gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIPn;
break;
}
}
Hardware ECC supportFunctions and constants
The nand driver supports three different types of
hardware ECC.
NAND_ECC_HW3_256
Hardware ECC generator providing 3 bytes ECC per
256 byte.
NAND_ECC_HW3_512
Hardware ECC generator providing 3 bytes ECC per
512 byte.
NAND_ECC_HW6_512
Hardware ECC generator providing 6 bytes ECC per
512 byte.
NAND_ECC_HW8_512
Hardware ECC generator providing 6 bytes ECC per
512 byte.

If your hardware generator has a different functionality
add it at the appropriate place in nand_base.c

The board driver must provide following functions:
enable_hwecc
This function is called before reading / writing to
the chip. Reset or initialize the hardware generator
in this function. The function is called with an
argument which let you distinguish between read
and write operations.
calculate_ecc
This function is called after read / write from / to
the chip. Transfer the ECC from the hardware to
the buffer. If the option NAND_HWECC_SYNDROME is set
then the function is only called on write. See below.
correct_data
In case of an ECC error this function is called for
error detection and correction. Return 1 respectively 2
in case the error can be corrected. If the error is
not correctable return -1. If your hardware generator
matches the default algorithm of the nand_ecc software
generator then use the correction function provided
by nand_ecc instead of implementing duplicated code.

Hardware ECC with syndrome calculation
Many hardware ECC implementations provide Reed-Solomon
codes and calculate an error syndrome on read. The syndrome
must be converted to a standard Reed-Solomon syndrome
before calling the error correction code in the generic
Reed-Solomon library.

The ECC bytes must be placed immediately after the data
bytes in order to make the syndrome generator work. This
is contrary to the usual layout used by software ECC. The
separation of data and out of band area is not longer
possible. The nand driver code handles this layout and
the remaining free bytes in the oob area are managed by
the autoplacement code. Provide a matching oob-layout
in this case. See rts_from4.c and diskonchip.c for
implementation reference. In those cases we must also
use bad block tables on FLASH, because the ECC layout is
interferring with the bad block marker positions.
See bad block table support for details.
Bad block table support
Most NAND chips mark the bad blocks at a defined
position in the spare area. Those blocks must
not be erased under any circumstances as the bad
block information would be lost.
It is possible to check the bad block mark each
time when the blocks are accessed by reading the
spare area of the first page in the block. This
is time consuming so a bad block table is used.

The nand driver supports various types of bad block
tables.
Per device
The bad block table contains all bad block information
of the device which can consist of multiple chips.
Per chip
A bad block table is used per chip and contains the
bad block information for this particular chip.
Fixed offset
The bad block table is located at a fixed offset
in the chip (device). This applies to various
DiskOnChip devices.
Automatic placed
The bad block table is automatically placed and
detected either at the end or at the beginning
of a chip (device)
Mirrored tables
The bad block table is mirrored on the chip (device) to
allow updates of the bad block table without data loss.


nand_scan() calls the function nand_default_bbt().
nand_default_bbt() selects appropriate default
bad block table desriptors depending on the chip information
which was retrieved by nand_scan().

The standard policy is scanning the device for bad
blocks and build a ram based bad block table which
allows faster access than always checking the
bad block information on the flash chip itself.
Flash based tables
It may be desired or neccecary to keep a bad block table in FLASH.
For AG-AND chips this is mandatory, as they have no factory marked
bad blocks. They have factory marked good blocks. The marker pattern
is erased when the block is erased to be reused. So in case of
powerloss before writing the pattern back to the chip this block
would be lost and added to the bad blocks. Therefore we scan the
chip(s) when we detect them the first time for good blocks and
store this information in a bad block table before erasing any
of the blocks.

The blocks in which the tables are stored are procteted against
accidental access by marking them bad in the memory bad block
table. The bad block table management functions are allowed
to circumvernt this protection.

The simplest way to activate the FLASH based bad block table support
is to set the option NAND_BBT_USE_FLASH in the bbt_option field of
the nand chip structure before calling nand_scan(). For AG-AND
chips is this done by default.
This activates the default FLASH based bad block table functionality
of the NAND driver. The default bad block table options are
Store bad block table per chipUse 2 bits per blockAutomatic placement at the end of the chipUse mirrored tables with version numbersReserve 4 blocks at the end of the chip
User defined tables
User defined tables are created by filling out a
nand_bbt_descr structure and storing the pointer in the
nand_chip structure member bbt_td before calling nand_scan().
If a mirror table is neccecary a second structure must be
created and a pointer to this structure must be stored
in bbt_md inside the nand_chip structure. If the bbt_md
member is set to NULL then only the main table is used
and no scan for the mirrored table is performed.

The most important field in the nand_bbt_descr structure
is the options field. The options define most of the
table properties. Use the predefined constants from
nand.h to define the options.
Number of bits per blockThe supported number of bits is 1, 2, 4, 8.Table per chipSetting the constant NAND_BBT_PERCHIP selects that
a bad block table is managed for each chip in a chip array.
If this option is not set then a per device bad block table
is used.Table location is absoluteUse the option constant NAND_BBT_ABSPAGE and
define the absolute page number where the bad block
table starts in the field pages. If you have selected bad block
tables per chip and you have a multi chip array then the start page
must be given for each chip in the chip array. Note: there is no scan
for a table ident pattern performed, so the fields
pattern, veroffs, offs, len can be left uninitializedTable location is automatically detectedThe table can either be located in the first or the last good
blocks of the chip (device). Set NAND_BBT_LASTBLOCK to place
the bad block table at the end of the chip (device). The
bad block tables are marked and identified by a pattern which
is stored in the spare area of the first page in the block which
holds the bad block table. Store a pointer to the pattern
in the pattern field. Further the length of the pattern has to be
stored in len and the offset in the spare area must be given
in the offs member of the nand_bbt_descr structure. For mirrored
bad block tables different patterns are mandatory.Table creationSet the option NAND_BBT_CREATE to enable the table creation
if no table can be found during the scan. Usually this is done only
once if a new chip is found. Table write supportSet the option NAND_BBT_WRITE to enable the table write support.
This allows the update of the bad block table(s) in case a block has
to be marked bad due to wear. The MTD interface function block_markbad
is calling the update function of the bad block table. If the write
support is enabled then the table is updated on FLASH.
Note: Write support should only be enabled for mirrored tables with
version control.
Table version controlSet the option NAND_BBT_VERSION to enable the table version control.
It&#39;s highly recommended to enable this for mirrored tables with write
support. It makes sure that the risk of losing the bad block
table information is reduced to the loss of the information about the
one worn out block which should be marked bad. The version is stored in
4 consecutive bytes in the spare area of the device. The position of
the version number is defined by the member veroffs in the bad block table
descriptor.Save block contents on write
In case that the block which holds the bad block table does contain
other useful information, set the option NAND_BBT_SAVECONTENT. When
the bad block table is written then the whole block is read the bad
block table is updated and the block is erased and everything is
written back. If this option is not set only the bad block table
is written and everything else in the block is ignored and erased.
Number of reserved blocks
For automatic placement some blocks must be reserved for
bad block table storage. The number of reserved blocks is defined
in the maxblocks member of the babd block table description structure.
Reserving 4 blocks for mirrored tables should be a reasonable number.
This also limits the number of blocks which are scanned for the bad
block table ident pattern.

Spare area (auto)placement
The nand driver implements different possibilities for
placement of filesystem data in the spare area,
Placement defined by fs driverAutomatic placement
The default placement function is automatic placement. The
nand driver has built in default placement schemes for the
various chiptypes. If due to hardware ECC functionality the
default placement does not fit then the board driver can
provide a own placement scheme.

File system drivers can provide a own placement scheme which
is used instead of the default placement scheme.

Placement schemes are defined by a nand_oobinfo structure

struct nand_oobinfo {
int    useecc;
int    eccbytes;
int    eccpos[24];
int    oobfree[8][2];
};

useecc
The useecc member controls the ecc and placement function. The header
file include/mtd/mtd-abi.h contains constants to select ecc and
placement. MTD_NANDECC_OFF switches off the ecc complete. This is
not recommended and available for testing and diagnosis only.
MTD_NANDECC_PLACE selects caller defined placement, MTD_NANDECC_AUTOPLACE
selects automatic placement.
eccbytes
The eccbytes member defines the number of ecc bytes per page.
eccpos
The eccpos array holds the byte offsets in the spare area where
the ecc codes are placed.
oobfree
The oobfree array defines the areas in the spare area which can be
used for automatic placement. The information is given in the format
{offset, size}. offset defines the start of the usable area, size the
length in bytes. More than one area can be defined. The list is terminated
by an {0, 0} entry.

Placement defined by fs driver
The calling function provides a pointer to a nand_oobinfo
structure which defines the ecc placement. For writes the
caller must provide a spare area buffer along with the
data buffer. The spare area buffer size is (number of pages) *
(size of spare area). For reads the buffer size is
(number of pages) * ((size of spare area) + (number of ecc
steps per page) * sizeof (int)). The driver stores the
result of the ecc check for each tuple in the spare buffer.
The storage sequence is

&amp;lt;spare data page 0&amp;gt;&amp;lt;ecc result 0&amp;gt;...&amp;lt;ecc result n&amp;gt;

...

&amp;lt;spare data page n&amp;gt;&amp;lt;ecc result 0&amp;gt;...&amp;lt;ecc result n&amp;gt;

This is a legacy mode used by YAFFS1.

If the spare area buffer is NULL then only the ECC placement is
done according to the given scheme in the nand_oobinfo structure.
Automatic placement
Automatic placement uses the built in defaults to place the
ecc bytes in the spare area. If filesystem data have to be stored /
read into the spare area then the calling function must provide a
buffer. The buffer size per page is determined by the oobfree array in
the nand_oobinfo structure.


If the spare area buffer is NULL then only the ECC placement is
done according to the default builtin scheme.
Spare area autoplacement default schemes256 byte pagesizeOffsetContentComment0x00ECC byte 0Error correction code byte 00x01ECC byte 1Error correction code byte 10x02ECC byte 2Error correction code byte 20x03Autoplace 00x04Autoplace 10x05Bad block markerIf any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved0x06Autoplace 20x07Autoplace 3512 byte pagesizeOffsetContentComment0x00ECC byte 0Error correction code byte 0 of the lower 256 Byte data in
this page0x01ECC byte 1Error correction code byte 1 of the lower 256 Bytes of data
in this page0x02ECC byte 2Error correction code byte 2 of the lower 256 Bytes of data
in this page0x03ECC byte 3Error correction code byte 0 of the upper 256 Bytes of data
in this page0x04reservedreserved0x05Bad block markerIf any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved0x06ECC byte 4Error correction code byte 1 of the upper 256 Bytes of data
in this page0x07ECC byte 5Error correction code byte 2 of the upper 256 Bytes of data
in this page0x08 - 0x0FAutoplace 0 - 72048 byte pagesizeOffsetContentComment0x00Bad block markerIf any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved0x01ReservedReserved0x02-0x27Autoplace 0 - 370x28ECC byte 0Error correction code byte 0 of the first 256 Byte data in
this page0x29ECC byte 1Error correction code byte 1 of the first 256 Bytes of data
in this page0x2AECC byte 2Error correction code byte 2 of the first 256 Bytes data in
this page0x2BECC byte 3Error correction code byte 0 of the second 256 Bytes of data
in this page0x2CECC byte 4Error correction code byte 1 of the second 256 Bytes of data
in this page0x2DECC byte 5Error correction code byte 2 of the second 256 Bytes of data
in this page0x2EECC byte 6Error correction code byte 0 of the third 256 Bytes of data
in this page0x2FECC byte 7Error correction code byte 1 of the third 256 Bytes of data
in this page0x30ECC byte 8Error correction code byte 2 of the third 256 Bytes of data
in this page0x31ECC byte 9Error correction code byte 0 of the fourth 256 Bytes of data
in this page0x32ECC byte 10Error correction code byte 1 of the fourth 256 Bytes of data
in this page0x33ECC byte 11Error correction code byte 2 of the fourth 256 Bytes of data
in this page0x34ECC byte 12Error correction code byte 0 of the fifth 256 Bytes of data
in this page0x35ECC byte 13Error correction code byte 1 of the fifth 256 Bytes of data
in this page0x36ECC byte 14Error correction code byte 2 of the fifth 256 Bytes of data
in this page0x37ECC byte 15Error correction code byte 0 of the sixt 256 Bytes of data
in this page0x38ECC byte 16Error correction code byte 1 of the sixt 256 Bytes of data
in this page0x39ECC byte 17Error correction code byte 2 of the sixt 256 Bytes of data
in this page0x3AECC byte 18Error correction code byte 0 of the seventh 256 Bytes of
data in this page0x3BECC byte 19Error correction code byte 1 of the seventh 256 Bytes of
data in this page0x3CECC byte 20Error correction code byte 2 of the seventh 256 Bytes of
data in this page0x3DECC byte 21Error correction code byte 0 of the eighth 256 Bytes of data
in this page0x3EECC byte 22Error correction code byte 1 of the eighth 256 Bytes of data
in this page0x3FECC byte 23Error correction code byte 2 of the eighth 256 Bytes of data
in this pageFilesystem support


The NAND driver provides all neccecary functions for a
filesystem via the MTD interface.

Filesystems must be aware of the NAND pecularities and
restrictions. One major restrictions of NAND Flash is, that you cannot
write as often as you want to a page. The consecutive writes to a page,
before erasing it again, are restricted to 1-3 writes, depending on the
manufacturers specifications. This applies similar to the spare area.

Therefore NAND aware filesystems must either write in page size chunks
or hold a writebuffer to collect smaller writes until they sum up to
pagesize. Available NAND aware filesystems: JFFS2, YAFFS.

The spare area usage to store filesystem data is controlled by
the spare area placement functionality which is described in one
of the earlier chapters.
Tools
The MTD project provides a couple of helpful tools to handle NAND Flash.
flasherase, flasheraseall: Erase and format FLASH partitionsnandwrite: write filesystem images to NAND FLASHnanddump: dump the contents of a NAND FLASH partitions

These tools are aware of the NAND restrictions. Please use those tools
instead of complaining about errors which are caused by non NAND aware
access methods.
Constants
This chapter describes the constants which might be relevant for a driver developer.
Chip option constantsConstants for chip id table
These constants are defined in nand.h. They are ored together to describe
the chip functionality.

/* Buswitdh is 16 bit */
#define NAND_BUSWIDTH_16    0x00000002
/* Device supports partial programming without padding */
#define NAND_NO_PADDING        0x00000004
/* Chip has cache program function */
#define NAND_CACHEPRG        0x00000008
/* Chip has copy back function */
#define NAND_COPYBACK        0x00000010
/* AND Chip which has 4 banks and a confusing page / block
* assignment. See Renesas datasheet for further information */
#define NAND_IS_AND        0x00000020
/* Chip has a array of 4 pages which can be read without
* additional ready /busy waits */
#define NAND_4PAGE_ARRAY    0x00000040

Constants for runtime options
These constants are defined in nand.h. They are ored together to describe
the functionality.

/* The hw ecc generator provides a syndrome instead a ecc value on read
* This can only work if we have the ecc bytes directly behind the
* data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
#define NAND_HWECC_SYNDROME    0x00020000

ECC selection constants
Use these constants to select the ECC algorithm.

/* No ECC. Usage is not recommended ! */
#define NAND_ECC_NONE        0
/* Software ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_SOFT        1
/* Hardware ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_HW3_256    2
/* Hardware ECC 3 byte ECC per 512 Byte data */
#define NAND_ECC_HW3_512    3
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW6_512    4
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW8_512    6

Hardware control related constants
These constants describe the requested hardware access function when
the boardspecific hardware control function is called

/* Select the chip by setting nCE to low */
#define NAND_CTL_SETNCE     1
/* Deselect the chip by setting nCE to high */
#define NAND_CTL_CLRNCE        2
/* Select the command latch by setting CLE to high */
#define NAND_CTL_SETCLE        3
/* Deselect the command latch by setting CLE to low */
#define NAND_CTL_CLRCLE        4
/* Select the address latch by setting ALE to high */
#define NAND_CTL_SETALE        5
/* Deselect the address latch by setting ALE to low */
#define NAND_CTL_CLRALE        6
/* Set write protection by setting WP to high. Not used! */
#define NAND_CTL_SETWP        7
/* Clear write protection by setting WP to low. Not used! */
#define NAND_CTL_CLRWP        8

Bad block table related constants
These constants describe the options used for bad block
table descriptors.

/* Options for the bad block table descriptors */

/* The number of bits used per block in the bbt on the device */
#define NAND_BBT_NRBITS_MSK    0x0000000F
#define NAND_BBT_1BIT        0x00000001
#define NAND_BBT_2BIT        0x00000002
#define NAND_BBT_4BIT        0x00000004
#define NAND_BBT_8BIT        0x00000008
/* The bad block table is in the last good block of the device */
#define    NAND_BBT_LASTBLOCK    0x00000010
/* The bbt is at the given page, else we must scan for the bbt */
#define NAND_BBT_ABSPAGE    0x00000020
/* bbt is stored per chip on multichip devices */
#define NAND_BBT_PERCHIP    0x00000080
/* bbt has a version counter at offset veroffs */
#define NAND_BBT_VERSION    0x00000100
/* Create a bbt if none axists */
#define NAND_BBT_CREATE        0x00000200
/* Write bbt if neccecary */
#define NAND_BBT_WRITE        0x00001000
/* Read and write back block contents when writing bbt */
#define NAND_BBT_SAVECONTENT    0x00002000

Structures
This chapter contains the autogenerated documentation of the structures which are
used in the NAND driver and might be relevant for a driver developer. Each
struct member has a short description which is marked with an [XXX] identifier.
See the chapter &quot;Documentation hints&quot; for an explanation.

Public Functions Provided
This chapter contains the autogenerated documentation of the NAND kernel API functions
which are exported. Each function has a short description which is marked with an [XXX] identifier.
See the chapter &quot;Documentation hints&quot; for an explanation.

Internal Functions Provided
This chapter contains the autogenerated documentation of the NAND driver internal functions.
Each function has a short description which is marked with an [XXX] identifier.
See the chapter &quot;Documentation hints&quot; for an explanation.
The functions marked with [DEFAULT] might be relevant for a board driver developer.

&lt;!-- No internal functions for kernel-doc:
X!Idrivers/mtd/nand/nand_ecc.c
--&gt;
Credits
The following people have contributed to the NAND driver:
Steven J. Hillsjhill@realitydiluted.comDavid Woodhousedwmw2@infradead.orgThomas Gleixnertglx@linutronix.de
A lot of users have provided bugfixes, improvements and helping hands for testing.
Thanks a lot.

The following people have contributed to this document:
Thomas Gleixnertglx@linutronix.de
Linux Networking and Network Devices APIs
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Linux NetworkingNetworking Base Types
Socket Buffer Functions
Socket Filter
Generic Network Statistics
SUN RPC subsystem&lt;!-- The !D functionality is not perfect, garbage has to be protected by comments
--&gt;
WiMAX
Network device supportDriver Support
PHY Support
&lt;!-- FIXME: Removed for now since no structured comments in source
&lt;sect1&gt;&lt;title&gt;Wireless&lt;/title&gt;
X!Enet/core/wireless.c
&lt;/sect1&gt;
--&gt;RapidIO Subsystem GuideMattPortermporter@kernel.crashing.orgmporter@mvista.com2005MontaVista Software, Inc.
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
RapidIO is a high speed switched fabric interconnect with
features aimed at the embedded market.  RapidIO provides
support for memory-mapped I/O as well as message-based
transactions over the switched fabric network. RapidIO has
a standardized discovery mechanism not unlike the PCI bus
standard that allows simple detection of devices in a
network.

This documentation is provided for developers intending
to support RapidIO on new architectures, write new drivers,
or to understand the subsystem internals.
Known Bugs and LimitationsBugsNone. ;)LimitationsAccess/management of RapidIO memory regions is not supportedMultiple host enumeration is not supportedRapidIO driver interface
Drivers are provided a set of calls in order
to interface with the subsystem to gather info
on devices, request/map memory region resources,
and manage mailboxes/doorbells.
Functions
Internals
This chapter contains the autogenerated documentation of the RapidIO
subsystem.
Structures
Enumeration and Discovery
Driver functionality
Device model support
Sysfs support
PPC32 support
Credits
The following people have contributed to the RapidIO
subsystem directly or indirectly:
Matt Portermporter@kernel.crashing.orgRandy Vinsonrvinson@mvista.comDan Malekdan@embeddedalley.com

The following people have contributed to this document:
Matt Portermporter@kernel.crashing.org
Voltage and current regulator APILiamGirdwoodlrg@slimlogic.co.ukMarkBrownWolfson Microelectronicsbroonie@opensource.wolfsonmicro.com2007-2008Wolfson Microelectronics2008Liam Girdwood

This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
This framework is designed to provide a standard kernel
interface to control voltage and current regulators.

The intention is to allow systems to dynamically control
regulator power output in order to save power and prolong
battery life.  This applies to both voltage regulators (where
voltage output is controllable) and current sinks (where current
limit is controllable).

Note that additional (and currently more complete) documentation
is available in the Linux kernel source under
Documentation/power/regulator.
Glossary
The regulator API uses a number of terms which may not be
familiar:
Regulator
Electronic device that supplies power to other devices.  Most
regulators can enable and disable their output and some can also
control their output voltage or current.
Consumer
Electronic device which consumes power provided by a regulator.
These may either be static, requiring only a fixed supply, or
dynamic, requiring active management of the regulator at
runtime.
Power Domain
The electronic circuit supplied by a given regulator, including
the regulator and all consumer devices.  The configuration of
the regulator is shared between all the components in the
circuit.
Power Management Integrated CircuitPMIC
An IC which contains numerous regulators and often also other
subsystems.  In an embedded system the primary PMIC is often
equivalent to a combination of the PSU and southbridge in a
desktop system.
Consumer driver interface
This offers a similar API to the kernel clock framework.
Consumer drivers use get and put operations to acquire and
release regulators.  Functions are
provided to enable
and disable the
reguator and to get and set the runtime parameters of the
regulator.

When requesting regulators consumers use symbolic names for their
supplies, such as &quot;Vcc&quot;, which are mapped into actual regulator
devices by the machine interface.

A stub version of this API is provided when the regulator
framework is not in use in order to minimise the need to use
ifdefs.
Enabling and disabling
The regulator API provides reference counted enabling and
disabling of regulators. Consumer devices use the regulator_enable
and regulator_disable functions to enable and disable regulators.  Calls
to the two functions must be balanced.

Note that since multiple consumers may be using a regulator and
machine constraints may not allow the regulator to be disabled
there is no guarantee that calling
regulator_disable will actually cause the
supply provided by the regulator to be disabled. Consumer
drivers should assume that the regulator may be enabled at all
times.
Configuration
Some consumer devices may need to be able to dynamically
configure their supplies.  For example, MMC drivers may need to
select the correct operating voltage for their cards.  This may
be done while the regulator is enabled or disabled.

The regulator_set_voltage and regulator_set_current_limit functions provide the primary interface for this.
Both take ranges of voltages and currents, supporting drivers
that do not require a specific value (eg, CPU frequency scaling
normally permits the CPU to use a wider range of supply
voltages at lower frequencies but does not require that the
supply voltage be lowered).  Where an exact value is required
both minimum and maximum values should be identical.
Callbacks
Callbacks may also be registered
for events such as regulation failures.
Regulator driver interface
Drivers for regulator chips register the regulators
with the regulator core, providing operations structures to the
core.  A notifier interface
allows error conditions to be reported to the core.

Registration should be triggered by explicit setup done by the
platform, supplying a struct
regulator_init_data for the regulator containing
constraint and
supply information.
Machine interface
This interface provides a way to define how regulators are
connected to consumers on a given system and what the valid
operating parameters are for the system.
Supplies
Regulator supplies are specified using struct
regulator_consumer_supply.  This is done at
driver registration
time as part of the machine constraints.
Constraints
As well as defining the connections the machine interface
also provides constraints defining the operations that
clients are allowed to perform and the parameters that may be
set.  This is required since generally regulator devices will
offer more flexibility than it is safe to use on a given
system, for example supporting higher supply voltages than the
consumers are rated for.

This is done at driver
registration time by providing a struct
regulation_constraints.

The constraints may also specify an initial configuration for the
regulator in the constraints, which is particularly useful for
use with static consumers.
API reference
Due to limitations of the kernel documentation framework and the
existing layout of the source code the entire regulator API is
documented here.

Writing s390 channel device driversCorneliaHuckcornelia.huck@de.ibm.com2007IBM Corp.
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
This document describes the interfaces available for device drivers that
drive s390 based channel attached I/O devices. This includes interfaces for
interaction with the hardware and interfaces for interacting with the
common driver core. Those interfaces are provided by the s390 common I/O
layer.

The document assumes a familarity with the technical terms associated
with the s390 channel I/O architecture. For a description of this
architecture, please refer to the &quot;z/Architecture: Principles of
Operation&quot;, IBM publication no. SA22-7832.

While most I/O devices on a s390 system are typically driven through the
channel I/O mechanism described here, there are various other methods
(like the diag interface). These are out of the scope of this document.

Some additional information can also be found in the kernel source
under Documentation/s390/driver-model.txt.
The ccw bus
The ccw bus typically contains the majority of devices available to
a s390 system. Named after the channel command word (ccw), the basic
command structure used to address its devices, the ccw bus contains
so-called channel attached devices. They are addressed via I/O
subchannels, visible on the css bus. A device driver for
channel-attached devices, however, will never interact    with the
subchannel directly, but only via the I/O device on the ccw bus,
the ccw device.
I/O functions for channel-attached devices
Some hardware structures have been translated into C structures for use
by the common I/O layer and device drivers. For more information on
the hardware structures represented here, please consult the Principles
of Operation.

ccw devices
Devices that want to initiate channel I/O need to attach to the ccw bus.
Interaction with the driver core is done via the common I/O layer, which
provides the abstractions of ccw devices and ccw device drivers.

The functions that initiate or terminate channel I/O all act upon a
ccw device structure. Device drivers must not bypass those functions
or strange side effects may happen.

The channel-measurement facility
The channel-measurement facility provides a means to collect
measurement data which is made available by the channel subsystem
for each channel attached device.

The ccwgroup bus
The ccwgroup bus only contains artificial devices, created by the user.
Many networking devices (e.g. qeth) are in fact composed of several
ccw devices (like read, write and data channel for qeth). The
ccwgroup bus provides a mechanism to create a meta-device which
contains those ccw devices as slave devices and can be associated
with the netdevice.
ccw group devices
Generic interfaces
Some interfaces are available to other drivers that do not necessarily
have anything to do with the busses described above, but still are
indirectly using basic infrastructure in the common I/O layer.
One example is the support for adapter interrupts.

SCSI Interfaces GuideJamesBottomleyJames.Bottomley@hansenpartnership.comRobLandleyrob@landley.net2007Linux Foundation
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
For more details see the file COPYING in the source
distribution of Linux.
IntroductionProtocol vs bus
Once upon a time, the Small Computer Systems Interface defined both
a parallel I/O bus and a data protocol to connect a wide variety of
peripherals (disk drives, tape drives, modems, printers, scanners,
optical drives, test equipment, and medical devices) to a host
computer.

Although the old parallel (fast/wide/ultra) SCSI bus has largely
fallen out of use, the SCSI command set is more widely used than ever
to communicate with devices over a number of different busses.

The SCSI protocol
is a big-endian peer-to-peer packet based protocol.  SCSI commands
are 6, 10, 12, or 16 bytes long, often followed by an associated data
payload.

SCSI commands can be transported over just about any kind of bus, and
are the default protocol for storage devices attached to USB, SATA,
SAS, Fibre Channel, FireWire, and ATAPI devices.  SCSI packets are
also commonly exchanged over Infiniband,
I20, TCP/IP
(iSCSI), even
Parallel
ports.
Design of the Linux SCSI subsystem
The SCSI subsystem uses a three layer design, with upper, mid, and low
layers.  Every operation involving the SCSI subsystem (such as reading
a sector from a disk) uses one driver at each of the 3 levels: one
upper layer driver, one lower layer driver, and the SCSI midlayer.

The SCSI upper layer provides the interface between userspace and the
kernel, in the form of block and char device nodes for I/O and
ioctl().  The SCSI lower layer contains drivers for specific hardware
devices.

In between is the SCSI mid-layer, analogous to a network routing
layer such as the IPv4 stack.  The SCSI mid-layer routes a packet
based data protocol between the upper layer&#39;s /dev nodes and the
corresponding devices in the lower layer.  It manages command queues,
provides error handling and power management functions, and responds
to ioctl() requests.
SCSI upper layer
The upper layer supports the user-kernel interface by providing
device nodes.
sd (SCSI Disk)sd (sd_mod.o)&lt;!-- !Idrivers/scsi/sd.c --&gt;sr (SCSI CD-ROM)sr (sr_mod.o)st (SCSI Tape)st (st.o)sg (SCSI Generic)sg (sg.o)ch (SCSI Media Changer)ch (ch.c)SCSI mid layerSCSI midlayer implementationinclude/scsi/scsi_device.h

drivers/scsi/scsi.cMain file for the SCSI midlayer.
drivers/scsi/scsicam.cSCSI
Common Access Method support functions, for use with
HDIO_GETGEO, etc.

drivers/scsi/scsi_error.cCommon SCSI error/timeout handling routines.
drivers/scsi/scsi_devinfo.c
Manage scsi_dev_info_list, which tracks blacklisted and whitelisted
devices.

drivers/scsi/scsi_ioctl.c
Handle ioctl() calls for SCSI devices.

drivers/scsi/scsi_lib.c
SCSI queuing library.

drivers/scsi/scsi_lib_dma.c
SCSI library functions depending on DMA
(map and unmap scatter-gather lists).

drivers/scsi/scsi_module.c
The file drivers/scsi/scsi_module.c contains legacy support for
old-style host templates.  It should never be used by any new driver.
drivers/scsi/scsi_proc.c
The functions in this file provide an interface between
the PROC file system and the SCSI device drivers
It is mainly used for debugging, statistics and to pass
information directly to the lowlevel driver.

I.E. plumbing to manage /proc/scsi/*

drivers/scsi/scsi_netlink.c
Infrastructure to provide async events from transports to userspace
via netlink, using a single NETLINK_SCSITRANSPORT protocol for all
transports.

See the
original patch submission for more details.

drivers/scsi/scsi_scan.c
Scan a host to determine which (if any) devices are attached.

The general scanning/probing algorithm is as follows, exceptions are
made to it depending on device specific flags, compilation options,
and global variable (boot or module load time) settings.

A specific LUN is scanned via an INQUIRY command; if the LUN has a
device attached, a scsi_device is allocated and setup for it.

For every id of every channel on the given host, start by scanning
LUN 0.  Skip hosts that don&#39;t respond at all to a scan of LUN 0.
Otherwise, if LUN 0 has a device attached, allocate and setup a
scsi_device for it.  If target is SCSI-3 or up, issue a REPORT LUN,
and scan all of the LUNs returned by the REPORT LUN; else,
sequentially scan LUNs up until some maximum is reached, or a LUN is
seen that cannot have a device attached to it.

drivers/scsi/scsi_sysctl.c
Set up the sysctl entry: &quot;/dev/scsi/logging_level&quot;
(DEV_SCSI_LOGGING_LEVEL) which sets/returns scsi_logging_level.
drivers/scsi/scsi_sysfs.c
SCSI sysfs interface routines.

drivers/scsi/hosts.c
mid to lowlevel SCSI driver interface

drivers/scsi/constants.c
mid to lowlevel SCSI driver interface

Transport classes
Transport classes are service libraries for drivers in the SCSI
lower layer, which expose transport attributes in sysfs.
Fibre Channel transport
The file drivers/scsi/scsi_transport_fc.c defines transport attributes
for Fibre Channel.

iSCSI transport class
The file drivers/scsi/scsi_transport_iscsi.c defines transport
attributes for the iSCSI class, which sends SCSI packets over TCP/IP
connections.

Serial Attached SCSI (SAS) transport class
The file drivers/scsi/scsi_transport_sas.c defines transport
attributes for Serial Attached SCSI, a variant of SATA aimed at
large high-end systems.

The SAS transport class contains common code to deal with SAS HBAs,
an aproximated representation of SAS topologies in the driver model,
and various sysfs attributes to expose these topologies and management
interfaces to userspace.

In addition to the basic SCSI core objects this transport class
introduces two additional intermediate objects:  The SAS PHY
as represented by struct sas_phy defines an &quot;outgoing&quot; PHY on
a SAS HBA or Expander, and the SAS remote PHY represented by
struct sas_rphy defines an &quot;incoming&quot; PHY on a SAS Expander or
end device.  Note that this is purely a software concept, the
underlying hardware for a PHY and a remote PHY is the exactly
the same.

There is no concept of a SAS port in this code, users can see
what PHYs form a wide port based on the port_identifier attribute,
which is the same for all PHYs in a port.

SATA transport class
The SATA transport is handled by libata, which has its own book of
documentation in this directory.
Parallel SCSI (SPI) transport class
The file drivers/scsi/scsi_transport_spi.c defines transport
attributes for traditional (fast/wide/ultra) SCSI busses.

SCSI RDMA (SRP) transport class
The file drivers/scsi/scsi_transport_srp.c defines transport
attributes for SCSI over Remote Direct Memory Access.

SCSI lower layerHost Bus Adapter transport types
Many modern device controllers use the SCSI command set as a protocol to
communicate with their devices through many different types of physical
connections.

In SCSI language a bus capable of carrying SCSI commands is
called a &quot;transport&quot;, and a controller connecting to such a bus is
called a &quot;host bus adapter&quot; (HBA).
Debug transport
The file drivers/scsi/scsi_debug.c simulates a host adapter with a
variable number of disks (or disk like devices) attached, sharing a
common amount of RAM.  Does a lot of checking to make sure that we are
not getting blocks mixed up, and panics the kernel if anything out of
the ordinary is seen.

To be more realistic, the simulated devices have the transport
attributes of SAS disks.

For documentation see
http://sg.danny.cz/sg/sdebug26.html
&lt;!-- !Edrivers/scsi/scsi_debug.c --&gt;todoParallel (fast/wide/ultra) SCSI, USB, SATA,
SAS, Fibre Channel, FireWire, ATAPI devices, Infiniband,
I20, iSCSI, Parallel ports, netlink...
SuperH Interfaces GuidePaulMundtlethal@linux-sh.org2008-2010Paul Mundt2008-2010Renesas Technology Corp.2010Renesas Electronics Corp.
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Memory ManagementSH-4Store Queue API
SH-5TLB Interfaces
Machine Specific Interfacesmach-dreamcast
mach-x3proto
BussesSuperHyway
Maple
The Linux Kernel Tracepoint APIJasonBaronjbaron@redhat.comWilliamCohenwcohen@redhat.com
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
Tracepoints are static probe points that are located in strategic points
throughout the kernel. &#39;Probes&#39; register/unregister with tracepoints
via a callback mechanism. The &#39;probes&#39; are strictly typed functions that
are passed a unique set of parameters defined by each tracepoint.

From this simple callback mechanism, &#39;probes&#39; can be used to profile, debug,
and understand kernel behavior. There are a number of tools that provide a
framework for using &#39;probes&#39;. These tools include Systemtap, ftrace, and
LTTng.

Tracepoints are defined in a number of header files via various macros. Thus,
the purpose of this document is to provide a clear accounting of the available
tracepoints. The intention is to understand not only what tracepoints are
available but also to understand where future tracepoints might be added.

The API presented has functions of the form:
trace_tracepointname(function parameters). These are the
tracepoints callbacks that are found throughout the code. Registering and
unregistering probes with these callback sites is covered in the
Documentation/trace/* directory.
IRQ
SIGNAL
Block IO
Workqueue
The Userspace I/O HOWTOHans-J&amp;#1043;&amp;#1112;rgenKochLinux developer, LinutronixLinutronixhjk@hansjkoch.de2006-2008Hans-J&amp;#1043;&amp;#1112;rgen Koch.2009Red Hat Inc, Michael S. Tsirkin (mst@redhat.com)
This documentation is Free Software licensed under the terms of the
GPL version 2.
2006-12-11This HOWTO describes concept and usage of Linux kernel&#39;s
Userspace I/O system.0.92009-07-16mstAdded generic pci driver
0.82008-12-24hjkAdded name attributes in mem and portio sysfs directories.
0.72008-12-23hjkAdded generic platform drivers and offset attribute.0.62008-12-05hjkAdded description of portio sysfs attributes.0.52008-05-22hjkAdded description of write() function.0.42007-11-26hjkRemoved section about uio_dummy.0.32007-04-29hjkAdded section about userspace drivers.0.22007-02-13hjkUpdate after multiple mappings were added.0.12006-12-11hjkFirst draft.&lt;?dbhtml filename=&quot;aboutthis.html&quot;?&gt;About this document&lt;?dbhtml filename=&quot;translations.html&quot;?&gt;TranslationsIf you know of any translations for this document, or you are
interested in translating it, please email me
hjk@hansjkoch.de.
Preface
For many types of devices, creating a Linux kernel driver is
overkill.  All that is really needed is some way to handle an
interrupt and provide access to the memory space of the
device.  The logic of controlling the device does not
necessarily have to be within the kernel, as the device does
not need to take advantage of any of other resources that the
kernel provides.  One such common class of devices that are
like this are for industrial I/O cards.

To address this situation, the userspace I/O system (UIO) was
designed.  For typical industrial I/O cards, only a very small
kernel module is needed. The main part of the driver will run in
user space. This simplifies development and reduces the risk of
serious bugs within a kernel module.

Please note that UIO is not an universal driver interface. Devices
that are already handled well by other kernel subsystems (like
networking or serial or USB) are no candidates for an UIO driver.
Hardware that is ideally suited for an UIO driver fulfills all of
the following:
The device has memory that can be mapped. The device can be
controlled completely by writing to this memory.The device usually generates interrupts.The device does not fit into one of the standard kernel
subsystems.AcknowledgmentsI&#39;d like to thank Thomas Gleixner and Benedikt Spranger of
Linutronix, who have not only written most of the UIO code, but also
helped greatly writing this HOWTO by giving me all kinds of background
information.FeedbackFind something wrong with this document? (Or perhaps something
right?) I would love to hear from you. Please email me at
hjk@hansjkoch.de.&lt;?dbhtml filename=&quot;about.html&quot;?&gt;About UIOIf you use UIO for your card&#39;s driver, here&#39;s what you get:only one small kernel module to write and maintain.develop the main part of your driver in user space,
with all the tools and libraries you&#39;re used to.bugs in your driver won&#39;t crash the kernel.updates of your driver can take place without recompiling
the kernel.How UIO works
Each UIO device is accessed through a device file and several
sysfs attribute files. The device file will be called
/dev/uio0 for the first device, and
/dev/uio1, /dev/uio2
and so on for subsequent devices.
/dev/uioX is used to access the
address space of the card. Just use
mmap() to access registers or RAM
locations of your card.

Interrupts are handled by reading from
/dev/uioX. A blocking
read() from
/dev/uioX will return as soon as an
interrupt occurs. You can also use
select() on
/dev/uioX to wait for an interrupt. The
integer value read from /dev/uioX
represents the total interrupt count. You can use this number
to figure out if you missed some interrupts.

For some hardware that has more than one interrupt source internally,
but not separate IRQ mask and status registers, there might be
situations where userspace cannot determine what the interrupt source
was if the kernel handler disables them by writing to the chip&#39;s IRQ
register. In such a case, the kernel has to disable the IRQ completely
to leave the chip&#39;s register untouched. Now the userspace part can
determine the cause of the interrupt, but it cannot re-enable
interrupts. Another cornercase is chips where re-enabling interrupts
is a read-modify-write operation to a combined IRQ status/acknowledge
register. This would be racy if a new interrupt occurred
simultaneously.

To address these problems, UIO also implements a write() function. It
is normally not used and can be ignored for hardware that has only a
single interrupt source or has separate IRQ mask and status registers.
If you need it, however, a write to /dev/uioX
will call the irqcontrol() function implemented
by the driver. You have to write a 32-bit value that is usually either
0 or 1 to disable or enable interrupts. If a driver does not implement
irqcontrol(), write() will
return with -ENOSYS.

To handle interrupts properly, your custom kernel module can
provide its own interrupt handler. It will automatically be
called by the built-in handler.

For cards that don&#39;t generate interrupts but need to be
polled, there is the possibility to set up a timer that
triggers the interrupt handler at configurable time intervals.
This interrupt simulation is done by calling
uio_event_notify()
from the timer&#39;s event handler.

Each driver provides attributes that are used to read or write
variables. These attributes are accessible through sysfs
files.  A custom kernel driver module can add its own
attributes to the device owned by the uio driver, but not added
to the UIO device itself at this time.  This might change in the
future if it would be found to be useful.

The following standard attributes are provided by the UIO
framework:
name: The name of your device. It is
recommended to use the name of your kernel module for this.
version: A version string defined by your
driver. This allows the user space part of your driver to deal
with different versions of the kernel module.
event: The total number of interrupts
handled by the driver since the last time the device node was
read.

These attributes appear under the
/sys/class/uio/uioX directory.  Please
note that this directory might be a symlink, and not a real
directory.  Any userspace code that accesses it must be able
to handle this.

Each UIO device can make one or more memory regions available for
memory mapping. This is necessary because some industrial I/O cards
require access to more than one PCI memory region in a driver.

Each mapping has its own directory in sysfs, the first mapping
appears as /sys/class/uio/uioX/maps/map0/.
Subsequent mappings create directories map1/,
map2/, and so on. These directories will only
appear if the size of the mapping is not 0.

Each mapX/ directory contains four read-only files
that show attributes of the memory:
name: A string identifier for this mapping. This
is optional, the string can be empty. Drivers can set this to make it
easier for userspace to find the correct mapping.
addr: The address of memory that can be mapped.
size: The size, in bytes, of the memory
pointed to by addr.
offset: The offset, in bytes, that has to be
added to the pointer returned by mmap() to get
to the actual device memory. This is important if the device&#39;s memory
is not page aligned. Remember that pointers returned by
mmap() are always page aligned, so it is good
style to always add this offset.

From userspace, the different mappings are distinguished by adjusting
the offset parameter of the
mmap() call. To map the memory of mapping N, you
have to use N times the page size as your offset:

offset = N * getpagesize();

Sometimes there is hardware with memory-like regions that can not be
mapped with the technique described here, but there are still ways to
access them from userspace. The most common example are x86 ioports.
On x86 systems, userspace can access these ioports using
ioperm(), iopl(),
inb(), outb(), and similar
functions.

Since these ioport regions can not be mapped, they will not appear under
/sys/class/uio/uioX/maps/ like the normal memory
described above. Without information about the port regions a hardware
has to offer, it becomes difficult for the userspace part of the
driver to find out which ports belong to which UIO device.

To address this situation, the new directory
/sys/class/uio/uioX/portio/ was added. It only
exists if the driver wants to pass information about one or more port
regions to userspace. If that is the case, subdirectories named
port0, port1, and so on,
will appear underneath
/sys/class/uio/uioX/portio/.

Each portX/ directory contains four read-only
files that show name, start, size, and type of the port region:
name: A string identifier for this port region.
The string is optional and can be empty. Drivers can set it to make it
easier for userspace to find a certain port region.
start: The first port of this region.
size: The number of ports in this region.
porttype: A string describing the type of port.
&lt;?dbhtml filename=&quot;custom_kernel_module.html&quot;?&gt;Writing your own kernel module
Please have a look at uio_cif.c as an
example. The following paragraphs explain the different
sections of this file.
struct uio_info
This structure tells the framework the details of your driver,
Some of the members are required, others are optional.
const char *name: Required. The name of your driver as
it will appear in sysfs. I recommend using the name of your module for this.
const char *version: Required. This string appears in
/sys/class/uio/uioX/version.
struct uio_mem mem[ MAX_UIO_MAPS ]: Required if you
have memory that can be mapped with mmap(). For each
mapping you need to fill one of the uio_mem structures.
See the description below for details.
struct uio_port port[ MAX_UIO_PORTS_REGIONS ]: Required
if you want to pass information about ioports to userspace. For each port
region you need to fill one of the uio_port structures.
See the description below for details.
long irq: Required. If your hardware generates an
interrupt, it&#39;s your modules task to determine the irq number during
initialization. If you don&#39;t have a hardware generated interrupt but
want to trigger the interrupt handler in some other way, set
irq to UIO_IRQ_CUSTOM.
If you had no interrupt at all, you could set
irq to UIO_IRQ_NONE, though this
rarely makes sense.
unsigned long irq_flags: Required if you&#39;ve set
irq to a hardware interrupt number. The flags given
here will be used in the call to request_irq().
int (*mmap)(struct uio_info *info, struct vm_area_struct
*vma): Optional. If you need a special
mmap() function, you can set it here. If this
pointer is not NULL, your mmap() will be called
instead of the built-in one.
int (*open)(struct uio_info *info, struct inode *inode)
: Optional. You might want to have your own
open(), e.g. to enable interrupts only when your
device is actually used.
int (*release)(struct uio_info *info, struct inode *inode)
: Optional. If you define your own
open(), you will probably also want a custom
release() function.
int (*irqcontrol)(struct uio_info *info, s32 irq_on)
: Optional. If you need to be able to enable or disable
interrupts from userspace by writing to /dev/uioX,
you can implement this function. The parameter irq_on
will be 0 to disable interrupts and 1 to enable them.

Usually, your device will have one or more memory regions that can be mapped
to user space. For each region, you have to set up a
struct uio_mem in the mem[] array.
Here&#39;s a description of the fields of struct uio_mem:
const char *name: Optional. Set this to help identify
the memory region, it will show up in the corresponding sysfs node.
int memtype: Required if the mapping is used. Set this to
UIO_MEM_PHYS if you you have physical memory on your
card to be mapped. Use UIO_MEM_LOGICAL for logical
memory (e.g. allocated with kmalloc()). There&#39;s also
UIO_MEM_VIRTUAL for virtual memory.
phys_addr_t addr: Required if the mapping is used.
Fill in the address of your memory block. This address is the one that
appears in sysfs.
unsigned long size: Fill in the size of the
memory block that addr points to. If size
is zero, the mapping is considered unused. Note that you
must initialize size with zero for
all unused mappings.
void *internal_addr: If you have to access this memory
region from within your kernel module, you will want to map it internally by
using something like ioremap(). Addresses
returned by this function cannot be mapped to user space, so you must not
store it in addr. Use internal_addr
instead to remember such an address.

Please do not touch the map element of
struct uio_mem! It is used by the UIO framework
to set up sysfs files for this mapping. Simply leave it alone.

Sometimes, your device can have one or more port regions which can not be
mapped to userspace. But if there are other possibilities for userspace to
access these ports, it makes sense to make information about the ports
available in sysfs. For each region, you have to set up a
struct uio_port in the port[] array.
Here&#39;s a description of the fields of struct uio_port:
char *porttype: Required. Set this to one of the predefined
constants. Use UIO_PORT_X86 for the ioports found in x86
architectures.
unsigned long start: Required if the port region is used.
Fill in the number of the first port of this region.
unsigned long size: Fill in the number of ports in this
region. If size is zero, the region is considered unused.
Note that you must initialize size
with zero for all unused regions.

Please do not touch the portio element of
struct uio_port! It is used internally by the UIO
framework to set up sysfs files for this region. Simply leave it alone.
Adding an interrupt handler
What you need to do in your interrupt handler depends on your
hardware and on how you want to    handle it. You should try to
keep the amount of code in your kernel interrupt handler low.
If your hardware requires no action that you
have to perform after each interrupt,
then your handler can be empty.If, on the other
hand, your hardware needs some action to
be performed after each interrupt, then you
must do it in your kernel module. Note
that you cannot rely on the userspace part of your driver. Your
userspace program can terminate at any time, possibly leaving
your hardware in a state where proper interrupt handling is
still required.

There might also be applications where you want to read data
from your hardware at each interrupt and buffer it in a piece
of kernel memory you&#39;ve allocated for that purpose.  With this
technique you could avoid loss of data if your userspace
program misses an interrupt.

A note on shared interrupts: Your driver should support
interrupt sharing whenever this is possible. It is possible if
and only if your driver can detect whether your hardware has
triggered the interrupt or not. This is usually done by looking
at an interrupt status register. If your driver sees that the
IRQ bit is actually set, it will perform its actions, and the
handler returns IRQ_HANDLED. If the driver detects that it was
not your hardware that caused the interrupt, it will do nothing
and return IRQ_NONE, allowing the kernel to call the next
possible interrupt handler.

If you decide not to support shared interrupts, your card
won&#39;t work in computers with no free interrupts. As this
frequently happens on the PC platform, you can save yourself a
lot of trouble by supporting interrupt sharing.
Using uio_pdrv for platform devices
In many cases, UIO drivers for platform devices can be handled in a
generic way. In the same place where you define your
struct platform_device, you simply also implement
your interrupt handler and fill your
struct uio_info. A pointer to this
struct uio_info is then used as
platform_data for your platform device.

You also need to set up an array of struct resource
containing addresses and sizes of your memory mappings. This
information is passed to the driver using the
.resource and .num_resources
elements of struct platform_device.

You now have to set the .name element of
struct platform_device to
&quot;uio_pdrv&quot; to use the generic UIO platform device
driver. This driver will fill the mem[] array
according to the resources given, and register the device.

The advantage of this approach is that you only have to edit a file
you need to edit anyway. You do not have to create an extra driver.
Using uio_pdrv_genirq for platform devices
Especially in embedded devices, you frequently find chips where the
irq pin is tied to its own dedicated interrupt line. In such cases,
where you can be really sure the interrupt is not shared, we can take
the concept of uio_pdrv one step further and use a
generic interrupt handler. That&#39;s what
uio_pdrv_genirq does.

The setup for this driver is the same as described above for
uio_pdrv, except that you do not implement an
interrupt handler. The .handler element of
struct uio_info must remain
NULL. The  .irq_flags element
must not contain IRQF_SHARED.

You will set the .name element of
struct platform_device to
&quot;uio_pdrv_genirq&quot; to use this driver.

The generic interrupt handler of uio_pdrv_genirq
will simply disable the interrupt line using
disable_irq_nosync(). After doing its work,
userspace can reenable the interrupt by writing 0x00000001 to the UIO
device file. The driver already implements an
irq_control() to make this possible, you must not
implement your own.

Using uio_pdrv_genirq not only saves a few lines of
interrupt handler code. You also do not need to know anything about
the chip&#39;s internal registers to create the kernel part of the driver.
All you need to know is the irq number of the pin the chip is
connected to.
Using uio_dmem_genirq for platform devices
In addition to statically allocated memory ranges, they may also be
a desire to use dynamically allocated regions in a user space driver.
In particular, being able to access memory made available through the
dma-mapping API, may be particularly useful.  The
uio_dmem_genirq driver provides a way to accomplish
this.

This driver is used in a similar manner to the
&quot;uio_pdrv_genirq&quot; driver with respect to interrupt
configuration and handling.

Set the .name element of
struct platform_device to
&quot;uio_dmem_genirq&quot; to use this driver.

When using this driver, fill in the .platform_data
element of struct platform_device, which is of type
struct uio_dmem_genirq_pdata and which contains the
following elements:
struct uio_info uioinfo: The same
structure used as the  uio_pdrv_genirq platform
dataunsigned int *dynamic_region_sizes:
Pointer to list of sizes of dynamic memory regions to be mapped into
user space.
unsigned int num_dynamic_regions:
Number of elements in dynamic_region_sizes array.

The dynamic regions defined in the platform data will be appended to
the  mem[]  array after the platform device
resources, which implies that the total number of static and dynamic
memory regions cannot exceed MAX_UIO_MAPS.

The dynamic memory regions will be allocated when the UIO device file,
/dev/uioX is opened.
Simiar to static memory resources, the memory region information for
dynamic regions is then visible via sysfs at
/sys/class/uio/uioX/maps/mapY/*.
The dynmaic memory regions will be freed when the UIO device file is
closed. When no processes are holding the device file open, the address
returned to userspace is ~0.
&lt;?dbhtml filename=&quot;userspace_driver.html&quot;?&gt;Writing a driver in userspace
Once you have a working kernel module for your hardware, you can
write the userspace part of your driver. You don&#39;t need any special
libraries, your driver can be written in any reasonable language,
you can use floating point numbers and so on. In short, you can
use all the tools and libraries you&#39;d normally use for writing a
userspace application.
Getting information about your UIO device
Information about all UIO devices is available in sysfs. The
first thing you should do in your driver is check
name and version to
make sure your talking to the right device and that its kernel
driver has the version you expect.

You should also make sure that the memory mapping you need
exists and has the size you expect.

There is a tool called lsuio that lists
UIO devices and their attributes. It is available here:

http://www.osadl.org/projects/downloads/UIO/user/
With lsuio you can quickly check if your
kernel module is loaded and which attributes it exports.
Have a look at the manpage for details.

The source code of lsuio can serve as an
example for getting information about an UIO device.
The file uio_helper.c contains a lot of
functions you could use in your userspace driver code.
mmap() device memory
After you made sure you&#39;ve got the right device with the
memory mappings you need, all you have to do is to call
mmap() to map the device&#39;s memory
to userspace.

The parameter offset of the
mmap() call has a special meaning
for UIO devices: It is used to select which mapping of
your device you want to map. To map the memory of
mapping N, you have to use N times the page size as
your offset:

offset = N * getpagesize();

N starts from zero, so if you&#39;ve got only one memory
range to map, set offset = 0.
A drawback of this technique is that memory is always
mapped beginning with its start address.
Waiting for interrupts
After you successfully mapped your devices memory, you
can access it like an ordinary array. Usually, you will
perform some initialization. After that, your hardware
starts working and will generate an interrupt as soon
as it&#39;s finished, has some data available, or needs your
attention because an error occurred.
/dev/uioX is a read-only file. A
read() will always block until an
interrupt occurs. There is only one legal value for the
count parameter of
read(), and that is the size of a
signed 32 bit integer (4). Any other value for
count causes read()
to fail. The signed 32 bit integer read is the interrupt
count of your device. If the value is one more than the value
you read the last time, everything is OK. If the difference
is greater than one, you missed interrupts.

You can also use select() on
/dev/uioX.
&lt;?dbhtml filename=&quot;uio_pci_generic.html&quot;?&gt;Generic PCI UIO driver
The generic driver is a kernel module named uio_pci_generic.
It can work with any device compliant to PCI 2.3 (circa 2002) and
any compliant PCI Express device. Using this, you only need to
write the userspace driver, removing the need to write
a hardware-specific kernel module.
Making the driver recognize the device
Since the driver does not declare any device ids, it will not get loaded
automatically and will not automatically bind to any devices, you must load it
and allocate id to the driver yourself. For example:

modprobe uio_pci_generic
echo &quot;8086 10f5&quot; &amp;gt; /sys/bus/pci/drivers/uio_pci_generic/new_id


If there already is a hardware specific kernel driver for your device, the
generic driver still won&#39;t bind to it, in this case if you want to use the
generic driver (why would you?) you&#39;ll have to manually unbind the hardware
specific driver and bind the generic driver, like this:

echo -n 0000:00:19.0 &amp;gt; /sys/bus/pci/drivers/e1000e/unbind
echo -n 0000:00:19.0 &amp;gt; /sys/bus/pci/drivers/uio_pci_generic/bind


You can verify that the device has been bound to the driver
by looking for it in sysfs, for example like the following:

ls -l /sys/bus/pci/devices/0000:00:19.0/driver

Which if successful should print

.../0000:00:19.0/driver -&amp;gt; ../../../bus/pci/drivers/uio_pci_generic

Note that the generic driver will not bind to old PCI 2.2 devices.
If binding the device failed, run the following command:

dmesg

and look in the output for failure reasons
Things to know about uio_pci_generic
Interrupts are handled using the Interrupt Disable bit in the PCI command
register and Interrupt Status bit in the PCI status register.  All devices
compliant to PCI 2.3 (circa 2002) and all compliant PCI Express devices should
support these bits.  uio_pci_generic detects this support, and won&#39;t bind to
devices which do not support the Interrupt Disable Bit in the command register.

On each interrupt, uio_pci_generic sets the Interrupt Disable bit.
This prevents the device from generating further interrupts
until the bit is cleared. The userspace driver should clear this
bit before blocking and waiting for more interrupts.
Writing userspace driver using uio_pci_generic
Userspace driver can use pci sysfs interface, or the
libpci libray that wraps it, to talk to the device and to
re-enable interrupts by writing to the command register.
Example code using uio_pci_generic
Here is some sample userspace driver code using uio_pci_generic:

#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

int main()
{
int uiofd;
int configfd;
int err;
int i;
unsigned icount;
unsigned char command_high;

uiofd = open(&quot;/dev/uio0&quot;, O_RDONLY);
if (uiofd &amp;lt; 0) {
perror(&quot;uio open:&quot;);
return errno;
}
configfd = open(&quot;/sys/class/uio/uio0/device/config&quot;, O_RDWR);
if (configfd &amp;lt; 0) {
perror(&quot;config open:&quot;);
return errno;
}

/* Read and cache command value */
err = pread(configfd, &amp;amp;command_high, 1, 5);
if (err != 1) {
perror(&quot;command config read:&quot;);
return errno;
}
command_high &amp;amp;= ~0x4;

for(i = 0;; ++i) {
/* Print out a message, for debugging. */
if (i == 0)
fprintf(stderr, &quot;Started uio test driver.\n&quot;);
else
fprintf(stderr, &quot;Interrupts: %d\n&quot;, icount);

/****************************************/
/* Here we got an interrupt from the
device. Do something to it. */
/****************************************/

/* Re-enable interrupts. */
err = pwrite(configfd, &amp;amp;command_high, 1, 5);
if (err != 1) {
perror(&quot;config write:&quot;);
break;
}

/* Wait for next interrupt. */
err = read(uiofd, &amp;amp;icount, 4);
if (err != 4) {
perror(&quot;uio read:&quot;);
break;
}

}
return errno;
}


Further information
OSADL homepage.
Linutronix homepage.The Linux-USB Host Side API
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction to USB on LinuxA Universal Serial Bus (USB) is used to connect a host,
such as a PC or workstation, to a number of peripheral
devices.  USB uses a tree structure, with the host as the
root (the system&#39;s master), hubs as interior nodes, and
peripherals as leaves (and slaves).
Modern PCs support several such trees of USB devices, usually
one USB 2.0 tree (480 Mbit/sec each) with
a few USB 1.1 trees (12 Mbit/sec each) that are used when you
connect a USB 1.1 device directly to the machine&#39;s &quot;root hub&quot;.
That master/slave asymmetry was designed-in for a number of
reasons, one being ease of use.  It is not physically possible to
assemble (legal) USB cables incorrectly:  all upstream &quot;to the host&quot;
connectors are the rectangular type (matching the sockets on
root hubs), and all downstream connectors are the squarish type
(or they are built into the peripheral).
Also, the host software doesn&#39;t need to deal with distributed
auto-configuration since the pre-designated master node manages all that.
And finally, at the electrical level, bus protocol overhead is reduced by
eliminating arbitration and moving scheduling into the host software.
USB 1.0 was announced in January 1996 and was revised
as USB 1.1 (with improvements in hub specification and
support for interrupt-out transfers) in September 1998.
USB 2.0 was released in April 2000, adding high-speed
transfers and transaction-translating hubs (used for USB 1.1
and 1.0 backward compatibility).
Kernel developers added USB support to Linux early in the 2.2 kernel
series, shortly before 2.3 development forked.  Updates from 2.3 were
regularly folded back into 2.2 releases, which improved reliability and
brought /sbin/hotplug support as well more drivers.
Such improvements were continued in the 2.5 kernel series, where they added
USB 2.0 support, improved performance, and made the host controller drivers
(HCDs) more consistent.  They also simplified the API (to make bugs less
likely) and added internal &quot;kerneldoc&quot; documentation.
Linux can run inside USB devices as well as on
the hosts that control the devices.
But USB device drivers running inside those peripherals
don&#39;t do the same things as the ones running inside hosts,
so they&#39;ve been given a different name:
gadget drivers.
This document does not cover gadget drivers.
USB Host-Side API ModelHost-side drivers for USB devices talk to the &quot;usbcore&quot; APIs.
There are two.  One is intended for
general-purpose drivers (exposed through
driver frameworks), and the other is for drivers that are
part of the core.
Such core drivers include the hub driver
(which manages trees of USB devices) and several different kinds
of host controller drivers,
which control individual busses.
The device model seen by USB drivers is relatively complex.
USB supports four kinds of data transfers
(control, bulk, interrupt, and isochronous).  Two of them (control
and bulk) use bandwidth as it&#39;s available,
while the other two (interrupt and isochronous)
are scheduled to provide guaranteed bandwidth.
The device description model includes one or more
&quot;configurations&quot; per device, only one of which is active at a time.
Devices that are capable of high-speed operation must also support
full-speed configurations, along with a way to ask about the
&quot;other speed&quot; configurations which might be used.
Configurations have one or more &quot;interfaces&quot;, each
of which may have &quot;alternate settings&quot;.  Interfaces may be
standardized by USB &quot;Class&quot; specifications, or may be specific to
a vendor or device.USB device drivers actually bind to interfaces, not devices.
Think of them as &quot;interface drivers&quot;, though you
may not see many devices where the distinction is important.
Most USB devices are simple, with only one configuration,
one interface, and one alternate setting.
Interfaces have one or more &quot;endpoints&quot;, each of
which supports one type and direction of data transfer such as
&quot;bulk out&quot; or &quot;interrupt in&quot;.  The entire configuration may have
up to sixteen endpoints in each direction, allocated as needed
among all the interfaces.
Data transfer on USB is packetized; each endpoint
has a maximum packet size.
Drivers must often be aware of conventions such as flagging the end
of bulk transfers using &quot;short&quot; (including zero length) packets.
The Linux USB API supports synchronous calls for
control and bulk messages.
It also supports asynchnous calls for all kinds of data transfer,
using request structures called &quot;URBs&quot; (USB Request Blocks).
Accordingly, the USB Core API exposed to device drivers
covers quite a lot of territory.  You&#39;ll probably need to consult
the USB 2.0 specification, available online from www.usb.org at
no cost, as well as class or device specifications.
The only host-side drivers that actually touch hardware
(reading/writing registers, handling IRQs, and so on) are the HCDs.
In theory, all HCDs provide the same functionality through the same
API.  In practice, that&#39;s becoming more true on the 2.5 kernels,
but there are still differences that crop up especially with
fault handling.  Different controllers don&#39;t necessarily report
the same aspects of failures, and recovery from faults (including
software-induced ones like unlinking an URB) isn&#39;t yet fully
consistent.
Device driver authors should make a point of doing disconnect
testing (while the device is active) with each different host
controller driver, to make sure drivers don&#39;t have bugs of
their own as well as to make sure they aren&#39;t relying on some
HCD-specific behavior.
(You will need external USB 1.1 and/or
USB 2.0 hubs to perform all those tests.)
USB-Standard TypesIn &amp;lt;linux/usb/ch9.h&amp;gt; you will find
the USB data types defined in chapter 9 of the USB specification.
These data types are used throughout USB, and in APIs including
this host side API, gadget APIs, and usbfs.



Host-Side Data Types and MacrosThe host side API exposes several layers to drivers, some of
which are more necessary than others.
These support lifecycle models for host side drivers
and devices, and support passing buffers through usbcore to
some HCD that performs the I/O for the device driver.




USB Core APIsThere are two basic I/O models in the USB API.
The most elemental one is asynchronous:  drivers submit requests
in the form of an URB, and the URB&#39;s completion callback
handle the next step.
All USB transfer types support that model, although there
are special cases for control URBs (which always have setup
and status stages, but may not have a data stage) and
isochronous URBs (which allow large packets and include
per-packet fault reports).
Built on top of that is synchronous API support, where a
driver calls a routine that allocates one or more URBs,
submits them, and waits until they complete.
There are synchronous wrappers for single-buffer control
and bulk transfers (which are awkward to use in some
driver disconnect scenarios), and for scatterlist based
streaming i/o (bulk or interrupt).
USB drivers need to provide buffers that can be
used for DMA, although they don&#39;t necessarily need to
provide the DMA mapping themselves.
There are APIs to use used when allocating DMA buffers,
which can prevent use of bounce buffers on some systems.
In some cases, drivers may be able to rely on 64bit DMA
to eliminate another kind of bounce buffer.


Host Controller APIsThese APIs are only for use by host controller drivers,
most of which implement standard register interfaces such as
EHCI, OHCI, or UHCI.
UHCI was one of the first interfaces, designed by Intel and
also used by VIA; it doesn&#39;t do much in hardware.
OHCI was designed later, to have the hardware do more work
(bigger transfers, tracking protocol state, and so on).
EHCI was designed with USB 2.0; its design has features that
resemble OHCI (hardware does much more work) as well as
UHCI (some parts of ISO support, TD list processing).
There are host controllers other than the &quot;big three&quot;,
although most PCI based controllers (and a few non-PCI based
ones) use one of those interfaces.
Not all host controllers use DMA; some use PIO, and there
is also a simulator.
The same basic APIs are available to drivers for all
those controllers.
For historical reasons they are in two layers:
struct usb_bus is a rather thin
layer that became available in the 2.2 kernels, while
struct usb_hcd is a more featureful
layer (available in later 2.4 kernels and in 2.5) that
lets HCDs share common code, to shrink driver size
and significantly reduce hcd-specific behaviors.


The USB Filesystem (usbfs)This chapter presents the Linux usbfs.
You may prefer to avoid writing new kernel code for your
USB driver; that&#39;s the problem that usbfs set out to solve.
User mode device drivers are usually packaged as applications
or libraries, and may use usbfs through some programming library
that wraps it.  Such libraries include
libusb
for C/C++, and
jUSB for Java.
UnfinishedThis particular documentation is incomplete,
especially with respect to the asynchronous mode.
As of kernel 2.5.66 the code and this (new) documentation
need to be cross-reviewed.
Configure usbfs into Linux kernels by enabling the
USB filesystem option (CONFIG_USB_DEVICEFS),
and you get basic support for user mode USB device drivers.
Until relatively recently it was often (confusingly) called
usbdevfs although it wasn&#39;t solving what
devfs was.
Every USB device will appear in usbfs, regardless of whether or
not it has a kernel driver.
What files are in &quot;usbfs&quot;?Conventionally mounted at
/proc/bus/usb, usbfs
features include:
/proc/bus/usb/devices
... a text file
showing each of the USB devices on known to the kernel,
and their configuration descriptors.
You can also poll() this to learn about new devices.
/proc/bus/usb/BBB/DDD
... magic files
exposing the each device&#39;s configuration descriptors, and
supporting a series of ioctls for making device requests,
including I/O to devices.  (Purely for access by programs.)

Each bus is given a number (BBB) based on when it was
enumerated; within each bus, each device is given a similar
number (DDD).
Those BBB/DDD paths are not &quot;stable&quot; identifiers;
expect them to change even if you always leave the devices
plugged in to the same hub port.
Don&#39;t even think of saving these in application
configuration files.
Stable identifiers are available, for user mode applications
that want to use them.  HID and networking devices expose
these stable IDs, so that for example you can be sure that
you told the right UPS to power down its second server.
&quot;usbfs&quot; doesn&#39;t (yet) expose those IDs.
Mounting and Access ControlThere are a number of mount options for usbfs, which will
be of most interest to you if you need to override the default
access control policy.
That policy is that only root may read or write device files
(/proc/bus/BBB/DDD) although anyone may read
the devices
or drivers files.
I/O requests to the device also need the CAP_SYS_RAWIO capability,
The significance of that is that by default, all user mode
device drivers need super-user privileges.
You can change modes or ownership in a driver setup
when the device hotplugs, or maye just start the
driver right then, as a privileged server (or some activity
within one).
That&#39;s the most secure approach for multi-user systems,
but for single user systems (&quot;trusted&quot; by that user)
it&#39;s more convenient just to grant everyone all access
(using the devmode=0666 option)
so the driver can start whenever it&#39;s needed.
The mount options for usbfs, usable in /etc/fstab or
in command line invocations of mount, are:

busgid=NNNNNControls the GID used for the
/proc/bus/usb/BBB
directories.  (Default: 0)busmode=MMMControls the file mode used for the
/proc/bus/usb/BBB
directories.  (Default: 0555)
busuid=NNNNNControls the UID used for the
/proc/bus/usb/BBB
directories.  (Default: 0)devgid=NNNNNControls the GID used for the
/proc/bus/usb/BBB/DDD
files.  (Default: 0)devmode=MMMControls the file mode used for the
/proc/bus/usb/BBB/DDD
files.  (Default: 0644)>devuid=NNNNNControls the UID used for the
/proc/bus/usb/BBB/DDD
files.  (Default: 0)listgid=NNNNNControls the GID used for the
/proc/bus/usb/devices and drivers files.
(Default: 0)listmode=MMMControls the file mode used for the
/proc/bus/usb/devices and drivers files.
(Default: 0444)listuid=NNNNNControls the UID used for the
/proc/bus/usb/devices and drivers files.
(Default: 0)

Note that many Linux distributions hard-wire the mount options
for usbfs in their init scripts, such as
/etc/rc.d/rc.sysinit,
rather than making it easy to set this per-system
policy in /etc/fstab.
/proc/bus/usb/devicesThis file is handy for status viewing tools in user
mode, which can scan the text format and ignore most of it.
More detailed device status (including class and vendor
status) is available from device-specific files.
For information about the current format of this file,
see the
Documentation/usb/proc_usb_info.txt
file in your Linux kernel sources.
This file, in combination with the poll() system call, can
also be used to detect when devices are added or removed:
int fd;
struct pollfd pfd;

fd = open(&quot;/proc/bus/usb/devices&quot;, O_RDONLY);
pfd = { fd, POLLIN, 0 };
for (;;) {
/* The first time through, this call will return immediately. */
poll(&amp;amp;pfd, 1, -1);

/* To see what&#39;s changed, compare the file&#39;s previous and current
contents or scan the filesystem.  (Scanning is more precise.) */
}
Note that this behavior is intended to be used for informational
and debug purposes.  It would be more appropriate to use programs
such as udev or HAL to initialize a device or start a user-mode
helper program, for instance.
/proc/bus/usb/BBB/DDDUse these files in one of these basic ways:
They can be read,
producing first the device descriptor
(18 bytes) and then the descriptors for the current configuration.
See the USB 2.0 spec for details about those binary data formats.
You&#39;ll need to convert most multibyte values from little endian
format to your native host byte order, although a few of the
fields in the device descriptor (both of the BCD-encoded fields,
and the vendor and product IDs) will be byteswapped for you.
Note that configuration descriptors include descriptors for
interfaces, altsettings, endpoints, and maybe additional
class descriptors.
Perform USB operations using
ioctl() requests to make endpoint I/O
requests (synchronously or asynchronously) or manage
the device.
These requests need the CAP_SYS_RAWIO capability,
as well as filesystem access permissions.
Only one ioctl request can be made on one of these
device files at a time.
This means that if you are synchronously reading an endpoint
from one thread, you won&#39;t be able to write to a different
endpoint from another thread until the read completes.
This works for half duplex protocols,
but otherwise you&#39;d use asynchronous i/o requests.
Life Cycle of User Mode DriversSuch a driver first needs to find a device file
for a device it knows how to handle.
Maybe it was told about it because a
/sbin/hotplug event handling agent
chose that driver to handle the new device.
Or maybe it&#39;s an application that scans all the
/proc/bus/usb device files, and ignores most devices.
In either case, it should read() all
the descriptors from the device file,
and check them against what it knows how to handle.
It might just reject everything except a particular
vendor and product ID, or need a more complex policy.
Never assume there will only be one such device
on the system at a time!
If your code can&#39;t handle more than one device at
a time, at least detect when there&#39;s more than one, and
have your users choose which device to use.
Once your user mode driver knows what device to use,
it interacts with it in either of two styles.
The simple style is to make only control requests; some
devices don&#39;t need more complex interactions than those.
(An example might be software using vendor-specific control
requests for some initialization or configuration tasks,
with a kernel driver for the rest.)
More likely, you need a more complex style driver:
one using non-control endpoints, reading or writing data
and claiming exclusive use of an interface.
Bulk transfers are easiest to use,
but only their sibling interrupt transfers
work with low speed devices.
Both interrupt and isochronous transfers
offer service guarantees because their bandwidth is reserved.
Such &quot;periodic&quot; transfers are awkward to use through usbfs,
unless you&#39;re using the asynchronous calls.  However, interrupt
transfers can also be used in a synchronous &quot;one shot&quot; style.
Your user-mode driver should never need to worry
about cleaning up request state when the device is
disconnected, although it should close its open file
descriptors as soon as it starts seeing the ENODEV
errors.
The ioctl() RequestsTo use these ioctls, you need to include the following
headers in your userspace program:
#include &amp;lt;linux/usb.h&amp;gt;
#include &amp;lt;linux/usbdevice_fs.h&amp;gt;
#include &amp;lt;asm/byteorder.h&amp;gt;
The standard USB device model requests, from &quot;Chapter 9&quot; of
the USB 2.0 specification, are automatically included from
the &amp;lt;linux/usb/ch9.h&amp;gt; header.
Unless noted otherwise, the ioctl requests
described here will
update the modification time on the usbfs file to which
they are applied (unless they fail).
A return of zero indicates success; otherwise, a
standard USB error code is returned.  (These are
documented in
Documentation/usb/error-codes.txt
in your kernel sources.)
Each of these files multiplexes access to several
I/O streams, one per endpoint.
Each device has one control endpoint (endpoint zero)
which supports a limited RPC style RPC access.
Devices are configured
by khubd (in the kernel) setting a device-wide
configuration that affects things
like power consumption and basic functionality.
The endpoints are part of USB interfaces,
which may have altsettings
affecting things like which endpoints are available.
Many devices only have a single configuration and interface,
so drivers for them will ignore configurations and altsettings.
Management/Status RequestsA number of usbfs requests don&#39;t deal very directly
with device I/O.
They mostly relate to device management and status.
These are all synchronous requests.
USBDEVFS_CLAIMINTERFACEThis is used to force usbfs to
claim a specific interface,
which has not previously been claimed by usbfs or any other
kernel driver.
The ioctl parameter is an integer holding the number of
the interface (bInterfaceNumber from descriptor).

Note that if your driver doesn&#39;t claim an interface
before trying to use one of its endpoints, and no
other driver has bound to it, then the interface is
automatically claimed by usbfs.

This claim will be released by a RELEASEINTERFACE ioctl,
or by closing the file descriptor.
File modification time is not updated by this request.
USBDEVFS_CONNECTINFOSays whether the device is lowspeed.
The ioctl parameter points to a structure like this:
struct usbdevfs_connectinfo {
unsigned int   devnum;
unsigned char  slow;
};
File modification time is not updated by this request.
You can&#39;t tell whether a &quot;not slow&quot;
device is connected at high speed (480 MBit/sec)
or just full speed (12 MBit/sec).
You should know the devnum value already,
it&#39;s the DDD value of the device file name.
USBDEVFS_GETDRIVERReturns the name of the kernel driver
bound to a given interface (a string).  Parameter
is a pointer to this structure, which is modified:
struct usbdevfs_getdriver {
unsigned int  interface;
char          driver[USBDEVFS_MAXDRIVERNAME + 1];
};
File modification time is not updated by this request.
USBDEVFS_IOCTLPasses a request from userspace through
to a kernel driver that has an ioctl entry in the
struct usb_driver it registered.
struct usbdevfs_ioctl {
int     ifno;
int     ioctl_code;
void    *data;
};

/* user mode call looks like this.
* &#39;request&#39; becomes the driver-&amp;gt;ioctl() &#39;code&#39; parameter.
* the size of &#39;param&#39; is encoded in &#39;request&#39;, and that data
* is copied to or from the driver-&amp;gt;ioctl() &#39;buf&#39; parameter.
*/
static int
usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
{
struct usbdevfs_ioctl    wrapper;

wrapper.ifno = ifno;
wrapper.ioctl_code = request;
wrapper.data = param;

return ioctl (fd, USBDEVFS_IOCTL, &amp;amp;wrapper);
}
File modification time is not updated by this request.

This request lets kernel drivers talk to user mode code
through filesystem operations even when they don&#39;t create
a character or block special device.
It&#39;s also been used to do things like ask devices what
device special file should be used.
Two pre-defined ioctls are used
to disconnect and reconnect kernel drivers, so
that user mode code can completely manage binding
and configuration of devices.
USBDEVFS_RELEASEINTERFACEThis is used to release the claim usbfs
made on interface, either implicitly or because of a
USBDEVFS_CLAIMINTERFACE call, before the file
descriptor is closed.
The ioctl parameter is an integer holding the number of
the interface (bInterfaceNumber from descriptor);
File modification time is not updated by this request.
No security check is made to ensure
that the task which made the claim is the one
which is releasing it.
This means that user mode driver may interfere
other ones.  USBDEVFS_RESETEPResets the data toggle value for an endpoint
(bulk or interrupt) to DATA0.
The ioctl parameter is an integer endpoint number
(1 to 15, as identified in the endpoint descriptor),
with USB_DIR_IN added if the device&#39;s endpoint sends
data to the host.
Avoid using this request.
It should probably be removed.
Using it typically means the device and driver will lose
toggle synchronization.  If you really lost synchronization,
you likely need to completely handshake with the device,
using a request like CLEAR_HALT
or SET_INTERFACE.
Synchronous I/O SupportSynchronous requests involve the kernel blocking
until the user mode request completes, either by
finishing successfully or by reporting an error.
In most cases this is the simplest way to use usbfs,
although as noted above it does prevent performing I/O
to more than one endpoint at a time.
USBDEVFS_BULKIssues a bulk read or write request to the
device.
The ioctl parameter is a pointer to this structure:
struct usbdevfs_bulktransfer {
unsigned int  ep;
unsigned int  len;
unsigned int  timeout; /* in milliseconds */
void          *data;
};
The &quot;ep&quot; value identifies a
bulk endpoint number (1 to 15, as identified in an endpoint
descriptor),
masked with USB_DIR_IN when referring to an endpoint which
sends data to the host from the device.
The length of the data buffer is identified by &quot;len&quot;;
Recent kernels support requests up to about 128KBytes.
FIXME say how read length is returned,
and how short reads are handled..
USBDEVFS_CLEAR_HALTClears endpoint halt (stall) and
resets the endpoint toggle.  This is only
meaningful for bulk or interrupt endpoints.
The ioctl parameter is an integer endpoint number
(1 to 15, as identified in an endpoint descriptor),
masked with USB_DIR_IN when referring to an endpoint which
sends data to the host from the device.

Use this on bulk or interrupt endpoints which have
stalled, returning -EPIPE status
to a data transfer request.
Do not issue the control request directly, since
that could invalidate the host&#39;s record of the
data toggle.
USBDEVFS_CONTROLIssues a control request to the device.
The ioctl parameter points to a structure like this:
struct usbdevfs_ctrltransfer {
__u8   bRequestType;
__u8   bRequest;
__u16  wValue;
__u16  wIndex;
__u16  wLength;
__u32  timeout;  /* in milliseconds */
void   *data;
};

The first eight bytes of this structure are the contents
of the SETUP packet to be sent to the device; see the
USB 2.0 specification for details.
The bRequestType value is composed by combining a
USB_TYPE_* value, a USB_DIR_* value, and a
USB_RECIP_* value (from
&amp;lt;linux/usb.h&amp;gt;).
If wLength is nonzero, it describes the length of the data
buffer, which is either written to the device
(USB_DIR_OUT) or read from the device (USB_DIR_IN).

At this writing, you can&#39;t transfer more than 4 KBytes
of data to or from a device; usbfs has a limit, and
some host controller drivers have a limit.
(That&#39;s not usually a problem.)
Also there&#39;s no way to say it&#39;s
not OK to get a short read back from the device.
USBDEVFS_RESETDoes a USB level device reset.
The ioctl parameter is ignored.
After the reset, this rebinds all device interfaces.
File modification time is not updated by this request.
Avoid using this call
until some usbcore bugs get fixed,
since it does not fully synchronize device, interface,
and driver (not just usbfs) state.
USBDEVFS_SETINTERFACESets the alternate setting for an
interface.  The ioctl parameter is a pointer to a
structure like this:
struct usbdevfs_setinterface {
unsigned int  interface;
unsigned int  altsetting;
};
File modification time is not updated by this request.

Those struct members are from some interface descriptor
applying to the current configuration.
The interface number is the bInterfaceNumber value, and
the altsetting number is the bAlternateSetting value.
(This resets each endpoint in the interface.)
USBDEVFS_SETCONFIGURATIONIssues the
usb_set_configuration call
for the device.
The parameter is an integer holding the number of
a configuration (bConfigurationValue from descriptor).
File modification time is not updated by this request.
Avoid using this call
until some usbcore bugs get fixed,
since it does not fully synchronize device, interface,
and driver (not just usbfs) state.
Asynchronous I/O SupportAs mentioned above, there are situations where it may be
important to initiate concurrent operations from user mode code.
This is particularly important for periodic transfers
(interrupt and isochronous), but it can be used for other
kinds of USB requests too.
In such cases, the asynchronous requests described here
are essential.  Rather than submitting one request and having
the kernel block until it completes, the blocking is separate.
These requests are packaged into a structure that
resembles the URB used by kernel device drivers.
(No POSIX Async I/O support here, sorry.)
It identifies the endpoint type (USBDEVFS_URB_TYPE_*),
endpoint (number, masked with USB_DIR_IN as appropriate),
buffer and length, and a user &quot;context&quot; value serving to
uniquely identify each request.
(It&#39;s usually a pointer to per-request data.)
Flags can modify requests (not as many as supported for
kernel drivers).
Each request can specify a realtime signal number
(between SIGRTMIN and SIGRTMAX, inclusive) to request a
signal be sent when the request completes.
When usbfs returns these urbs, the status value
is updated, and the buffer may have been modified.
Except for isochronous transfers, the actual_length is
updated to say how many bytes were transferred; if the
USBDEVFS_URB_DISABLE_SPD flag is set
(&quot;short packets are not OK&quot;), if fewer bytes were read
than were requested then you get an error report.
struct usbdevfs_iso_packet_desc {
unsigned int                     length;
unsigned int                     actual_length;
unsigned int                     status;
};

struct usbdevfs_urb {
unsigned char                    type;
unsigned char                    endpoint;
int                              status;
unsigned int                     flags;
void                             *buffer;
int                              buffer_length;
int                              actual_length;
int                              start_frame;
int                              number_of_packets;
int                              error_count;
unsigned int                     signr;
void                             *usercontext;
struct usbdevfs_iso_packet_desc  iso_frame_desc[];
}; For these asynchronous requests, the file modification
time reflects when the request was initiated.
This contrasts with their use with the synchronous requests,
where it reflects when requests complete.
USBDEVFS_DISCARDURBTBS
File modification time is not updated by this request.

USBDEVFS_DISCSIGNALTBS
File modification time is not updated by this request.

USBDEVFS_REAPURBTBS
File modification time is not updated by this request.

USBDEVFS_REAPURBNDELAYTBS
File modification time is not updated by this request.

USBDEVFS_SUBMITURBTBS
&lt;!-- vim:syntax=sgml:sw=4
--&gt;&lt;!-- ****************************************************** --&gt;&lt;!-- Header  --&gt;&lt;!-- ****************************************************** --&gt;Writing an ALSA DriverTakashiIwaitiwai@suse.deOct 15, 20070.3.7
This document describes how to write an ALSA (Advanced Linux
Sound Architecture) driver.

Copyright (c) 2002-2005  Takashi Iwai tiwai@suse.de

This document is free; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA
&lt;!-- ****************************************************** --&gt;&lt;!-- Preface  --&gt;&lt;!-- ****************************************************** --&gt;Preface
This document describes how to write an

ALSA (Advanced Linux Sound Architecture)
driver. The document focuses mainly on PCI soundcards.
In the case of other device types, the API might
be different, too. However, at least the ALSA kernel API is
consistent, and therefore it would be still a bit help for
writing them.

This document targets people who already have enough
C language skills and have basic linux kernel programming
knowledge.  This document doesn&#39;t explain the general
topic of linux kernel coding and doesn&#39;t cover low-level
driver implementation details. It only describes
the standard way to write a PCI sound driver on ALSA.

If you are already familiar with the older ALSA ver.0.5.x API, you
can check the drivers such as sound/pci/es1938.c or
sound/pci/maestro3.c which have also almost the same
code-base in the ALSA 0.5.x tree, so you can compare the differences.

This document is still a draft version. Any feedback and
corrections, please!!
&lt;!-- ****************************************************** --&gt;&lt;!-- File Tree Structure  --&gt;&lt;!-- ****************************************************** --&gt;File Tree StructureGeneral
The ALSA drivers are provided in two ways.

One is the trees provided as a tarball or via cvs from the
ALSA&#39;s ftp site, and another is the 2.6 (or later) Linux kernel
tree. To synchronize both, the ALSA driver tree is split into
two different trees: alsa-kernel and alsa-driver. The former
contains purely the source code for the Linux 2.6 (or later)
tree. This tree is designed only for compilation on 2.6 or
later environment. The latter, alsa-driver, contains many subtle
files for compiling ALSA drivers outside of the Linux kernel tree,
wrapper functions for older 2.2 and 2.4 kernels, to adapt the latest kernel API,
and additional drivers which are still in development or in
tests.  The drivers in alsa-driver tree will be moved to
alsa-kernel (and eventually to the 2.6 kernel tree) when they are
finished and confirmed to work fine.

The file tree structure of ALSA driver is depicted below. Both
alsa-kernel and alsa-driver have almost the same file
structure, except for core directory. It&#39;s
named as acore in alsa-driver tree.

ALSA File Tree Structure
sound
/core
/oss
/seq
/oss
/instr
/ioctl32
/include
/drivers
/mpu401
/opl3
/i2c
/l3
/synth
/emux
/pci
/(cards)
/isa
/(cards)
/arm
/ppc
/sparc
/usb
/pcmcia /(cards)
/oss

core directory
This directory contains the middle layer which is the heart
of ALSA drivers. In this directory, the native ALSA modules are
stored. The sub-directories contain different modules and are
dependent upon the kernel config.
core/oss
The codes for PCM and mixer OSS emulation modules are stored
in this directory. The rawmidi OSS emulation is included in
the ALSA rawmidi code since it&#39;s quite small. The sequencer
code is stored in core/seq/oss directory (see

below).
core/ioctl32
This directory contains the 32bit-ioctl wrappers for 64bit
architectures such like x86-64, ppc64 and sparc64. For 32bit
and alpha architectures, these are not compiled.
core/seq
This directory and its sub-directories are for the ALSA
sequencer. This directory contains the sequencer core and
primary sequencer modules such like snd-seq-midi,
snd-seq-virmidi, etc. They are compiled only when
CONFIG_SND_SEQUENCER is set in the kernel
config.
core/seq/oss
This contains the OSS sequencer emulation codes.
core/seq/instr
This directory contains the modules for the sequencer
instrument layer.
include directory
This is the place for the public header files of ALSA drivers,
which are to be exported to user-space, or included by
several files at different directories. Basically, the private
header files should not be placed in this directory, but you may
still find files there, due to historical reasons :)
drivers directory
This directory contains code shared among different drivers
on different architectures.  They are hence supposed not to be
architecture-specific.
For example, the dummy pcm driver and the serial MIDI
driver are found in this directory. In the sub-directories,
there is code for components which are independent from
bus and cpu architectures.
drivers/mpu401
The MPU401 and MPU401-UART modules are stored here.
drivers/opl3 and opl4
The OPL3 and OPL4 FM-synth stuff is found here.
i2c directory
This contains the ALSA i2c components.

Although there is a standard i2c layer on Linux, ALSA has its
own i2c code for some cards, because the soundcard needs only a
simple operation and the standard i2c API is too complicated for
such a purpose.
i2c/l3
This is a sub-directory for ARM L3 i2c.
synth directory
This contains the synth middle-level modules.

So far, there is only Emu8000/Emu10k1 synth driver under
the synth/emux sub-directory.
pci directory
This directory and its sub-directories hold the top-level card modules
for PCI soundcards and the code specific to the PCI BUS.

The drivers compiled from a single file are stored directly
in the pci directory, while the drivers with several source files are
stored on their own sub-directory (e.g. emu10k1, ice1712).
isa directory
This directory and its sub-directories hold the top-level card modules
for ISA soundcards.
arm, ppc, and sparc directories
They are used for top-level card modules which are
specific to one of these architectures.
usb directory
This directory contains the USB-audio driver. In the latest version, the
USB MIDI driver is integrated in the usb-audio driver.
pcmcia directory
The PCMCIA, especially PCCard drivers will go here. CardBus
drivers will be in the pci directory, because their API is identical
to that of standard PCI cards.
oss directory
The OSS/Lite source files are stored here in Linux 2.6 (or
later) tree. In the ALSA driver tarball, this directory is empty,
of course :)
&lt;!-- ****************************************************** --&gt;&lt;!-- Basic Flow for PCI Drivers  --&gt;&lt;!-- ****************************************************** --&gt;Basic Flow for PCI DriversOutline
The minimum flow for PCI soundcards is as follows:

define the PCI ID table (see the section
PCI Entries
).create probe() callback.create remove() callback.create a pci_driver structure
containing the three pointers above.create an init() function just calling
the pci_register_driver() to register the pci_driver table
defined above.create an exit() function to call
the pci_unregister_driver() function.
Full Code Example
The code example is shown below. Some parts are kept
unimplemented at this moment but will be filled in the
next sections. The numbers in the comment lines of the
snd_mychip_probe() function
refer to details explained in the following section.

Basic Flow for PCI Drivers - Example
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/pci.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;sound/core.h&amp;gt;
#include &amp;lt;sound/initval.h&amp;gt;

/* module parameters (see &quot;Module Parameters&quot;) */
/* SNDRV_CARDS: maximum number of cards supported by this module */
static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;

/* definition of the chip-specific record */
struct mychip {
struct snd_card *card;
/* the rest of the implementation will be in section
* &quot;PCI Resource Management&quot;
*/
};

/* chip-specific destructor
* (see &quot;PCI Resource Management&quot;)
*/
static int snd_mychip_free(struct mychip *chip)
{
.... /* will be implemented later... */
}

/* component-destructor
* (see &quot;Management of Cards and Components&quot;)
*/
static int snd_mychip_dev_free(struct snd_device *device)
{
return snd_mychip_free(device-&amp;gt;device_data);
}

/* chip-specific constructor
* (see &quot;Management of Cards and Components&quot;)
*/
static int snd_mychip_create(struct snd_card *card,
struct pci_dev *pci,
struct mychip **rchip)
{
struct mychip *chip;
int err;
static struct snd_device_ops ops = {
.dev_free = snd_mychip_dev_free,
};

*rchip = NULL;

/* check PCI availability here
* (see &quot;PCI Resource Management&quot;)
*/
....

/* allocate a chip-specific data with zero filled */
chip = kzalloc(sizeof(*chip), GFP_KERNEL);
if (chip == NULL)
return -ENOMEM;

chip-&amp;gt;card = card;

/* rest of initialization here; will be implemented
* later, see &quot;PCI Resource Management&quot;
*/
....

err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;amp;ops);
if (err &amp;lt; 0) {
snd_mychip_free(chip);
return err;
}

snd_card_set_dev(card, &amp;amp;pci-&amp;gt;dev);

*rchip = chip;
return 0;
}

/* constructor -- see &quot;Constructor&quot; sub-section */
static int snd_mychip_probe(struct pci_dev *pci,
const struct pci_device_id *pci_id)
{
static int dev;
struct snd_card *card;
struct mychip *chip;
int err;

/* (1) */
if (dev &amp;gt;= SNDRV_CARDS)
return -ENODEV;
if (!enable[dev]) {
dev++;
return -ENOENT;
}

/* (2) */
err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;amp;card);
if (err &amp;lt; 0)
return err;

/* (3) */
err = snd_mychip_create(card, pci, &amp;amp;chip);
if (err &amp;lt; 0) {
snd_card_free(card);
return err;
}

/* (4) */
strcpy(card-&amp;gt;driver, &quot;My Chip&quot;);
strcpy(card-&amp;gt;shortname, &quot;My Own Chip 123&quot;);
sprintf(card-&amp;gt;longname, &quot;%s at 0x%lx irq %i&quot;,
card-&amp;gt;shortname, chip-&amp;gt;ioport, chip-&amp;gt;irq);

/* (5) */
.... /* implemented later */

/* (6) */
err = snd_card_register(card);
if (err &amp;lt; 0) {
snd_card_free(card);
return err;
}

/* (7) */
pci_set_drvdata(pci, card);
dev++;
return 0;
}

/* destructor -- see the &quot;Destructor&quot; sub-section */
static void snd_mychip_remove(struct pci_dev *pci)
{
snd_card_free(pci_get_drvdata(pci));
pci_set_drvdata(pci, NULL);
}


Constructor
The real constructor of PCI drivers is the probe callback.
The probe callback and other component-constructors which are called
from the probe callback cannot be used with
the __init prefix
because any PCI device could be a hotplug device.

In the probe callback, the following scheme is often used.
1) Check and increment the device index.
static int dev;
....
if (dev &amp;gt;= SNDRV_CARDS)
return -ENODEV;
if (!enable[dev]) {
dev++;
return -ENOENT;
}



where enable[dev] is the module option.

Each time the probe callback is called, check the
availability of the device. If not available, simply increment
the device index and returns. dev will be incremented also
later (step
7).
2) Create a card instance
struct snd_card *card;
int err;
....
err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;amp;card);


The details will be explained in the section

Management of Cards and Components.
3) Create a main component
In this part, the PCI resources are allocated.


struct mychip *chip;
....
err = snd_mychip_create(card, pci, &amp;amp;chip);
if (err &amp;lt; 0) {
snd_card_free(card);
return err;
}



The details will be explained in the section PCI Resource
Management.
4) Set the driver ID and name strings.
strcpy(card-&amp;gt;driver, &quot;My Chip&quot;);
strcpy(card-&amp;gt;shortname, &quot;My Own Chip 123&quot;);
sprintf(card-&amp;gt;longname, &quot;%s at 0x%lx irq %i&quot;,
card-&amp;gt;shortname, chip-&amp;gt;ioport, chip-&amp;gt;irq);



The driver field holds the minimal ID string of the
chip. This is used by alsa-lib&#39;s configurator, so keep it
simple but unique.
Even the same driver can have different driver IDs to
distinguish the functionality of each chip type.

The shortname field is a string shown as more verbose
name. The longname field contains the information
shown in /proc/asound/cards.
5) Create other components, such as mixer, MIDI, etc.
Here you define the basic components such as
PCM,
mixer (e.g. AC97),
MIDI (e.g. MPU-401),
and other interfaces.
Also, if you want a proc
file, define it here, too.
6) Register the card instance.
err = snd_card_register(card);
if (err &amp;lt; 0) {
snd_card_free(card);
return err;
}


Will be explained in the section Management
of Cards and Components, too.
7) Set the PCI driver data and return zero.
pci_set_drvdata(pci, card);
dev++;
return 0;



In the above, the card record is stored. This pointer is
used in the remove callback and power-management
callbacks, too.
Destructor
The destructor, remove callback, simply releases the card
instance. Then the ALSA middle layer will release all the
attached components automatically.

It would be typically like the following:


static void snd_mychip_remove(struct pci_dev *pci)
{
snd_card_free(pci_get_drvdata(pci));
pci_set_drvdata(pci, NULL);
}



The above code assumes that the card pointer is set to the PCI
driver data.
Header Files
For the above example, at least the following include files
are necessary.


#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/pci.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;sound/core.h&amp;gt;
#include &amp;lt;sound/initval.h&amp;gt;



where the last one is necessary only when module options are
defined in the source file.  If the code is split into several
files, the files without module options don&#39;t need them.

In addition to these headers, you&#39;ll need
&amp;lt;linux/interrupt.h&amp;gt; for interrupt
handling, and &amp;lt;asm/io.h&amp;gt; for I/O
access. If you use the mdelay() or
udelay() functions, you&#39;ll need to include
&amp;lt;linux/delay.h&amp;gt; too.

The ALSA interfaces like the PCM and control APIs are defined in other
&amp;lt;sound/xxx.h&amp;gt; header files.
They have to be included after
&amp;lt;sound/core.h&amp;gt;.
&lt;!-- ****************************************************** --&gt;&lt;!-- Management of Cards and Components  --&gt;&lt;!-- ****************************************************** --&gt;Management of Cards and ComponentsCard Instance
For each soundcard, a card record must be allocated.

A card record is the headquarters of the soundcard.  It manages
the whole list of devices (components) on the soundcard, such as
PCM, mixers, MIDI, synthesizer, and so on.  Also, the card
record holds the ID and the name strings of the card, manages
the root of proc files, and controls the power-management states
and hotplug disconnections.  The component list on the card
record is used to manage the correct release of resources at
destruction.

As mentioned above, to create a card instance, call
snd_card_create().


struct snd_card *card;
int err;
err = snd_card_create(index, id, module, extra_size, &amp;amp;card);



The function takes five arguments, the card-index number, the
id string, the module pointer (usually
THIS_MODULE),
the size of extra-data space, and the pointer to return the
card instance.  The extra_size argument is used to
allocate card-&amp;gt;private_data for the
chip-specific data.  Note that these data
are allocated by snd_card_create().
Components
After the card is created, you can attach the components
(devices) to the card instance. In an ALSA driver, a component is
represented as a struct snd_device object.
A component can be a PCM instance, a control interface, a raw
MIDI interface, etc.  Each such instance has one component
entry.

A component can be created via
snd_device_new() function.


snd_device_new(card, SNDRV_DEV_XXX, chip, &amp;amp;ops);



This takes the card pointer, the device-level
(SNDRV_DEV_XXX), the data pointer, and the
callback pointers (&amp;amp;ops). The
device-level defines the type of components and the order of
registration and de-registration.  For most components, the
device-level is already defined.  For a user-defined component,
you can use SNDRV_DEV_LOWLEVEL.

This function itself doesn&#39;t allocate the data space. The data
must be allocated manually beforehand, and its pointer is passed
as the argument. This pointer (chip in the
above example) is used as the identifier for the instance.

Each pre-defined ALSA component such as ac97 and pcm calls
snd_device_new() inside its
constructor. The destructor for each component is defined in the
callback pointers.  Hence, you don&#39;t need to take care of
calling a destructor for such a component.

If you wish to create your own component, you need to
set the destructor function to the dev_free callback in
the ops, so that it can be released
automatically via snd_card_free().
The next example will show an implementation of chip-specific
data.
Chip-Specific Data
Chip-specific information, e.g. the I/O port address, its
resource pointer, or the irq number, is stored in the
chip-specific record.


struct mychip {
....
};



In general, there are two ways of allocating the chip record.
1. Allocating via snd_card_create().
As mentioned above, you can pass the extra-data-length
to the 4th argument of snd_card_create(), i.e.


err = snd_card_create(index[dev], id[dev], THIS_MODULE,
sizeof(struct mychip), &amp;amp;card);



struct mychip is the type of the chip record.

In return, the allocated record can be accessed as


struct mychip *chip = card-&amp;gt;private_data;



With this method, you don&#39;t have to allocate twice.
The record is released together with the card instance.
2. Allocating an extra device.
After allocating a card instance via
snd_card_create() (with
0 on the 4th arg), call
kzalloc().


struct snd_card *card;
struct mychip *chip;
err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;amp;card);
.....
chip = kzalloc(sizeof(*chip), GFP_KERNEL);



The chip record should have the field to hold the card
pointer at least,


struct mychip {
struct snd_card *card;
....
};



Then, set the card pointer in the returned chip instance.


chip-&amp;gt;card = card;



Next, initialize the fields, and register this chip
record as a low-level device with a specified
ops,


static struct snd_device_ops ops = {
.dev_free =        snd_mychip_dev_free,
};
....
snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;amp;ops);



snd_mychip_dev_free() is the
device-destructor function, which will call the real
destructor.

static int snd_mychip_dev_free(struct snd_device *device)
{
return snd_mychip_free(device-&amp;gt;device_data);
}



where snd_mychip_free() is the real destructor.
Registration and Release
After all components are assigned, register the card instance
by calling snd_card_register(). Access
to the device files is enabled at this point. That is, before
snd_card_register() is called, the
components are safely inaccessible from external side. If this
call fails, exit the probe function after releasing the card via
snd_card_free().

For releasing the card instance, you can call simply
snd_card_free(). As mentioned earlier, all
components are released automatically by this call.

For a device which allows hotplugging, you can use
snd_card_free_when_closed.  This one will
postpone the destruction until all devices are closed.
&lt;!-- ****************************************************** --&gt;&lt;!-- PCI Resource Management  --&gt;&lt;!-- ****************************************************** --&gt;PCI Resource ManagementFull Code Example
In this section, we&#39;ll complete the chip-specific constructor,
destructor and PCI entries. Example code is shown first,
below.

PCI Resource Management Example
struct mychip {
struct snd_card *card;
struct pci_dev *pci;

unsigned long port;
int irq;
};

static int snd_mychip_free(struct mychip *chip)
{
/* disable hardware here if any */
.... /* (not implemented in this document) */

/* release the irq */
if (chip-&amp;gt;irq &amp;gt;= 0)
free_irq(chip-&amp;gt;irq, chip);
/* release the I/O ports &amp;amp; memory */
pci_release_regions(chip-&amp;gt;pci);
/* disable the PCI entry */
pci_disable_device(chip-&amp;gt;pci);
/* release the data */
kfree(chip);
return 0;
}

/* chip-specific constructor */
static int snd_mychip_create(struct snd_card *card,
struct pci_dev *pci,
struct mychip **rchip)
{
struct mychip *chip;
int err;
static struct snd_device_ops ops = {
.dev_free = snd_mychip_dev_free,
};

*rchip = NULL;

/* initialize the PCI entry */
err = pci_enable_device(pci);
if (err &amp;lt; 0)
return err;
/* check PCI availability (28bit DMA) */
if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &amp;lt; 0 ||
pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &amp;lt; 0) {
printk(KERN_ERR &quot;error to set 28bit mask DMA\n&quot;);
pci_disable_device(pci);
return -ENXIO;
}

chip = kzalloc(sizeof(*chip), GFP_KERNEL);
if (chip == NULL) {
pci_disable_device(pci);
return -ENOMEM;
}

/* initialize the stuff */
chip-&amp;gt;card = card;
chip-&amp;gt;pci = pci;
chip-&amp;gt;irq = -1;

/* (1) PCI resource allocation */
err = pci_request_regions(pci, &quot;My Chip&quot;);
if (err &amp;lt; 0) {
kfree(chip);
pci_disable_device(pci);
return err;
}
chip-&amp;gt;port = pci_resource_start(pci, 0);
if (request_irq(pci-&amp;gt;irq, snd_mychip_interrupt,
IRQF_SHARED, KBUILD_MODNAME, chip)) {
printk(KERN_ERR &quot;cannot grab irq %d\n&quot;, pci-&amp;gt;irq);
snd_mychip_free(chip);
return -EBUSY;
}
chip-&amp;gt;irq = pci-&amp;gt;irq;

/* (2) initialization of the chip hardware */
.... /*   (not implemented in this document) */

err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;amp;ops);
if (err &amp;lt; 0) {
snd_mychip_free(chip);
return err;
}

snd_card_set_dev(card, &amp;amp;pci-&amp;gt;dev);

*rchip = chip;
return 0;
}

/* PCI IDs */
static struct pci_device_id snd_mychip_ids[] = {
{ PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
....
{ 0, }
};
MODULE_DEVICE_TABLE(pci, snd_mychip_ids);

/* pci_driver definition */
static struct pci_driver driver = {
.name = KBUILD_MODNAME,
.id_table = snd_mychip_ids,
.probe = snd_mychip_probe,
.remove = snd_mychip_remove,
};

/* module initialization */
static int __init alsa_card_mychip_init(void)
{
return pci_register_driver(&amp;amp;driver);
}

/* module clean up */
static void __exit alsa_card_mychip_exit(void)
{
pci_unregister_driver(&amp;amp;driver);
}

module_init(alsa_card_mychip_init)
module_exit(alsa_card_mychip_exit)

EXPORT_NO_SYMBOLS; /* for old kernels only */


Some Hafta&#39;s
The allocation of PCI resources is done in the
probe() function, and usually an extra
xxx_create() function is written for this
purpose.

In the case of PCI devices, you first have to call
the pci_enable_device() function before
allocating resources. Also, you need to set the proper PCI DMA
mask to limit the accessed I/O range. In some cases, you might
need to call pci_set_master() function,
too.

Suppose the 28bit mask, and the code to be added would be like:


err = pci_enable_device(pci);
if (err &amp;lt; 0)
return err;
if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &amp;lt; 0 ||
pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &amp;lt; 0) {
printk(KERN_ERR &quot;error to set 28bit mask DMA\n&quot;);
pci_disable_device(pci);
return -ENXIO;
}



Resource Allocation
The allocation of I/O ports and irqs is done via standard kernel
functions. Unlike ALSA ver.0.5.x., there are no helpers for
that. And these resources must be released in the destructor
function (see below). Also, on ALSA 0.9.x, you don&#39;t need to
allocate (pseudo-)DMA for PCI like in ALSA 0.5.x.

Now assume that the PCI device has an I/O port with 8 bytes
and an interrupt. Then struct mychip will have the
following fields:


struct mychip {
struct snd_card *card;

unsigned long port;
int irq;
};



For an I/O port (and also a memory region), you need to have
the resource pointer for the standard resource management. For
an irq, you have to keep only the irq number (integer). But you
need to initialize this number as -1 before actual allocation,
since irq 0 is valid. The port address and its resource pointer
can be initialized as null by
kzalloc() automatically, so you
don&#39;t have to take care of resetting them.

The allocation of an I/O port is done like this:


err = pci_request_regions(pci, &quot;My Chip&quot;);
if (err &amp;lt; 0) {
kfree(chip);
pci_disable_device(pci);
return err;
}
chip-&amp;gt;port = pci_resource_start(pci, 0);


&lt;!-- obsolete --&gt;
It will reserve the I/O port region of 8 bytes of the given
PCI device. The returned value, chip-&amp;gt;res_port, is allocated
via kmalloc() by
request_region(). The pointer must be
released via kfree(), but there is a
problem with this. This issue will be explained later.

The allocation of an interrupt source is done like this:


if (request_irq(pci-&amp;gt;irq, snd_mychip_interrupt,
IRQF_SHARED, KBUILD_MODNAME, chip)) {
printk(KERN_ERR &quot;cannot grab irq %d\n&quot;, pci-&amp;gt;irq);
snd_mychip_free(chip);
return -EBUSY;
}
chip-&amp;gt;irq = pci-&amp;gt;irq;



where snd_mychip_interrupt() is the
interrupt handler defined later.
Note that chip-&amp;gt;irq should be defined
only when request_irq() succeeded.

On the PCI bus, interrupts can be shared. Thus,
IRQF_SHARED is used as the interrupt flag of
request_irq().

The last argument of request_irq() is the
data pointer passed to the interrupt handler. Usually, the
chip-specific record is used for that, but you can use what you
like, too.

I won&#39;t give details about the interrupt handler at this
point, but at least its appearance can be explained now. The
interrupt handler looks usually like the following:


static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
struct mychip *chip = dev_id;
....
return IRQ_HANDLED;
}



Now let&#39;s write the corresponding destructor for the resources
above. The role of destructor is simple: disable the hardware
(if already activated) and release the resources. So far, we
have no hardware part, so the disabling code is not written here.

To release the resources, the check-and-release
method is a safer way. For the interrupt, do like this:


if (chip-&amp;gt;irq &amp;gt;= 0)
free_irq(chip-&amp;gt;irq, chip);



Since the irq number can start from 0, you should initialize
chip-&amp;gt;irq with a negative value (e.g. -1), so that you can
check the validity of the irq number as above.

When you requested I/O ports or memory regions via
pci_request_region() or
pci_request_regions() like in this example,
release the resource(s) using the corresponding function,
pci_release_region() or
pci_release_regions().


pci_release_regions(chip-&amp;gt;pci);



When you requested manually via request_region()
or request_mem_region, you can release it via
release_resource().  Suppose that you keep
the resource pointer returned from request_region()
in chip-&amp;gt;res_port, the release procedure looks like:


release_and_free_resource(chip-&amp;gt;res_port);



Don&#39;t forget to call pci_disable_device()
before the end.

And finally, release the chip-specific record.


kfree(chip);



We didn&#39;t implement the hardware disabling part in the above.
If you need to do this, please note that the destructor may be
called even before the initialization of the chip is completed.
It would be better to have a flag to skip hardware disabling
if the hardware was not initialized yet.

When the chip-data is assigned to the card using
snd_device_new() with
SNDRV_DEV_LOWLELVEL , its destructor is
called at the last.  That is, it is assured that all other
components like PCMs and controls have already been released.
You don&#39;t have to stop PCMs, etc. explicitly, but just
call low-level hardware stopping.

The management of a memory-mapped region is almost as same as
the management of an I/O port. You&#39;ll need three fields like
the following:


struct mychip {
....
unsigned long iobase_phys;
void __iomem *iobase_virt;
};



and the allocation would be like below:


if ((err = pci_request_regions(pci, &quot;My Chip&quot;)) &amp;lt; 0) {
kfree(chip);
return err;
}
chip-&amp;gt;iobase_phys = pci_resource_start(pci, 0);
chip-&amp;gt;iobase_virt = ioremap_nocache(chip-&amp;gt;iobase_phys,
pci_resource_len(pci, 0));



and the corresponding destructor would be:


static int snd_mychip_free(struct mychip *chip)
{
....
if (chip-&amp;gt;iobase_virt)
iounmap(chip-&amp;gt;iobase_virt);
....
pci_release_regions(chip-&amp;gt;pci);
....
}


Registration of Device Struct
At some point, typically after calling snd_device_new(),
you need to register the struct device of the chip
you&#39;re handling for udev and co.  ALSA provides a macro for compatibility with
older kernels.  Simply call like the following:

snd_card_set_dev(card, &amp;amp;pci-&amp;gt;dev);


so that it stores the PCI&#39;s device pointer to the card.  This will be
referred by ALSA core functions later when the devices are registered.

In the case of non-PCI, pass the proper device struct pointer of the BUS
instead.  (In the case of legacy ISA without PnP, you don&#39;t have to do
anything.)
PCI Entries
So far, so good. Let&#39;s finish the missing PCI
stuff. At first, we need a
pci_device_id table for this
chipset. It&#39;s a table of PCI vendor/device ID number, and some
masks.

For example,


static struct pci_device_id snd_mychip_ids[] = {
{ PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
....
{ 0, }
};
MODULE_DEVICE_TABLE(pci, snd_mychip_ids);



The first and second fields of
the pci_device_id structure are the vendor and
device IDs. If you have no reason to filter the matching
devices, you can leave the remaining fields as above. The last
field of the pci_device_id struct contains
private data for this entry. You can specify any value here, for
example, to define specific operations for supported device IDs.
Such an example is found in the intel8x0 driver.

The last entry of this list is the terminator. You must
specify this all-zero entry.

Then, prepare the pci_driver record:


static struct pci_driver driver = {
.name = KBUILD_MODNAME,
.id_table = snd_mychip_ids,
.probe = snd_mychip_probe,
.remove = snd_mychip_remove,
};



The probe and
remove functions have already
been defined in the previous sections.
The name
field is the name string of this device. Note that you must not
use a slash / in this string.

And at last, the module entries:


static int __init alsa_card_mychip_init(void)
{
return pci_register_driver(&amp;amp;driver);
}

static void __exit alsa_card_mychip_exit(void)
{
pci_unregister_driver(&amp;amp;driver);
}

module_init(alsa_card_mychip_init)
module_exit(alsa_card_mychip_exit)



Note that these module entries are tagged with
__init and
__exit prefixes.

Oh, one thing was forgotten. If you have no exported symbols,
you need to declare it in 2.2 or 2.4 kernels (it&#39;s not necessary in 2.6 kernels).


EXPORT_NO_SYMBOLS;



That&#39;s all!
&lt;!-- ****************************************************** --&gt;&lt;!-- PCM Interface  --&gt;&lt;!-- ****************************************************** --&gt;PCM InterfaceGeneral
The PCM middle layer of ALSA is quite powerful and it is only
necessary for each driver to implement the low-level functions
to access its hardware.

For accessing to the PCM layer, you need to include
&amp;lt;sound/pcm.h&amp;gt; first. In addition,
&amp;lt;sound/pcm_params.h&amp;gt; might be needed
if you access to some functions related with hw_param.

Each card device can have up to four pcm instances. A pcm
instance corresponds to a pcm device file. The limitation of
number of instances comes only from the available bit size of
the Linux&#39;s device numbers. Once when 64bit device number is
used, we&#39;ll have more pcm instances available.

A pcm instance consists of pcm playback and capture streams,
and each pcm stream consists of one or more pcm substreams. Some
soundcards support multiple playback functions. For example,
emu10k1 has a PCM playback of 32 stereo substreams. In this case, at
each open, a free substream is (usually) automatically chosen
and opened. Meanwhile, when only one substream exists and it was
already opened, the successful open will either block
or error with EAGAIN according to the
file open mode. But you don&#39;t have to care about such details in your
driver. The PCM middle layer will take care of such work.
Full Code Example
The example code below does not include any hardware access
routines but shows only the skeleton, how to build up the PCM
interfaces.

PCM Example Code
#include &amp;lt;sound/pcm.h&amp;gt;
....

/* hardware definition */
static struct snd_pcm_hardware snd_mychip_playback_hw = {
.info = (SNDRV_PCM_INFO_MMAP |
SNDRV_PCM_INFO_INTERLEAVED |
SNDRV_PCM_INFO_BLOCK_TRANSFER |
SNDRV_PCM_INFO_MMAP_VALID),
.formats =          SNDRV_PCM_FMTBIT_S16_LE,
.rates =            SNDRV_PCM_RATE_8000_48000,
.rate_min =         8000,
.rate_max =         48000,
.channels_min =     2,
.channels_max =     2,
.buffer_bytes_max = 32768,
.period_bytes_min = 4096,
.period_bytes_max = 32768,
.periods_min =      1,
.periods_max =      1024,
};

/* hardware definition */
static struct snd_pcm_hardware snd_mychip_capture_hw = {
.info = (SNDRV_PCM_INFO_MMAP |
SNDRV_PCM_INFO_INTERLEAVED |
SNDRV_PCM_INFO_BLOCK_TRANSFER |
SNDRV_PCM_INFO_MMAP_VALID),
.formats =          SNDRV_PCM_FMTBIT_S16_LE,
.rates =            SNDRV_PCM_RATE_8000_48000,
.rate_min =         8000,
.rate_max =         48000,
.channels_min =     2,
.channels_max =     2,
.buffer_bytes_max = 32768,
.period_bytes_min = 4096,
.period_bytes_max = 32768,
.periods_min =      1,
.periods_max =      1024,
};

/* open callback */
static int snd_mychip_playback_open(struct snd_pcm_substream *substream)
{
struct mychip *chip = snd_pcm_substream_chip(substream);
struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime;

runtime-&amp;gt;hw = snd_mychip_playback_hw;
/* more hardware-initialization will be done here */
....
return 0;
}

/* close callback */
static int snd_mychip_playback_close(struct snd_pcm_substream *substream)
{
struct mychip *chip = snd_pcm_substream_chip(substream);
/* the hardware-specific codes will be here */
....
return 0;

}

/* open callback */
static int snd_mychip_capture_open(struct snd_pcm_substream *substream)
{
struct mychip *chip = snd_pcm_substream_chip(substream);
struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime;

runtime-&amp;gt;hw = snd_mychip_capture_hw;
/* more hardware-initialization will be done here */
....
return 0;
}

/* close callback */
static int snd_mychip_capture_close(struct snd_pcm_substream *substream)
{
struct mychip *chip = snd_pcm_substream_chip(substream);
/* the hardware-specific codes will be here */
....
return 0;

}

/* hw_params callback */
static int snd_mychip_pcm_hw_params(struct snd_pcm_substream *substream,
struct snd_pcm_hw_params *hw_params)
{
return snd_pcm_lib_malloc_pages(substream,
params_buffer_bytes(hw_params));
}

/* hw_free callback */
static int snd_mychip_pcm_hw_free(struct snd_pcm_substream *substream)
{
return snd_pcm_lib_free_pages(substream);
}

/* prepare callback */
static int snd_mychip_pcm_prepare(struct snd_pcm_substream *substream)
{
struct mychip *chip = snd_pcm_substream_chip(substream);
struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime;

/* set up the hardware with the current configuration
* for example...
*/
mychip_set_sample_format(chip, runtime-&amp;gt;format);
mychip_set_sample_rate(chip, runtime-&amp;gt;rate);
mychip_set_channels(chip, runtime-&amp;gt;channels);
mychip_set_dma_setup(chip, runtime-&amp;gt;dma_addr,
chip-&amp;gt;buffer_size,
chip-&amp;gt;period_size);
return 0;
}

/* trigger callback */
static int snd_mychip_pcm_trigger(struct snd_pcm_substream *substream,
int cmd)
{
switch (cmd) {
case SNDRV_PCM_TRIGGER_START:
/* do something to start the PCM engine */
....
break;
case SNDRV_PCM_TRIGGER_STOP:
/* do something to stop the PCM engine */
....
break;
default:
return -EINVAL;
}
}

/* pointer callback */
static snd_pcm_uframes_t
snd_mychip_pcm_pointer(struct snd_pcm_substream *substream)
{
struct mychip *chip = snd_pcm_substream_chip(substream);
unsigned int current_ptr;

/* get the current hardware pointer */
current_ptr = mychip_get_hw_pointer(chip);
return current_ptr;
}

/* operators */
static struct snd_pcm_ops snd_mychip_playback_ops = {
.open =        snd_mychip_playback_open,
.close =       snd_mychip_playback_close,
.ioctl =       snd_pcm_lib_ioctl,
.hw_params =   snd_mychip_pcm_hw_params,
.hw_free =     snd_mychip_pcm_hw_free,
.prepare =     snd_mychip_pcm_prepare,
.trigger =     snd_mychip_pcm_trigger,
.pointer =     snd_mychip_pcm_pointer,
};

/* operators */
static struct snd_pcm_ops snd_mychip_capture_ops = {
.open =        snd_mychip_capture_open,
.close =       snd_mychip_capture_close,
.ioctl =       snd_pcm_lib_ioctl,
.hw_params =   snd_mychip_pcm_hw_params,
.hw_free =     snd_mychip_pcm_hw_free,
.prepare =     snd_mychip_pcm_prepare,
.trigger =     snd_mychip_pcm_trigger,
.pointer =     snd_mychip_pcm_pointer,
};

/*
*  definitions of capture are omitted here...
*/

/* create a pcm device */
static int snd_mychip_new_pcm(struct mychip *chip)
{
struct snd_pcm *pcm;
int err;

err = snd_pcm_new(chip-&amp;gt;card, &quot;My Chip&quot;, 0, 1, 1, &amp;amp;pcm);
if (err &amp;lt; 0)
return err;
pcm-&amp;gt;private_data = chip;
strcpy(pcm-&amp;gt;name, &quot;My Chip&quot;);
chip-&amp;gt;pcm = pcm;
/* set operators */
snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
&amp;amp;snd_mychip_playback_ops);
snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
&amp;amp;snd_mychip_capture_ops);
/* pre-allocation of buffers */
/* NOTE: this may fail */
snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
snd_dma_pci_data(chip-&amp;gt;pci),
64*1024, 64*1024);
return 0;
}


Constructor
A pcm instance is allocated by the snd_pcm_new()
function. It would be better to create a constructor for pcm,
namely,


static int snd_mychip_new_pcm(struct mychip *chip)
{
struct snd_pcm *pcm;
int err;

err = snd_pcm_new(chip-&amp;gt;card, &quot;My Chip&quot;, 0, 1, 1, &amp;amp;pcm);
if (err &amp;lt; 0)
return err;
pcm-&amp;gt;private_data = chip;
strcpy(pcm-&amp;gt;name, &quot;My Chip&quot;);
chip-&amp;gt;pcm = pcm;
....
return 0;
}



The snd_pcm_new() function takes four
arguments. The first argument is the card pointer to which this
pcm is assigned, and the second is the ID string.

The third argument (index, 0 in the
above) is the index of this new pcm. It begins from zero. If
you create more than one pcm instances, specify the
different numbers in this argument. For example,
index = 1 for the second PCM device.

The fourth and fifth arguments are the number of substreams
for playback and capture, respectively. Here 1 is used for
both arguments. When no playback or capture substreams are available,
pass 0 to the corresponding argument.

If a chip supports multiple playbacks or captures, you can
specify more numbers, but they must be handled properly in
open/close, etc. callbacks.  When you need to know which
substream you are referring to, then it can be obtained from
struct snd_pcm_substream data passed to each callback
as follows:


struct snd_pcm_substream *substream;
int index = substream-&amp;gt;number;



After the pcm is created, you need to set operators for each
pcm stream.


snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
&amp;amp;snd_mychip_playback_ops);
snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
&amp;amp;snd_mychip_capture_ops);



The operators are defined typically like this:


static struct snd_pcm_ops snd_mychip_playback_ops = {
.open =        snd_mychip_pcm_open,
.close =       snd_mychip_pcm_close,
.ioctl =       snd_pcm_lib_ioctl,
.hw_params =   snd_mychip_pcm_hw_params,
.hw_free =     snd_mychip_pcm_hw_free,
.prepare =     snd_mychip_pcm_prepare,
.trigger =     snd_mychip_pcm_trigger,
.pointer =     snd_mychip_pcm_pointer,
};



All the callbacks are described in the

Operators subsection.

After setting the operators, you probably will want to
pre-allocate the buffer. For the pre-allocation, simply call
the following:


snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
snd_dma_pci_data(chip-&amp;gt;pci),
64*1024, 64*1024);



It will allocate a buffer up to 64kB as default.
Buffer management details will be described in the later section Buffer and Memory
Management.

Additionally, you can set some extra information for this pcm
in pcm-&amp;gt;info_flags.
The available values are defined as
SNDRV_PCM_INFO_XXX in
&amp;lt;sound/asound.h&amp;gt;, which is used for
the hardware definition (described later). When your soundchip
supports only half-duplex, specify like this:


pcm-&amp;gt;info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;


... And the Destructor?
The destructor for a pcm instance is not always
necessary. Since the pcm device will be released by the middle
layer code automatically, you don&#39;t have to call the destructor
explicitly.

The destructor would be necessary if you created
special records internally and needed to release them. In such a
case, set the destructor function to
pcm-&amp;gt;private_free:

PCM Instance with a Destructor
static void mychip_pcm_free(struct snd_pcm *pcm)
{
struct mychip *chip = snd_pcm_chip(pcm);
/* free your own data */
kfree(chip-&amp;gt;my_private_pcm_data);
/* do what you like else */
....
}

static int snd_mychip_new_pcm(struct mychip *chip)
{
struct snd_pcm *pcm;
....
/* allocate your own data */
chip-&amp;gt;my_private_pcm_data = kmalloc(...);
/* set the destructor */
pcm-&amp;gt;private_data = chip;
pcm-&amp;gt;private_free = mychip_pcm_free;
....
}


Runtime Pointer - The Chest of PCM Information
When the PCM substream is opened, a PCM runtime instance is
allocated and assigned to the substream. This pointer is
accessible via substream-&amp;gt;runtime.
This runtime pointer holds most information you need
to control the PCM: the copy of hw_params and sw_params configurations, the buffer
pointers, mmap records, spinlocks, etc.

The definition of runtime instance is found in
&amp;lt;sound/pcm.h&amp;gt;.  Here are
the contents of this file:

struct _snd_pcm_runtime {
/* -- Status -- */
struct snd_pcm_substream *trigger_master;
snd_timestamp_t trigger_tstamp;    /* trigger timestamp */
int overrange;
snd_pcm_uframes_t avail_max;
snd_pcm_uframes_t hw_ptr_base;    /* Position at buffer restart */
snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/

/* -- HW params -- */
snd_pcm_access_t access;    /* access mode */
snd_pcm_format_t format;    /* SNDRV_PCM_FORMAT_* */
snd_pcm_subformat_t subformat;    /* subformat */
unsigned int rate;        /* rate in Hz */
unsigned int channels;        /* channels */
snd_pcm_uframes_t period_size;    /* period size */
unsigned int periods;        /* periods */
snd_pcm_uframes_t buffer_size;    /* buffer size */
unsigned int tick_time;        /* tick time */
snd_pcm_uframes_t min_align;    /* Min alignment for the format */
size_t byte_align;
unsigned int frame_bits;
unsigned int sample_bits;
unsigned int info;
unsigned int rate_num;
unsigned int rate_den;

/* -- SW params -- */
struct timespec tstamp_mode;    /* mmap timestamp is updated */
unsigned int period_step;
unsigned int sleep_min;        /* min ticks to sleep */
snd_pcm_uframes_t start_threshold;
snd_pcm_uframes_t stop_threshold;
snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
noise is nearest than this */
snd_pcm_uframes_t silence_size;    /* Silence filling size */
snd_pcm_uframes_t boundary;    /* pointers wrap point */

snd_pcm_uframes_t silenced_start;
snd_pcm_uframes_t silenced_size;

snd_pcm_sync_id_t sync;        /* hardware synchronization ID */

/* -- mmap -- */
volatile struct snd_pcm_mmap_status *status;
volatile struct snd_pcm_mmap_control *control;
atomic_t mmap_count;

/* -- locking / scheduling -- */
spinlock_t lock;
wait_queue_head_t sleep;
struct timer_list tick_timer;
struct fasync_struct *fasync;

/* -- private section -- */
void *private_data;
void (*private_free)(struct snd_pcm_runtime *runtime);

/* -- hardware description -- */
struct snd_pcm_hardware hw;
struct snd_pcm_hw_constraints hw_constraints;

/* -- interrupt callbacks -- */
void (*transfer_ack_begin)(struct snd_pcm_substream *substream);
void (*transfer_ack_end)(struct snd_pcm_substream *substream);

/* -- timer -- */
unsigned int timer_resolution;    /* timer resolution */

/* -- DMA -- */
unsigned char *dma_area;    /* DMA area */
dma_addr_t dma_addr;        /* physical bus address (not accessible from main CPU) */
size_t dma_bytes;        /* size of DMA area */

struct snd_dma_buffer *dma_buffer_p;    /* allocated buffer */

#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
/* -- OSS things -- */
struct snd_pcm_oss_runtime oss;
#endif
};



For the operators (callbacks) of each sound driver, most of
these records are supposed to be read-only.  Only the PCM
middle-layer changes / updates them.  The exceptions are
the hardware description (hw), interrupt callbacks
(transfer_ack_xxx), DMA buffer information, and the private
data.  Besides, if you use the standard buffer allocation
method via snd_pcm_lib_malloc_pages(),
you don&#39;t need to set the DMA buffer information by yourself.

In the sections below, important records are explained.
Hardware Description
The hardware descriptor (struct snd_pcm_hardware)
contains the definitions of the fundamental hardware
configuration.  Above all, you&#39;ll need to define this in

the open callback.
Note that the runtime instance holds the copy of the
descriptor, not the pointer to the existing descriptor.  That
is, in the open callback, you can modify the copied descriptor
(runtime-&amp;gt;hw) as you need.  For example, if the maximum
number of channels is 1 only on some chip models, you can
still use the same hardware descriptor and change the
channels_max later:

struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime;
...
runtime-&amp;gt;hw = snd_mychip_playback_hw; /* common definition */
if (chip-&amp;gt;model == VERY_OLD_ONE)
runtime-&amp;gt;hw.channels_max = 1;



Typically, you&#39;ll have a hardware descriptor as below:

static struct snd_pcm_hardware snd_mychip_playback_hw = {
.info = (SNDRV_PCM_INFO_MMAP |
SNDRV_PCM_INFO_INTERLEAVED |
SNDRV_PCM_INFO_BLOCK_TRANSFER |
SNDRV_PCM_INFO_MMAP_VALID),
.formats =          SNDRV_PCM_FMTBIT_S16_LE,
.rates =            SNDRV_PCM_RATE_8000_48000,
.rate_min =         8000,
.rate_max =         48000,
.channels_min =     2,
.channels_max =     2,
.buffer_bytes_max = 32768,
.period_bytes_min = 4096,
.period_bytes_max = 32768,
.periods_min =      1,
.periods_max =      1024,
};



The info field contains the type and
capabilities of this pcm. The bit flags are defined in
&amp;lt;sound/asound.h&amp;gt; as
SNDRV_PCM_INFO_XXX. Here, at least, you
have to specify whether the mmap is supported and which
interleaved format is supported.
When the hardware supports mmap, add the
SNDRV_PCM_INFO_MMAP flag here. When the
hardware supports the interleaved or the non-interleaved
formats, SNDRV_PCM_INFO_INTERLEAVED or
SNDRV_PCM_INFO_NONINTERLEAVED flag must
be set, respectively. If both are supported, you can set both,
too.

In the above example, MMAP_VALID and
BLOCK_TRANSFER are specified for the OSS mmap
mode. Usually both are set. Of course,
MMAP_VALID is set only if the mmap is
really supported.

The other possible flags are
SNDRV_PCM_INFO_PAUSE and
SNDRV_PCM_INFO_RESUME. The
PAUSE bit means that the pcm supports the
pause operation, while the
RESUME bit means that the pcm supports
the full suspend/resume operation.
If the PAUSE flag is set,
the trigger callback below
must handle the corresponding (pause push/release) commands.
The suspend/resume trigger commands can be defined even without
the RESUME flag.  See
Power Management section for details.

When the PCM substreams can be synchronized (typically,
synchronized start/stop of a playback and a capture streams),
you can give SNDRV_PCM_INFO_SYNC_START,
too.  In this case, you&#39;ll need to check the linked-list of
PCM substreams in the trigger callback.  This will be
described in the later section.
formats field contains the bit-flags
of supported formats (SNDRV_PCM_FMTBIT_XXX).
If the hardware supports more than one format, give all or&#39;ed
bits.  In the example above, the signed 16bit little-endian
format is specified.
rates field contains the bit-flags of
supported rates (SNDRV_PCM_RATE_XXX).
When the chip supports continuous rates, pass
CONTINUOUS bit additionally.
The pre-defined rate bits are provided only for typical
rates. If your chip supports unconventional rates, you need to add
the KNOT bit and set up the hardware
constraint manually (explained later).
rate_min and
rate_max define the minimum and
maximum sample rate.  This should correspond somehow to
rates bits.
channel_min and
channel_max
define, as you might already expected, the minimum and maximum
number of channels.
buffer_bytes_max defines the
maximum buffer size in bytes.  There is no
buffer_bytes_min field, since
it can be calculated from the minimum period size and the
minimum number of periods.
Meanwhile, period_bytes_min and
define the minimum and maximum size of the period in bytes.
periods_max and
periods_min define the maximum and
minimum number of periods in the buffer.

The period is a term that corresponds to
a fragment in the OSS world. The period defines the size at
which a PCM interrupt is generated. This size strongly
depends on the hardware.
Generally, the smaller period size will give you more
interrupts, that is, more controls.
In the case of capture, this size defines the input latency.
On the other hand, the whole buffer size defines the
output latency for the playback direction.

There is also a field fifo_size.
This specifies the size of the hardware FIFO, but currently it
is neither used in the driver nor in the alsa-lib.  So, you
can ignore this field.
PCM Configurations
Ok, let&#39;s go back again to the PCM runtime records.
The most frequently referred records in the runtime instance are
the PCM configurations.
The PCM configurations are stored in the runtime instance
after the application sends hw_params data via
alsa-lib.  There are many fields copied from hw_params and
sw_params structs.  For example,
format holds the format type
chosen by the application.  This field contains the enum value
SNDRV_PCM_FORMAT_XXX.

One thing to be noted is that the configured buffer and period
sizes are stored in frames in the runtime.
In the ALSA world, 1 frame = channels * samples-size.
For conversion between frames and bytes, you can use the
frames_to_bytes() and
bytes_to_frames() helper functions.

period_bytes = frames_to_bytes(runtime, runtime-&amp;gt;period_size);



Also, many software parameters (sw_params) are
stored in frames, too.  Please check the type of the field.
snd_pcm_uframes_t is for the frames as unsigned
integer while snd_pcm_sframes_t is for the frames
as signed integer.
DMA Buffer Information
The DMA buffer is defined by the following four fields,
dma_area,
dma_addr,
dma_bytes and
dma_private.
The dma_area holds the buffer
pointer (the logical address).  You can call
memcpy from/to
this pointer.  Meanwhile, dma_addr
holds the physical address of the buffer.  This field is
specified only when the buffer is a linear buffer.
dma_bytes holds the size of buffer
in bytes.  dma_private is used for
the ALSA DMA allocator.

If you use a standard ALSA function,
snd_pcm_lib_malloc_pages(), for
allocating the buffer, these fields are set by the ALSA middle
layer, and you should not change them by
yourself.  You can read them but not write them.
On the other hand, if you want to allocate the buffer by
yourself, you&#39;ll need to manage it in hw_params callback.
At least, dma_bytes is mandatory.
dma_area is necessary when the
buffer is mmapped.  If your driver doesn&#39;t support mmap, this
field is not necessary.  dma_addr
is also optional.  You can use
dma_private as you like, too.
Running Status
The running status can be referred via runtime-&amp;gt;status.
This is the pointer to the struct snd_pcm_mmap_status
record.  For example, you can get the current DMA hardware
pointer via runtime-&amp;gt;status-&amp;gt;hw_ptr.

The DMA application pointer can be referred via
runtime-&amp;gt;control, which points to the
struct snd_pcm_mmap_control record.
However, accessing directly to this value is not recommended.
Private Data
You can allocate a record for the substream and store it in
runtime-&amp;gt;private_data.  Usually, this
is done in

the open callback.
Don&#39;t mix this with pcm-&amp;gt;private_data.
The pcm-&amp;gt;private_data usually points to the
chip instance assigned statically at the creation of PCM, while the
runtime-&amp;gt;private_data points to a dynamic
data structure created at the PCM open callback.


static int snd_xxx_open(struct snd_pcm_substream *substream)
{
struct my_pcm_data *data;
....
data = kmalloc(sizeof(*data), GFP_KERNEL);
substream-&amp;gt;runtime-&amp;gt;private_data = data;
....
}



The allocated object must be released in

the close callback.
Interrupt Callbacks
The field transfer_ack_begin and
transfer_ack_end are called at
the beginning and at the end of
snd_pcm_period_elapsed(), respectively.
Operators
OK, now let me give details about each pcm callback
(ops). In general, every callback must
return 0 if successful, or a negative error number
such as -EINVAL. To choose an appropriate
error number, it is advised to check what value other parts of
the kernel return when the same kind of request fails.

The callback function takes at least the argument with
snd_pcm_substream pointer. To retrieve
the chip record from the given substream instance, you can use the
following macro.


int xxx() {
struct mychip *chip = snd_pcm_substream_chip(substream);
....
}



The macro reads substream-&amp;gt;private_data,
which is a copy of pcm-&amp;gt;private_data.
You can override the former if you need to assign different data
records per PCM substream.  For example, the cmi8330 driver assigns
different private_data for playback and capture directions,
because it uses two different codecs (SB- and AD-compatible) for
different directions.
open callback
static int snd_xxx_open(struct snd_pcm_substream *substream);



This is called when a pcm substream is opened.

At least, here you have to initialize the runtime-&amp;gt;hw
record. Typically, this is done by like this:


static int snd_xxx_open(struct snd_pcm_substream *substream)
{
struct mychip *chip = snd_pcm_substream_chip(substream);
struct snd_pcm_runtime *runtime = substream-&amp;gt;runtime;

runtime-&amp;gt;hw = snd_mychip_playback_hw;
return 0;
}



where snd_mychip_playback_hw is the
pre-defined hardware description.

You can allocate a private data in this callback, as described
in
Private Data section.

If the hardware configuration needs more constraints, set the
hardware constraints here, too.
See
Constraints for more details.
close callback
static int snd_xxx_close(struct snd_pcm_substream *substream);



Obviously, this is called when a pcm substream is closed.

Any private instance for a pcm substream allocated in the
open callback will be released here.


static int snd_xxx_close(struct snd_pcm_substream *substream)
{
....
kfree(substream-&amp;gt;runtime-&amp;gt;private_data);
....
}


ioctl callback
This is used for any special call to pcm ioctls. But
usually you can pass a generic ioctl callback,
snd_pcm_lib_ioctl.
hw_params callback
static int snd_xxx_hw_params(struct snd_pcm_substream *substream,
struct snd_pcm_hw_params *hw_params);


This is called when the hardware parameter
(hw_params) is set
up by the application,
that is, once when the buffer size, the period size, the
format, etc. are defined for the pcm substream.

Many hardware setups should be done in this callback,
including the allocation of buffers.

Parameters to be initialized are retrieved by
params_xxx() macros. To allocate
buffer, you can call a helper function,


snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));



snd_pcm_lib_malloc_pages() is available
only when the DMA buffers have been pre-allocated.
See the section
Buffer Types for more details.

Note that this and prepare callbacks
may be called multiple times per initialization.
For example, the OSS emulation may
call these callbacks at each change via its ioctl.

Thus, you need to be careful not to allocate the same buffers
many times, which will lead to memory leaks!  Calling the
helper function above many times is OK. It will release the
previous buffer automatically when it was already allocated.

Another note is that this callback is non-atomic
(schedulable). This is important, because the
trigger callback
is atomic (non-schedulable). That is, mutexes or any
schedule-related functions are not available in
trigger callback.
Please see the subsection

Atomicity for details.
hw_free callback
static int snd_xxx_hw_free(struct snd_pcm_substream *substream);


This is called to release the resources allocated via
hw_params. For example, releasing the
buffer via
snd_pcm_lib_malloc_pages() is done by
calling the following:


snd_pcm_lib_free_pages(substream);



This function is always called before the close callback is called.
Also, the callback may be called multiple times, too.
Keep track whether the resource was already released.
prepare callback
static int snd_xxx_prepare(struct snd_pcm_substream *substream);


This callback is called when the pcm is
prepared. You can set the format type, sample
rate, etc. here. The difference from
hw_params is that the
prepare callback will be called each
time
snd_pcm_prepare() is called, i.e. when
recovering after underruns, etc.

Note that this callback is now non-atomic.
You can use schedule-related functions safely in this callback.

In this and the following callbacks, you can refer to the
values via the runtime record,
substream-&amp;gt;runtime.
For example, to get the current
rate, format or channels, access to
runtime-&amp;gt;rate,
runtime-&amp;gt;format or
runtime-&amp;gt;channels, respectively.
The physical address of the allocated buffer is set to
runtime-&amp;gt;dma_area.  The buffer and period sizes are
in runtime-&amp;gt;buffer_size and runtime-&amp;gt;period_size,
respectively.

Be careful that this callback will be called many times at
each setup, too.
trigger callback
static int snd_xxx_trigger(struct snd_pcm_substream *substream, int cmd);



This is called when the pcm is started, stopped or paused.

Which action is specified in the second argument,
SNDRV_PCM_TRIGGER_XXX in
&amp;lt;sound/pcm.h&amp;gt;. At least,
the START and STOP
commands must be defined in this callback.


switch (cmd) {
case SNDRV_PCM_TRIGGER_START:
/* do something to start the PCM engine */
break;
case SNDRV_PCM_TRIGGER_STOP:
/* do something to stop the PCM engine */
break;
default:
return -EINVAL;
}



When the pcm supports the pause operation (given in the info
field of the hardware table), the PAUSE_PUSH
and PAUSE_RELEASE commands must be
handled here, too. The former is the command to pause the pcm,
and the latter to restart the pcm again.

When the pcm supports the suspend/resume operation,
regardless of full or partial suspend/resume support,
the SUSPEND and RESUME
commands must be handled, too.
These commands are issued when the power-management status is
changed.  Obviously, the SUSPEND and
RESUME commands
suspend and resume the pcm substream, and usually, they
are identical to the STOP and
START commands, respectively.
See the
Power Management section for details.

As mentioned, this callback is atomic.  You cannot call
functions which may sleep.
The trigger callback should be as minimal as possible,
just really triggering the DMA.  The other stuff should be
initialized hw_params and prepare callbacks properly
beforehand.
pointer callback
static snd_pcm_uframes_t snd_xxx_pointer(struct snd_pcm_substream *substream)



This callback is called when the PCM middle layer inquires
the current hardware position on the buffer. The position must
be returned in frames,
ranging from 0 to buffer_size - 1.

This is called usually from the buffer-update routine in the
pcm middle layer, which is invoked when
snd_pcm_period_elapsed() is called in the
interrupt routine. Then the pcm middle layer updates the
position and calculates the available space, and wakes up the
sleeping poll threads, etc.

This callback is also atomic.
copy and silence callbacks
These callbacks are not mandatory, and can be omitted in
most cases. These callbacks are used when the hardware buffer
cannot be in the normal memory space. Some chips have their
own buffer on the hardware which is not mappable. In such a
case, you have to transfer the data manually from the memory
buffer to the hardware buffer. Or, if the buffer is
non-contiguous on both physical and virtual memory spaces,
these callbacks must be defined, too.

If these two callbacks are defined, copy and set-silence
operations are done by them. The detailed will be described in
the later section Buffer and Memory
Management.
ack callback
This callback is also not mandatory. This callback is called
when the appl_ptr is updated in read or write operations.
Some drivers like emu10k1-fx and cs46xx need to track the
current appl_ptr for the internal buffer, and this callback
is useful only for such a purpose.

This callback is atomic.
page callback
This callback is optional too. This callback is used
mainly for non-contiguous buffers. The mmap calls this
callback to get the page address. Some examples will be
explained in the later section Buffer and Memory
Management, too.
Interrupt Handler
The rest of pcm stuff is the PCM interrupt handler. The
role of PCM interrupt handler in the sound driver is to update
the buffer position and to tell the PCM middle layer when the
buffer position goes across the prescribed period size. To
inform this, call the snd_pcm_period_elapsed()
function.

There are several types of sound chips to generate the interrupts.
Interrupts at the period (fragment) boundary
This is the most frequently found type:  the hardware
generates an interrupt at each period boundary.
In this case, you can call
snd_pcm_period_elapsed() at each
interrupt.
snd_pcm_period_elapsed() takes the
substream pointer as its argument. Thus, you need to keep the
substream pointer accessible from the chip instance. For
example, define substream field in the chip record to hold the
current running substream pointer, and set the pointer value
at open callback (and reset at close callback).

If you acquire a spinlock in the interrupt handler, and the
lock is used in other pcm callbacks, too, then you have to
release the lock before calling
snd_pcm_period_elapsed(), because
snd_pcm_period_elapsed() calls other pcm
callbacks inside.

Typical code would be like:

Interrupt Handler Case #1
static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
struct mychip *chip = dev_id;
spin_lock(&amp;amp;chip-&amp;gt;lock);
....
if (pcm_irq_invoked(chip)) {
/* call updater, unlock before it */
spin_unlock(&amp;amp;chip-&amp;gt;lock);
snd_pcm_period_elapsed(chip-&amp;gt;substream);
spin_lock(&amp;amp;chip-&amp;gt;lock);
/* acknowledge the interrupt if necessary */
}
....
spin_unlock(&amp;amp;chip-&amp;gt;lock);
return IRQ_HANDLED;
}


High frequency timer interrupts
This happens when the hardware doesn&#39;t generate interrupts
at the period boundary but issues timer interrupts at a fixed
timer rate (e.g. es1968 or ymfpci drivers).
In this case, you need to check the current hardware
position and accumulate the processed sample length at each
interrupt.  When the accumulated size exceeds the period
size, call
snd_pcm_period_elapsed() and reset the
accumulator.

Typical code would be like the following.

Interrupt Handler Case #2
static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
struct mychip *chip = dev_id;
spin_lock(&amp;amp;chip-&amp;gt;lock);
....
if (pcm_irq_invoked(chip)) {
unsigned int last_ptr, size;
/* get the current hardware pointer (in frames) */
last_ptr = get_hw_ptr(chip);
/* calculate the processed frames since the
* last update
*/
if (last_ptr &amp;lt; chip-&amp;gt;last_ptr)
size = runtime-&amp;gt;buffer_size + last_ptr
- chip-&amp;gt;last_ptr;
else
size = last_ptr - chip-&amp;gt;last_ptr;
/* remember the last updated point */
chip-&amp;gt;last_ptr = last_ptr;
/* accumulate the size */
chip-&amp;gt;size += size;
/* over the period boundary? */
if (chip-&amp;gt;size &amp;gt;= runtime-&amp;gt;period_size) {
/* reset the accumulator */
chip-&amp;gt;size %= runtime-&amp;gt;period_size;
/* call updater */
spin_unlock(&amp;amp;chip-&amp;gt;lock);
snd_pcm_period_elapsed(substream);
spin_lock(&amp;amp;chip-&amp;gt;lock);
}
/* acknowledge the interrupt if necessary */
}
....
spin_unlock(&amp;amp;chip-&amp;gt;lock);
return IRQ_HANDLED;
}


On calling snd_pcm_period_elapsed()
In both cases, even if more than one period are elapsed, you
don&#39;t have to call
snd_pcm_period_elapsed() many times. Call
only once. And the pcm layer will check the current hardware
pointer and update to the latest status.
Atomicity
One of the most important (and thus difficult to debug) problems
in kernel programming are race conditions.
In the Linux kernel, they are usually avoided via spin-locks, mutexes
or semaphores.  In general, if a race condition can happen
in an interrupt handler, it has to be managed atomically, and you
have to use a spinlock to protect the critical session. If the
critical section is not in interrupt handler code and
if taking a relatively long time to execute is acceptable, you
should use mutexes or semaphores instead.

As already seen, some pcm callbacks are atomic and some are
not.  For example, the hw_params callback is
non-atomic, while trigger callback is
atomic.  This means, the latter is called already in a spinlock
held by the PCM middle layer. Please take this atomicity into
account when you choose a locking scheme in the callbacks.

In the atomic callbacks, you cannot use functions which may call
schedule or go to
sleep.  Semaphores and mutexes can sleep,
and hence they cannot be used inside the atomic callbacks
(e.g. trigger callback).
To implement some delay in such a callback, please use
udelay() or mdelay().

All three atomic callbacks (trigger, pointer, and ack) are
called with local interrupts disabled.
Constraints
If your chip supports unconventional sample rates, or only the
limited samples, you need to set a constraint for the
condition.

For example, in order to restrict the sample rates in the some
supported values, use
snd_pcm_hw_constraint_list().
You need to call this function in the open callback.

Example of Hardware Constraints
static unsigned int rates[] =
{4000, 10000, 22050, 44100};
static struct snd_pcm_hw_constraint_list constraints_rates = {
.count = ARRAY_SIZE(rates),
.list = rates,
.mask = 0,
};

static int snd_mychip_pcm_open(struct snd_pcm_substream *substream)
{
int err;
....
err = snd_pcm_hw_constraint_list(substream-&amp;gt;runtime, 0,
SNDRV_PCM_HW_PARAM_RATE,
&amp;amp;constraints_rates);
if (err &amp;lt; 0)
return err;
....
}



There are many different constraints.
Look at sound/pcm.h for a complete list.
You can even define your own constraint rules.
For example, let&#39;s suppose my_chip can manage a substream of 1 channel
if and only if the format is S16_LE, otherwise it supports any format
specified in the snd_pcm_hardware structure (or in any
other constraint_list). You can build a rule like this:

Example of Hardware Constraints for Channels
static int hw_rule_channels_by_format(struct snd_pcm_hw_params *params,
struct snd_pcm_hw_rule *rule)
{
struct snd_interval *c = hw_param_interval(params,
SNDRV_PCM_HW_PARAM_CHANNELS);
struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
struct snd_interval ch;

snd_interval_any(&amp;amp;ch);
if (f-&amp;gt;bits[0] == SNDRV_PCM_FMTBIT_S16_LE) {
ch.min = ch.max = 1;
ch.integer = 1;
return snd_interval_refine(c, &amp;amp;ch);
}
return 0;
}



Then you need to call this function to add your rule:


snd_pcm_hw_rule_add(substream-&amp;gt;runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
hw_rule_channels_by_format, NULL,
SNDRV_PCM_HW_PARAM_FORMAT, -1);



The rule function is called when an application sets the PCM
format, and it refines the number of channels accordingly.
But an application may set the number of channels before
setting the format. Thus you also need to define the inverse rule:

Example of Hardware Constraints for Formats
static int hw_rule_format_by_channels(struct snd_pcm_hw_params *params,
struct snd_pcm_hw_rule *rule)
{
struct snd_interval *c = hw_param_interval(params,
SNDRV_PCM_HW_PARAM_CHANNELS);
struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
struct snd_mask fmt;

snd_mask_any(&amp;amp;fmt);    /* Init the struct */
if (c-&amp;gt;min &amp;lt; 2) {
fmt.bits[0] &amp;amp;= SNDRV_PCM_FMTBIT_S16_LE;
return snd_mask_refine(f, &amp;amp;fmt);
}
return 0;
}



...and in the open callback:

snd_pcm_hw_rule_add(substream-&amp;gt;runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,
hw_rule_format_by_channels, NULL,
SNDRV_PCM_HW_PARAM_CHANNELS, -1);



I won&#39;t give more details here, rather I
would like to say, Luke, use the source.
&lt;!-- ****************************************************** --&gt;&lt;!-- Control Interface  --&gt;&lt;!-- ****************************************************** --&gt;Control InterfaceGeneral
The control interface is used widely for many switches,
sliders, etc. which are accessed from user-space. Its most
important use is the mixer interface. In other words, since ALSA
0.9.x, all the mixer stuff is implemented on the control kernel API.

ALSA has a well-defined AC97 control module. If your chip
supports only the AC97 and nothing else, you can skip this
section.

The control API is defined in
&amp;lt;sound/control.h&amp;gt;.
Include this file if you want to add your own controls.
Definition of Controls
To create a new control, you need to define the
following three
callbacks: info,
get and
put. Then, define a
struct snd_kcontrol_new record, such as:

Definition of a Control
static struct snd_kcontrol_new my_control = {
.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
.name = &quot;PCM Playback Switch&quot;,
.index = 0,
.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
.private_value = 0xffff,
.info = my_control_info,
.get = my_control_get,
.put = my_control_put
};



The iface field specifies the control
type, SNDRV_CTL_ELEM_IFACE_XXX, which
is usually MIXER.
Use CARD for global controls that are not
logically part of the mixer.
If the control is closely associated with some specific device on
the sound card, use HWDEP,
PCM, RAWMIDI,
TIMER, or SEQUENCER, and
specify the device number with the
device and
subdevice fields.

The name is the name identifier
string. Since ALSA 0.9.x, the control name is very important,
because its role is classified from its name. There are
pre-defined standard control names. The details are described in
the
Control Names subsection.

The index field holds the index number
of this control. If there are several different controls with
the same name, they can be distinguished by the index
number. This is the case when
several codecs exist on the card. If the index is zero, you can
omit the definition above.

The access field contains the access
type of this control. Give the combination of bit masks,
SNDRV_CTL_ELEM_ACCESS_XXX, there.
The details will be explained in
the
Access Flags subsection.

The private_value field contains
an arbitrary long integer value for this record. When using
the generic info,
get and
put callbacks, you can pass a value
through this field. If several small numbers are necessary, you can
combine them in bitwise. Or, it&#39;s possible to give a pointer
(casted to unsigned long) of some record to this field, too.

The tlv field can be used to provide
metadata about the control; see the
Metadata subsection.

The other three are

callback functions.
Control Names
There are some standards to define the control names. A
control is usually defined from the three parts as
SOURCE DIRECTION FUNCTION.

The first, SOURCE, specifies the source
of the control, and is a string such as Master,
PCM, CD and
Line. There are many pre-defined sources.

The second, DIRECTION, is one of the
following strings according to the direction of the control:
Playback, Capture, Bypass
Playback and Bypass Capture. Or, it can
be omitted, meaning both playback and capture directions.

The third, FUNCTION, is one of the
following strings according to the function of the control:
Switch, Volume and
Route.

The example of control names are, thus, Master Capture
Switch or PCM Playback Volume.

There are some exceptions:
Global capture and playbackCapture Source, Capture Switch
and Capture Volume are used for the global
capture (input) source, switch and volume. Similarly,
Playback Switch and Playback
Volume are used for the global output gain switch and
volume.
Tone-controls
tone-control switch and volumes are specified like
Tone Control - XXX, e.g. Tone Control -
Switch, Tone Control - Bass,
Tone Control - Center.
3D controls
3D-control switches and volumes are specified like 3D
Control - XXX, e.g. 3D Control -
Switch, 3D Control - Center, 3D
Control - Space.
Mic boost
Mic-boost switch is set as Mic Boost or
Mic Boost (6dB).

More precise information can be found in
Documentation/sound/alsa/ControlNames.txt.
Access Flags
The access flag is the bitmask which specifies the access type
of the given control.  The default access type is
SNDRV_CTL_ELEM_ACCESS_READWRITE,
which means both read and write are allowed to this control.
When the access flag is omitted (i.e. = 0), it is
considered as READWRITE access as default.

When the control is read-only, pass
SNDRV_CTL_ELEM_ACCESS_READ instead.
In this case, you don&#39;t have to define
the put callback.
Similarly, when the control is write-only (although it&#39;s a rare
case), you can use the WRITE flag instead, and
you don&#39;t need the get callback.

If the control value changes frequently (e.g. the VU meter),
VOLATILE flag should be given.  This means
that the control may be changed without

notification. Applications should poll such
a control constantly.

When the control is inactive, set
the INACTIVE flag, too.
There are LOCK and
OWNER flags to change the write
permissions.
Callbacksinfo callback
The info callback is used to get
detailed information on this control. This must store the
values of the given struct snd_ctl_elem_info
object. For example, for a boolean control with a single
element:

Example of info callback
static int snd_myctl_mono_info(struct snd_kcontrol *kcontrol,
struct snd_ctl_elem_info *uinfo)
{
uinfo-&amp;gt;type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
uinfo-&amp;gt;count = 1;
uinfo-&amp;gt;value.integer.min = 0;
uinfo-&amp;gt;value.integer.max = 1;
return 0;
}



The type field specifies the type
of the control. There are BOOLEAN,
INTEGER, ENUMERATED,
BYTES, IEC958 and
INTEGER64. The
count field specifies the
number of elements in this control. For example, a stereo
volume would have count = 2. The
value field is a union, and
the values stored are depending on the type. The boolean and
integer types are identical.

The enumerated type is a bit different from others.  You&#39;ll
need to set the string for the currently given item index.


static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol,
struct snd_ctl_elem_info *uinfo)
{
static char *texts[4] = {
&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot;
};
uinfo-&amp;gt;type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
uinfo-&amp;gt;count = 1;
uinfo-&amp;gt;value.enumerated.items = 4;
if (uinfo-&amp;gt;value.enumerated.item &amp;gt; 3)
uinfo-&amp;gt;value.enumerated.item = 3;
strcpy(uinfo-&amp;gt;value.enumerated.name,
texts[uinfo-&amp;gt;value.enumerated.item]);
return 0;
}



Some common info callbacks are available for your convenience:
snd_ctl_boolean_mono_info() and
snd_ctl_boolean_stereo_info().
Obviously, the former is an info callback for a mono channel
boolean item, just like snd_myctl_mono_info
above, and the latter is for a stereo channel boolean item.
get callback
This callback is used to read the current value of the
control and to return to user-space.

For example,

Example of get callback
static int snd_myctl_get(struct snd_kcontrol *kcontrol,
struct snd_ctl_elem_value *ucontrol)
{
struct mychip *chip = snd_kcontrol_chip(kcontrol);
ucontrol-&amp;gt;value.integer.value[0] = get_some_value(chip);
return 0;
}



The value field depends on
the type of control as well as on the info callback.  For example,
the sb driver uses this field to store the register offset,
the bit-shift and the bit-mask.  The
private_value field is set as follows:

.private_value = reg | (shift &amp;lt;&amp;lt; 16) | (mask &amp;lt;&amp;lt; 24)


and is retrieved in callbacks like

static int snd_sbmixer_get_single(struct snd_kcontrol *kcontrol,
struct snd_ctl_elem_value *ucontrol)
{
int reg = kcontrol-&amp;gt;private_value &amp;amp; 0xff;
int shift = (kcontrol-&amp;gt;private_value &amp;gt;&amp;gt; 16) &amp;amp; 0xff;
int mask = (kcontrol-&amp;gt;private_value &amp;gt;&amp;gt; 24) &amp;amp; 0xff;
....
}



In the get callback,
you have to fill all the elements if the
control has more than one elements,
i.e. count &amp;gt; 1.
In the example above, we filled only one element
(value.integer.value[0]) since it&#39;s
assumed as count = 1.
put callback
This callback is used to write a value from user-space.

For example,

Example of put callback
static int snd_myctl_put(struct snd_kcontrol *kcontrol,
struct snd_ctl_elem_value *ucontrol)
{
struct mychip *chip = snd_kcontrol_chip(kcontrol);
int changed = 0;
if (chip-&amp;gt;current_value !=
ucontrol-&amp;gt;value.integer.value[0]) {
change_current_value(chip,
ucontrol-&amp;gt;value.integer.value[0]);
changed = 1;
}
return changed;
}



As seen above, you have to return 1 if the value is
changed. If the value is not changed, return 0 instead.
If any fatal error happens, return a negative error code as
usual.

As in the get callback,
when the control has more than one elements,
all elements must be evaluated in this callback, too.
Callbacks are not atomic
All these three callbacks are basically not atomic.
Constructor
When everything is ready, finally we can create a new
control. To create a control, there are two functions to be
called, snd_ctl_new1() and
snd_ctl_add().

In the simplest way, you can do like this:


err = snd_ctl_add(card, snd_ctl_new1(&amp;amp;my_control, chip));
if (err &amp;lt; 0)
return err;



where my_control is the
struct snd_kcontrol_new object defined above, and chip
is the object pointer to be passed to
kcontrol-&amp;gt;private_data
which can be referred to in callbacks.
snd_ctl_new1() allocates a new
snd_kcontrol instance,
and snd_ctl_add assigns the given
control component to the card.
Change Notification
If you need to change and update a control in the interrupt
routine, you can call snd_ctl_notify(). For
example,


snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, id_pointer);



This function takes the card pointer, the event-mask, and the
control id pointer for the notification. The event-mask
specifies the types of notification, for example, in the above
example, the change of control values is notified.
The id pointer is the pointer of struct snd_ctl_elem_id
to be notified.
You can find some examples in es1938.c or
es1968.c for hardware volume interrupts.
Metadata
To provide information about the dB values of a mixer control, use
on of the DECLARE_TLV_xxx macros from
&amp;lt;sound/tlv.h&amp;gt; to define a variable
containing this information, set thetlv.p
field to point to this variable, and include the
SNDRV_CTL_ELEM_ACCESS_TLV_READ flag in the
access field; like this:

static DECLARE_TLV_DB_SCALE(db_scale_my_control, -4050, 150, 0);

static struct snd_kcontrol_new my_control = {
...
.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
SNDRV_CTL_ELEM_ACCESS_TLV_READ,
...
.tlv.p = db_scale_my_control,
};



The DECLARE_TLV_DB_SCALE macro defines
information about a mixer control where each step in the control&#39;s
value changes the dB value by a constant dB amount.
The first parameter is the name of the variable to be defined.
The second parameter is the minimum value, in units of 0.01 dB.
The third parameter is the step size, in units of 0.01 dB.
Set the fourth parameter to 1 if the minimum value actually mutes
the control.

The DECLARE_TLV_DB_LINEAR macro defines
information about a mixer control where the control&#39;s value affects
the output linearly.
The first parameter is the name of the variable to be defined.
The second parameter is the minimum value, in units of 0.01 dB.
The third parameter is the maximum value, in units of 0.01 dB.
If the minimum value mutes the control, set the second parameter to
TLV_DB_GAIN_MUTE.
&lt;!-- ****************************************************** --&gt;&lt;!-- API for AC97 Codec  --&gt;&lt;!-- ****************************************************** --&gt;API for AC97 CodecGeneral
The ALSA AC97 codec layer is a well-defined one, and you don&#39;t
have to write much code to control it. Only low-level control
routines are necessary. The AC97 codec API is defined in
&amp;lt;sound/ac97_codec.h&amp;gt;.
Full Code ExampleExample of AC97 Interface
struct mychip {
....
struct snd_ac97 *ac97;
....
};

static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,
unsigned short reg)
{
struct mychip *chip = ac97-&amp;gt;private_data;
....
/* read a register value here from the codec */
return the_register_value;
}

static void snd_mychip_ac97_write(struct snd_ac97 *ac97,
unsigned short reg, unsigned short val)
{
struct mychip *chip = ac97-&amp;gt;private_data;
....
/* write the given register value to the codec */
}

static int snd_mychip_ac97(struct mychip *chip)
{
struct snd_ac97_bus *bus;
struct snd_ac97_template ac97;
int err;
static struct snd_ac97_bus_ops ops = {
.write = snd_mychip_ac97_write,
.read = snd_mychip_ac97_read,
};

err = snd_ac97_bus(chip-&amp;gt;card, 0, &amp;amp;ops, NULL, &amp;amp;bus);
if (err &amp;lt; 0)
return err;
memset(&amp;amp;ac97, 0, sizeof(ac97));
ac97.private_data = chip;
return snd_ac97_mixer(bus, &amp;amp;ac97, &amp;amp;chip-&amp;gt;ac97);
}


Constructor
To create an ac97 instance, first call snd_ac97_bus
with an ac97_bus_ops_t record with callback functions.


struct snd_ac97_bus *bus;
static struct snd_ac97_bus_ops ops = {
.write = snd_mychip_ac97_write,
.read = snd_mychip_ac97_read,
};

snd_ac97_bus(card, 0, &amp;amp;ops, NULL, &amp;amp;pbus);



The bus record is shared among all belonging ac97 instances.

And then call snd_ac97_mixer() with an
struct snd_ac97_template
record together with the bus pointer created above.


struct snd_ac97_template ac97;
int err;

memset(&amp;amp;ac97, 0, sizeof(ac97));
ac97.private_data = chip;
snd_ac97_mixer(bus, &amp;amp;ac97, &amp;amp;chip-&amp;gt;ac97);



where chip-&amp;gt;ac97 is a pointer to a newly created
ac97_t instance.
In this case, the chip pointer is set as the private data, so that
the read/write callback functions can refer to this chip instance.
This instance is not necessarily stored in the chip
record.  If you need to change the register values from the
driver, or need the suspend/resume of ac97 codecs, keep this
pointer to pass to the corresponding functions.
Callbacks
The standard callbacks are read and
write. Obviously they
correspond to the functions for read and write accesses to the
hardware low-level codes.

The read callback returns the
register value specified in the argument.


static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,
unsigned short reg)
{
struct mychip *chip = ac97-&amp;gt;private_data;
....
return the_register_value;
}



Here, the chip can be cast from ac97-&amp;gt;private_data.

Meanwhile, the write callback is
used to set the register value.


static void snd_mychip_ac97_write(struct snd_ac97 *ac97,
unsigned short reg, unsigned short val)



These callbacks are non-atomic like the control API callbacks.

There are also other callbacks:
reset,
wait and
init.

The reset callback is used to reset
the codec. If the chip requires a special kind of reset, you can
define this callback.

The wait callback is used to
add some waiting time in the standard initialization of the codec. If the
chip requires the extra waiting time, define this callback.

The init callback is used for
additional initialization of the codec.
Updating Registers in The Driver
If you need to access to the codec from the driver, you can
call the following functions:
snd_ac97_write(),
snd_ac97_read(),
snd_ac97_update() and
snd_ac97_update_bits().

Both snd_ac97_write() and
snd_ac97_update() functions are used to
set a value to the given register
(AC97_XXX). The difference between them is
that snd_ac97_update() doesn&#39;t write a
value if the given value has been already set, while
snd_ac97_write() always rewrites the
value.


snd_ac97_write(ac97, AC97_MASTER, 0x8080);
snd_ac97_update(ac97, AC97_MASTER, 0x8080);


snd_ac97_read() is used to read the value
of the given register. For example,


value = snd_ac97_read(ac97, AC97_MASTER);


snd_ac97_update_bits() is used to update
some bits in the given register.


snd_ac97_update_bits(ac97, reg, mask, value);



Also, there is a function to change the sample rate (of a
given register such as
AC97_PCM_FRONT_DAC_RATE) when VRA or
DRA is supported by the codec:
snd_ac97_set_rate().


snd_ac97_set_rate(ac97, AC97_PCM_FRONT_DAC_RATE, 44100);



The following registers are available to set the rate:
AC97_PCM_MIC_ADC_RATE,
AC97_PCM_FRONT_DAC_RATE,
AC97_PCM_LR_ADC_RATE,
AC97_SPDIF. When
AC97_SPDIF is specified, the register is
not really changed but the corresponding IEC958 status bits will
be updated.
Clock Adjustment
In some chips, the clock of the codec isn&#39;t 48000 but using a
PCI clock (to save a quartz!). In this case, change the field
bus-&amp;gt;clock to the corresponding
value. For example, intel8x0
and es1968 drivers have their own function to read from the clock.
Proc Files
The ALSA AC97 interface will create a proc file such as
/proc/asound/card0/codec97#0/ac97#0-0 and
ac97#0-0+regs. You can refer to these files to
see the current status and registers of the codec.
Multiple Codecs
When there are several codecs on the same card, you need to
call snd_ac97_mixer() multiple times with
ac97.num=1 or greater. The num field
specifies the codec number.

If you set up multiple codecs, you either need to write
different callbacks for each codec or check
ac97-&amp;gt;num in the callback routines.
&lt;!-- ****************************************************** --&gt;&lt;!-- MIDI (MPU401-UART) Interface  --&gt;&lt;!-- ****************************************************** --&gt;MIDI (MPU401-UART) InterfaceGeneral
Many soundcards have built-in MIDI (MPU401-UART)
interfaces. When the soundcard supports the standard MPU401-UART
interface, most likely you can use the ALSA MPU401-UART API. The
MPU401-UART API is defined in
&amp;lt;sound/mpu401.h&amp;gt;.

Some soundchips have a similar but slightly different
implementation of mpu401 stuff. For example, emu10k1 has its own
mpu401 routines.
Constructor
To create a rawmidi object, call
snd_mpu401_uart_new().


struct snd_rawmidi *rmidi;
snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401, port, info_flags,
irq, &amp;amp;rmidi);



The first argument is the card pointer, and the second is the
index of this component. You can create up to 8 rawmidi
devices.

The third argument is the type of the hardware,
MPU401_HW_XXX. If it&#39;s not a special one,
you can use MPU401_HW_MPU401.

The 4th argument is the I/O port address. Many
backward-compatible MPU401 have an I/O port such as 0x330. Or, it
might be a part of its own PCI I/O region. It depends on the
chip design.

The 5th argument is a bitflag for additional information.
When the I/O port address above is part of the PCI I/O
region, the MPU401 I/O port might have been already allocated
(reserved) by the driver itself. In such a case, pass a bit flag
MPU401_INFO_INTEGRATED,
and the mpu401-uart layer will allocate the I/O ports by itself.

When the controller supports only the input or output MIDI stream,
pass the MPU401_INFO_INPUT or
MPU401_INFO_OUTPUT bitflag, respectively.
Then the rawmidi instance is created as a single stream.
MPU401_INFO_MMIO bitflag is used to change
the access method to MMIO (via readb and writeb) instead of
iob and outb. In this case, you have to pass the iomapped address
to snd_mpu401_uart_new().

When MPU401_INFO_TX_IRQ is set, the output
stream isn&#39;t checked in the default interrupt handler.  The driver
needs to call snd_mpu401_uart_interrupt_tx()
by itself to start processing the output stream in the irq handler.

If the MPU-401 interface shares its interrupt with the other logical
devices on the card, set MPU401_INFO_IRQ_HOOK
(see
below).

Usually, the port address corresponds to the command port and
port + 1 corresponds to the data port. If not, you may change
the cport field of
struct snd_mpu401 manually
afterward. However, snd_mpu401 pointer is not
returned explicitly by
snd_mpu401_uart_new(). You need to cast
rmidi-&amp;gt;private_data to
snd_mpu401 explicitly,


struct snd_mpu401 *mpu;
mpu = rmidi-&amp;gt;private_data;



and reset the cport as you like:


mpu-&amp;gt;cport = my_own_control_port;



The 6th argument specifies the ISA irq number that will be
allocated.  If no interrupt is to be allocated (because your
code is already allocating a shared interrupt, or because the
device does not use interrupts), pass -1 instead.
For a MPU-401 device without an interrupt, a polling timer
will be used instead.
Interrupt Handler
When the interrupt is allocated in
snd_mpu401_uart_new(), an exclusive ISA
interrupt handler is automatically used, hence you don&#39;t have
anything else to do than creating the mpu401 stuff.  Otherwise, you
have to set MPU401_INFO_IRQ_HOOK, and call
snd_mpu401_uart_interrupt() explicitly from your
own interrupt handler when it has determined that a UART interrupt
has occurred.

In this case, you need to pass the private_data of the
returned rawmidi object from
snd_mpu401_uart_new() as the second
argument of snd_mpu401_uart_interrupt().


snd_mpu401_uart_interrupt(irq, rmidi-&amp;gt;private_data, regs);


&lt;!-- ****************************************************** --&gt;&lt;!-- RawMIDI Interface  --&gt;&lt;!-- ****************************************************** --&gt;RawMIDI InterfaceOverview
The raw MIDI interface is used for hardware MIDI ports that can
be accessed as a byte stream.  It is not used for synthesizer
chips that do not directly understand MIDI.

ALSA handles file and buffer management.  All you have to do is
to write some code to move data between the buffer and the
hardware.

The rawmidi API is defined in
&amp;lt;sound/rawmidi.h&amp;gt;.
Constructor
To create a rawmidi device, call the
snd_rawmidi_new function:

struct snd_rawmidi *rmidi;
err = snd_rawmidi_new(chip-&amp;gt;card, &quot;MyMIDI&quot;, 0, outs, ins, &amp;amp;rmidi);
if (err &amp;lt; 0)
return err;
rmidi-&amp;gt;private_data = chip;
strcpy(rmidi-&amp;gt;name, &quot;My MIDI&quot;);
rmidi-&amp;gt;info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
SNDRV_RAWMIDI_INFO_INPUT |
SNDRV_RAWMIDI_INFO_DUPLEX;



The first argument is the card pointer, the second argument is
the ID string.

The third argument is the index of this component.  You can
create up to 8 rawmidi devices.

The fourth and fifth arguments are the number of output and
input substreams, respectively, of this device (a substream is
the equivalent of a MIDI port).

Set the info_flags field to specify
the capabilities of the device.
Set SNDRV_RAWMIDI_INFO_OUTPUT if there is
at least one output port,
SNDRV_RAWMIDI_INFO_INPUT if there is at
least one input port,
and SNDRV_RAWMIDI_INFO_DUPLEX if the device
can handle output and input at the same time.

After the rawmidi device is created, you need to set the
operators (callbacks) for each substream.  There are helper
functions to set the operators for all the substreams of a device:

snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &amp;amp;snd_mymidi_output_ops);
snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &amp;amp;snd_mymidi_input_ops);



The operators are usually defined like this:

static struct snd_rawmidi_ops snd_mymidi_output_ops = {
.open =    snd_mymidi_output_open,
.close =   snd_mymidi_output_close,
.trigger = snd_mymidi_output_trigger,
};


These callbacks are explained in the Callbacks
section.

If there are more than one substream, you should give a
unique name to each of them:

struct snd_rawmidi_substream *substream;
list_for_each_entry(substream,
&amp;amp;rmidi-&amp;gt;streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,
list {
sprintf(substream-&amp;gt;name, &quot;My MIDI Port %d&quot;, substream-&amp;gt;number + 1);
}
/* same for SNDRV_RAWMIDI_STREAM_INPUT */


Callbacks
In all the callbacks, the private data that you&#39;ve set for the
rawmidi device can be accessed as
substream-&amp;gt;rmidi-&amp;gt;private_data.
&lt;!-- &lt;code&gt; isn&#39;t available before DocBook 4.3 --&gt;

If there is more than one port, your callbacks can determine the
port index from the struct snd_rawmidi_substream data passed to each
callback:

struct snd_rawmidi_substream *substream;
int index = substream-&amp;gt;number;


open callback
static int snd_xxx_open(struct snd_rawmidi_substream *substream);


This is called when a substream is opened.
You can initialize the hardware here, but you shouldn&#39;t
start transmitting/receiving data yet.
close callback
static int snd_xxx_close(struct snd_rawmidi_substream *substream);


Guess what.

The open and close
callbacks of a rawmidi device are serialized with a mutex,
and can sleep.
trigger callback for output
substreams
static void snd_xxx_output_trigger(struct snd_rawmidi_substream *substream, int up);


This is called with a nonzero up
parameter when there is some data in the substream buffer that
must be transmitted.

To read data from the buffer, call
snd_rawmidi_transmit_peek.  It will
return the number of bytes that have been read; this will be
less than the number of bytes requested when there are no more
data in the buffer.
After the data have been transmitted successfully, call
snd_rawmidi_transmit_ack to remove the
data from the substream buffer:

unsigned char data;
while (snd_rawmidi_transmit_peek(substream, &amp;amp;data, 1) == 1) {
if (snd_mychip_try_to_transmit(data))
snd_rawmidi_transmit_ack(substream, 1);
else
break; /* hardware FIFO full */
}



If you know beforehand that the hardware will accept data, you
can use the snd_rawmidi_transmit function
which reads some data and removes them from the buffer at once:

while (snd_mychip_transmit_possible()) {
unsigned char data;
if (snd_rawmidi_transmit(substream, &amp;amp;data, 1) != 1)
break; /* no more data */
snd_mychip_transmit(data);
}



If you know beforehand how many bytes you can accept, you can
use a buffer size greater than one with the
snd_rawmidi_transmit* functions.

The trigger callback must not sleep.  If
the hardware FIFO is full before the substream buffer has been
emptied, you have to continue transmitting data later, either
in an interrupt handler, or with a timer if the hardware
doesn&#39;t have a MIDI transmit interrupt.

The trigger callback is called with a
zero up parameter when the transmission
of data should be aborted.
trigger callback for input
substreams
static void snd_xxx_input_trigger(struct snd_rawmidi_substream *substream, int up);


This is called with a nonzero up
parameter to enable receiving data, or with a zero
up parameter do disable receiving data.

The trigger callback must not sleep; the
actual reading of data from the device is usually done in an
interrupt handler.

When data reception is enabled, your interrupt handler should
call snd_rawmidi_receive for all received
data:

void snd_mychip_midi_interrupt(...)
{
while (mychip_midi_available()) {
unsigned char data;
data = mychip_midi_read();
snd_rawmidi_receive(substream, &amp;amp;data, 1);
}
}


drain callback
static void snd_xxx_drain(struct snd_rawmidi_substream *substream);


This is only used with output substreams.  This function should wait
until all data read from the substream buffer have been transmitted.
This ensures that the device can be closed and the driver unloaded
without losing data.

This callback is optional. If you do not set
drain in the struct snd_rawmidi_ops
structure, ALSA will simply wait for 50&amp;nbsp;milliseconds
instead.
&lt;!-- ****************************************************** --&gt;&lt;!-- Miscellaneous Devices  --&gt;&lt;!-- ****************************************************** --&gt;Miscellaneous DevicesFM OPL3
The FM OPL3 is still used in many chips (mainly for backward
compatibility). ALSA has a nice OPL3 FM control layer, too. The
OPL3 API is defined in
&amp;lt;sound/opl3.h&amp;gt;.

FM registers can be directly accessed through the direct-FM API,
defined in &amp;lt;sound/asound_fm.h&amp;gt;. In
ALSA native mode, FM registers are accessed through
the Hardware-Dependent Device direct-FM extension API, whereas in
OSS compatible mode, FM registers can be accessed with the OSS
direct-FM compatible API in /dev/dmfmX device.

To create the OPL3 component, you have two functions to
call. The first one is a constructor for the opl3_t
instance.


struct snd_opl3 *opl3;
snd_opl3_create(card, lport, rport, OPL3_HW_OPL3_XXX,
integrated, &amp;amp;opl3);



The first argument is the card pointer, the second one is the
left port address, and the third is the right port address. In
most cases, the right port is placed at the left port + 2.

The fourth argument is the hardware type.

When the left and right ports have been already allocated by
the card driver, pass non-zero to the fifth argument
(integrated). Otherwise, the opl3 module will
allocate the specified ports by itself.

When the accessing the hardware requires special method
instead of the standard I/O access, you can create opl3 instance
separately with snd_opl3_new().


struct snd_opl3 *opl3;
snd_opl3_new(card, OPL3_HW_OPL3_XXX, &amp;amp;opl3);



Then set command,
private_data and
private_free for the private
access function, the private data and the destructor.
The l_port and r_port are not necessarily set.  Only the
command must be set properly.  You can retrieve the data
from the opl3-&amp;gt;private_data field.

After creating the opl3 instance via snd_opl3_new(),
call snd_opl3_init() to initialize the chip to the
proper state. Note that snd_opl3_create() always
calls it internally.

If the opl3 instance is created successfully, then create a
hwdep device for this opl3.


struct snd_hwdep *opl3hwdep;
snd_opl3_hwdep_new(opl3, 0, 1, &amp;amp;opl3hwdep);



The first argument is the opl3_t instance you
created, and the second is the index number, usually 0.

The third argument is the index-offset for the sequencer
client assigned to the OPL3 port. When there is an MPU401-UART,
give 1 for here (UART always takes 0).
Hardware-Dependent Devices
Some chips need user-space access for special
controls or for loading the micro code. In such a case, you can
create a hwdep (hardware-dependent) device. The hwdep API is
defined in &amp;lt;sound/hwdep.h&amp;gt;. You can
find examples in opl3 driver or
isa/sb/sb16_csp.c.

The creation of the hwdep instance is done via
snd_hwdep_new().


struct snd_hwdep *hw;
snd_hwdep_new(card, &quot;My HWDEP&quot;, 0, &amp;amp;hw);



where the third argument is the index number.

You can then pass any pointer value to the
private_data.
If you assign a private data, you should define the
destructor, too. The destructor function is set in
the private_free field.


struct mydata *p = kmalloc(sizeof(*p), GFP_KERNEL);
hw-&amp;gt;private_data = p;
hw-&amp;gt;private_free = mydata_free;



and the implementation of the destructor would be:


static void mydata_free(struct snd_hwdep *hw)
{
struct mydata *p = hw-&amp;gt;private_data;
kfree(p);
}



The arbitrary file operations can be defined for this
instance. The file operators are defined in
the ops table. For example, assume that
this chip needs an ioctl.


hw-&amp;gt;ops.open = mydata_open;
hw-&amp;gt;ops.ioctl = mydata_ioctl;
hw-&amp;gt;ops.release = mydata_release;



And implement the callback functions as you like.
IEC958 (S/PDIF)
Usually the controls for IEC958 devices are implemented via
the control interface. There is a macro to compose a name string for
IEC958 controls, SNDRV_CTL_NAME_IEC958()
defined in &amp;lt;include/asound.h&amp;gt;.

There are some standard controls for IEC958 status bits. These
controls use the type SNDRV_CTL_ELEM_TYPE_IEC958,
and the size of element is fixed as 4 bytes array
(value.iec958.status[x]). For the info
callback, you don&#39;t specify
the value field for this type (the count field must be set,
though).
IEC958 Playback Con Mask is used to return the
bit-mask for the IEC958 status bits of consumer mode. Similarly,
IEC958 Playback Pro Mask returns the bitmask for
professional mode. They are read-only controls, and are defined
as MIXER controls (iface =
SNDRV_CTL_ELEM_IFACE_MIXER).

Meanwhile, IEC958 Playback Default control is
defined for getting and setting the current default IEC958
bits. Note that this one is usually defined as a PCM control
(iface = SNDRV_CTL_ELEM_IFACE_PCM),
although in some places it&#39;s defined as a MIXER control.

In addition, you can define the control switches to
enable/disable or to set the raw bit mode. The implementation
will depend on the chip, but the control should be named as
IEC958 xxx, preferably using
the SNDRV_CTL_NAME_IEC958() macro.

You can find several cases, for example,
pci/emu10k1,
pci/ice1712, or
pci/cmipci.c.
&lt;!-- ****************************************************** --&gt;&lt;!-- Buffer and Memory Management  --&gt;&lt;!-- ****************************************************** --&gt;Buffer and Memory ManagementBuffer Types
ALSA provides several different buffer allocation functions
depending on the bus and the architecture. All these have a
consistent API. The allocation of physically-contiguous pages is
done via
snd_malloc_xxx_pages() function, where xxx
is the bus type.

The allocation of pages with fallback is
snd_malloc_xxx_pages_fallback(). This
function tries to allocate the specified pages but if the pages
are not available, it tries to reduce the page sizes until
enough space is found.

The release the pages, call
snd_free_xxx_pages() function.

Usually, ALSA drivers try to allocate and reserve
a large contiguous physical space
at the time the module is loaded for the later use.
This is called pre-allocation.
As already written, you can call the following function at
pcm instance construction time (in the case of PCI bus).


snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
snd_dma_pci_data(pci), size, max);



where size is the byte size to be
pre-allocated and the max is the maximum
size to be changed via the prealloc proc file.
The allocator will try to get an area as large as possible
within the given size.

The second argument (type) and the third argument (device pointer)
are dependent on the bus.
In the case of the ISA bus, pass snd_dma_isa_data()
as the third argument with SNDRV_DMA_TYPE_DEV type.
For the continuous buffer unrelated to the bus can be pre-allocated
with SNDRV_DMA_TYPE_CONTINUOUS type and the
snd_dma_continuous_data(GFP_KERNEL) device pointer,
where GFP_KERNEL is the kernel allocation flag to
use.
For the PCI scatter-gather buffers, use
SNDRV_DMA_TYPE_DEV_SG with
snd_dma_pci_data(pci)
(see the
Non-Contiguous Buffers
section).

Once the buffer is pre-allocated, you can use the
allocator in the hw_params callback:


snd_pcm_lib_malloc_pages(substream, size);



Note that you have to pre-allocate to use this function.
External Hardware Buffers
Some chips have their own hardware buffers and the DMA
transfer from the host memory is not available. In such a case,
you need to either 1) copy/set the audio data directly to the
external hardware buffer, or 2) make an intermediate buffer and
copy/set the data from it to the external hardware buffer in
interrupts (or in tasklets, preferably).

The first case works fine if the external hardware buffer is large
enough.  This method doesn&#39;t need any extra buffers and thus is
more effective. You need to define the
copy and
silence callbacks for
the data transfer. However, there is a drawback: it cannot
be mmapped. The examples are GUS&#39;s GF1 PCM or emu8000&#39;s
wavetable PCM.

The second case allows for mmap on the buffer, although you have
to handle an interrupt or a tasklet to transfer the data
from the intermediate buffer to the hardware buffer. You can find an
example in the vxpocket driver.

Another case is when the chip uses a PCI memory-map
region for the buffer instead of the host memory. In this case,
mmap is available only on certain architectures like the Intel one.
In non-mmap mode, the data cannot be transferred as in the normal
way. Thus you need to define the copy and
silence callbacks as well,
as in the cases above. The examples are found in
rme32.c and rme96.c.

The implementation of the copy and
silence callbacks depends upon
whether the hardware supports interleaved or non-interleaved
samples. The copy callback is
defined like below, a bit
differently depending whether the direction is playback or
capture:


static int playback_copy(struct snd_pcm_substream *substream, int channel,
snd_pcm_uframes_t pos, void *src, snd_pcm_uframes_t count);
static int capture_copy(struct snd_pcm_substream *substream, int channel,
snd_pcm_uframes_t pos, void *dst, snd_pcm_uframes_t count);



In the case of interleaved samples, the second argument
(channel) is not used. The third argument
(pos) points the
current position offset in frames.

The meaning of the fourth argument is different between
playback and capture. For playback, it holds the source data
pointer, and for capture, it&#39;s the destination data pointer.

The last argument is the number of frames to be copied.

What you have to do in this callback is again different
between playback and capture directions. In the
playback case, you copy the given amount of data
(count) at the specified pointer
(src) to the specified offset
(pos) on the hardware buffer. When
coded like memcpy-like way, the copy would be like:


my_memcpy(my_buffer + frames_to_bytes(runtime, pos), src,
frames_to_bytes(runtime, count));



For the capture direction, you copy the given amount of
data (count) at the specified offset
(pos) on the hardware buffer to the
specified pointer (dst).


my_memcpy(dst, my_buffer + frames_to_bytes(runtime, pos),
frames_to_bytes(runtime, count));



Note that both the position and the amount of data are given
in frames.

In the case of non-interleaved samples, the implementation
will be a bit more complicated.

You need to check the channel argument, and if it&#39;s -1, copy
the whole channels. Otherwise, you have to copy only the
specified channel. Please check
isa/gus/gus_pcm.c as an example.

The silence callback is also
implemented in a similar way.


static int silence(struct snd_pcm_substream *substream, int channel,
snd_pcm_uframes_t pos, snd_pcm_uframes_t count);



The meanings of arguments are the same as in the
copy
callback, although there is no src/dst
argument. In the case of interleaved samples, the channel
argument has no meaning, as well as on
copy callback.

The role of silence callback is to
set the given amount
(count) of silence data at the
specified offset (pos) on the hardware
buffer. Suppose that the data format is signed (that is, the
silent-data is 0), and the implementation using a memset-like
function would be like:


my_memcpy(my_buffer + frames_to_bytes(runtime, pos), 0,
frames_to_bytes(runtime, count));



In the case of non-interleaved samples, again, the
implementation becomes a bit more complicated. See, for example,
isa/gus/gus_pcm.c.
Non-Contiguous Buffers
If your hardware supports the page table as in emu10k1 or the
buffer descriptors as in via82xx, you can use the scatter-gather
(SG) DMA. ALSA provides an interface for handling SG-buffers.
The API is provided in &amp;lt;sound/pcm.h&amp;gt;.

For creating the SG-buffer handler, call
snd_pcm_lib_preallocate_pages() or
snd_pcm_lib_preallocate_pages_for_all()
with SNDRV_DMA_TYPE_DEV_SG
in the PCM constructor like other PCI pre-allocator.
You need to pass snd_dma_pci_data(pci),
where pci is the struct pci_dev pointer
of the chip as well.
The struct snd_sg_buf instance is created as
substream-&amp;gt;dma_private. You can cast
the pointer like:


struct snd_sg_buf *sgbuf = (struct snd_sg_buf *)substream-&amp;gt;dma_private;



Then call snd_pcm_lib_malloc_pages()
in the hw_params callback
as well as in the case of normal PCI buffer.
The SG-buffer handler will allocate the non-contiguous kernel
pages of the given size and map them onto the virtually contiguous
memory.  The virtual pointer is addressed in runtime-&amp;gt;dma_area.
The physical address (runtime-&amp;gt;dma_addr) is set to zero,
because the buffer is physically non-contiguous.
The physical address table is set up in sgbuf-&amp;gt;table.
You can get the physical address at a certain offset via
snd_pcm_sgbuf_get_addr().

When a SG-handler is used, you need to set
snd_pcm_sgbuf_ops_page as
the page callback.
(See page callback section.)

To release the data, call
snd_pcm_lib_free_pages() in the
hw_free callback as usual.
Vmalloc&#39;ed Buffers
It&#39;s possible to use a buffer allocated via
vmalloc, for example, for an intermediate
buffer. Since the allocated pages are not contiguous, you need
to set the page callback to obtain
the physical address at every offset.

The implementation of page callback
would be like this:


#include &amp;lt;linux/vmalloc.h&amp;gt;

/* get the physical page pointer on the given offset */
static struct page *mychip_page(struct snd_pcm_substream *substream,
unsigned long offset)
{
void *pageptr = substream-&amp;gt;runtime-&amp;gt;dma_area + offset;
return vmalloc_to_page(pageptr);
}


&lt;!-- ****************************************************** --&gt;&lt;!-- Proc Interface  --&gt;&lt;!-- ****************************************************** --&gt;Proc Interface
ALSA provides an easy interface for procfs. The proc files are
very useful for debugging. I recommend you set up proc files if
you write a driver and want to get a running status or register
dumps. The API is found in
&amp;lt;sound/info.h&amp;gt;.

To create a proc file, call
snd_card_proc_new().


struct snd_info_entry *entry;
int err = snd_card_proc_new(card, &quot;my-file&quot;, &amp;amp;entry);



where the second argument specifies the name of the proc file to be
created. The above example will create a file
my-file under the card directory,
e.g. /proc/asound/card0/my-file.

Like other components, the proc entry created via
snd_card_proc_new() will be registered and
released automatically in the card registration and release
functions.

When the creation is successful, the function stores a new
instance in the pointer given in the third argument.
It is initialized as a text proc file for read only.  To use
this proc file as a read-only text file as it is, set the read
callback with a private data via
snd_info_set_text_ops().


snd_info_set_text_ops(entry, chip, my_proc_read);



where the second argument (chip) is the
private data to be used in the callbacks. The third parameter
specifies the read buffer size and the fourth
(my_proc_read) is the callback function, which
is defined like


static void my_proc_read(struct snd_info_entry *entry,
struct snd_info_buffer *buffer);




In the read callback, use snd_iprintf() for
output strings, which works just like normal
printf().  For example,


static void my_proc_read(struct snd_info_entry *entry,
struct snd_info_buffer *buffer)
{
struct my_chip *chip = entry-&amp;gt;private_data;

snd_iprintf(buffer, &quot;This is my chip!\n&quot;);
snd_iprintf(buffer, &quot;Port = %ld\n&quot;, chip-&amp;gt;port);
}



The file permissions can be changed afterwards.  As default, it&#39;s
set as read only for all users.  If you want to add write
permission for the user (root as default), do as follows:


entry-&amp;gt;mode = S_IFREG | S_IRUGO | S_IWUSR;



and set the write buffer size and the callback


entry-&amp;gt;c.text.write = my_proc_write;



For the write callback, you can use
snd_info_get_line() to get a text line, and
snd_info_get_str() to retrieve a string from
the line. Some examples are found in
core/oss/mixer_oss.c, core/oss/and
pcm_oss.c.

For a raw-data proc-file, set the attributes as follows:


static struct snd_info_entry_ops my_file_io_ops = {
.read = my_file_io_read,
};

entry-&amp;gt;content = SNDRV_INFO_CONTENT_DATA;
entry-&amp;gt;private_data = chip;
entry-&amp;gt;c.ops = &amp;amp;my_file_io_ops;
entry-&amp;gt;size = 4096;
entry-&amp;gt;mode = S_IFREG | S_IRUGO;



For the raw data, size field must be
set properly.  This specifies the maximum size of the proc file access.

The read/write callbacks of raw mode are more direct than the text mode.
You need to use a low-level I/O functions such as
copy_from/to_user() to transfer the
data.


static ssize_t my_file_io_read(struct snd_info_entry *entry,
void *file_private_data,
struct file *file,
char *buf,
size_t count,
loff_t pos)
{
if (copy_to_user(buf, local_data + pos, count))
return -EFAULT;
return count;
}



If the size of the info entry has been set up properly,
count and pos are
guaranteed to fit within 0 and the given size.
You don&#39;t have to check the range in the callbacks unless any
other condition is required.

&lt;!-- ****************************************************** --&gt;&lt;!-- Power Management  --&gt;&lt;!-- ****************************************************** --&gt;Power Management
If the chip is supposed to work with suspend/resume
functions, you need to add power-management code to the
driver. The additional code for power-management should be
ifdef&#39;ed with
CONFIG_PM.

If the driver fully supports suspend/resume
that is, the device can be
properly resumed to its state when suspend was called,
you can set the SNDRV_PCM_INFO_RESUME flag
in the pcm info field.  Usually, this is possible when the
registers of the chip can be safely saved and restored to
RAM. If this is set, the trigger callback is called with
SNDRV_PCM_TRIGGER_RESUME after the resume
callback completes.

Even if the driver doesn&#39;t support PM fully but
partial suspend/resume is still possible, it&#39;s still worthy to
implement suspend/resume callbacks. In such a case, applications
would reset the status by calling
snd_pcm_prepare() and restart the stream
appropriately.  Hence, you can define suspend/resume callbacks
below but don&#39;t set SNDRV_PCM_INFO_RESUME
info flag to the PCM.

Note that the trigger with SUSPEND can always be called when
snd_pcm_suspend_all is called,
regardless of the SNDRV_PCM_INFO_RESUME flag.
The RESUME flag affects only the behavior
of snd_pcm_resume().
(Thus, in theory,
SNDRV_PCM_TRIGGER_RESUME isn&#39;t needed
to be handled in the trigger callback when no
SNDRV_PCM_INFO_RESUME flag is set.  But,
it&#39;s better to keep it for compatibility reasons.)

In the earlier version of ALSA drivers, a common
power-management layer was provided, but it has been removed.
The driver needs to define the suspend/resume hooks according to
the bus the device is connected to.  In the case of PCI drivers, the
callbacks look like below:


#ifdef CONFIG_PM
static int snd_my_suspend(struct pci_dev *pci, pm_message_t state)
{
.... /* do things for suspend */
return 0;
}
static int snd_my_resume(struct pci_dev *pci)
{
.... /* do things for suspend */
return 0;
}
#endif



The scheme of the real suspend job is as follows.

Retrieve the card and the chip data.Call snd_power_change_state() with
SNDRV_CTL_POWER_D3hot to change the
power status.Call snd_pcm_suspend_all() to suspend the running PCM streams.If AC97 codecs are used, call
snd_ac97_suspend() for each codec.Save the register values if necessary.Stop the hardware if necessary.Disable the PCI device by calling
pci_disable_device().  Then, call
pci_save_state() at last.

A typical code would be like:


static int mychip_suspend(struct pci_dev *pci, pm_message_t state)
{
/* (1) */
struct snd_card *card = pci_get_drvdata(pci);
struct mychip *chip = card-&amp;gt;private_data;
/* (2) */
snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
/* (3) */
snd_pcm_suspend_all(chip-&amp;gt;pcm);
/* (4) */
snd_ac97_suspend(chip-&amp;gt;ac97);
/* (5) */
snd_mychip_save_registers(chip);
/* (6) */
snd_mychip_stop_hardware(chip);
/* (7) */
pci_disable_device(pci);
pci_save_state(pci);
return 0;
}



The scheme of the real resume job is as follows.

Retrieve the card and the chip data.Set up PCI. First, call pci_restore_state().
Then enable the pci device again by calling pci_enable_device().
Call pci_set_master() if necessary, too.Re-initialize the chip.Restore the saved registers if necessary.Resume the mixer, e.g. calling
snd_ac97_resume().Restart the hardware (if any).Call snd_power_change_state() with
SNDRV_CTL_POWER_D0 to notify the processes.

A typical code would be like:


static int mychip_resume(struct pci_dev *pci)
{
/* (1) */
struct snd_card *card = pci_get_drvdata(pci);
struct mychip *chip = card-&amp;gt;private_data;
/* (2) */
pci_restore_state(pci);
pci_enable_device(pci);
pci_set_master(pci);
/* (3) */
snd_mychip_reinit_chip(chip);
/* (4) */
snd_mychip_restore_registers(chip);
/* (5) */
snd_ac97_resume(chip-&amp;gt;ac97);
/* (6) */
snd_mychip_restart_chip(chip);
/* (7) */
snd_power_change_state(card, SNDRV_CTL_POWER_D0);
return 0;
}



As shown in the above, it&#39;s better to save registers after
suspending the PCM operations via
snd_pcm_suspend_all() or
snd_pcm_suspend().  It means that the PCM
streams are already stoppped when the register snapshot is
taken.  But, remember that you don&#39;t have to restart the PCM
stream in the resume callback. It&#39;ll be restarted via
trigger call with SNDRV_PCM_TRIGGER_RESUME
when necessary.

OK, we have all callbacks now. Let&#39;s set them up. In the
initialization of the card, make sure that you can get the chip
data from the card instance, typically via
private_data field, in case you
created the chip data individually.


static int snd_mychip_probe(struct pci_dev *pci,
const struct pci_device_id *pci_id)
{
....
struct snd_card *card;
struct mychip *chip;
int err;
....
err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;amp;card);
....
chip = kzalloc(sizeof(*chip), GFP_KERNEL);
....
card-&amp;gt;private_data = chip;
....
}



When you created the chip data with
snd_card_create(), it&#39;s anyway accessible
via private_data field.


static int snd_mychip_probe(struct pci_dev *pci,
const struct pci_device_id *pci_id)
{
....
struct snd_card *card;
struct mychip *chip;
int err;
....
err = snd_card_create(index[dev], id[dev], THIS_MODULE,
sizeof(struct mychip), &amp;amp;card);
....
chip = card-&amp;gt;private_data;
....
}




If you need a space to save the registers, allocate the
buffer for it here, too, since it would be fatal
if you cannot allocate a memory in the suspend phase.
The allocated buffer should be released in the corresponding
destructor.

And next, set suspend/resume callbacks to the pci_driver.


static struct pci_driver driver = {
.name = KBUILD_MODNAME,
.id_table = snd_my_ids,
.probe = snd_my_probe,
.remove = snd_my_remove,
#ifdef CONFIG_PM
.suspend = snd_my_suspend,
.resume = snd_my_resume,
#endif
};


&lt;!-- ****************************************************** --&gt;&lt;!-- Module Parameters  --&gt;&lt;!-- ****************************************************** --&gt;Module Parameters
There are standard module options for ALSA. At least, each
module should have the index,
id and enable
options.

If the module supports multiple cards (usually up to
8 = SNDRV_CARDS cards), they should be
arrays. The default initial values are defined already as
constants for easier programming:


static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;



If the module supports only a single card, they could be single
variables, instead.  enable option is not
always necessary in this case, but it would be better to have a
dummy option for compatibility.

The module parameters must be declared with the standard
module_param()(),
module_param_array()() and
MODULE_PARM_DESC() macros.

The typical coding would be like below:


#define CARD_NAME &quot;My Chip&quot;

module_param_array(index, int, NULL, 0444);
MODULE_PARM_DESC(index, &quot;Index value for &quot; CARD_NAME &quot; soundcard.&quot;);
module_param_array(id, charp, NULL, 0444);
MODULE_PARM_DESC(id, &quot;ID string for &quot; CARD_NAME &quot; soundcard.&quot;);
module_param_array(enable, bool, NULL, 0444);
MODULE_PARM_DESC(enable, &quot;Enable &quot; CARD_NAME &quot; soundcard.&quot;);



Also, don&#39;t forget to define the module description, classes,
license and devices. Especially, the recent modprobe requires to
define the module license as GPL, etc., otherwise the system is
shown as tainted.


MODULE_DESCRIPTION(&quot;My Chip&quot;);
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_SUPPORTED_DEVICE(&quot;{{Vendor,My Chip Name}}&quot;);


&lt;!-- ****************************************************** --&gt;&lt;!-- How To Put Your Driver  --&gt;&lt;!-- ****************************************************** --&gt;How To Put Your Driver Into ALSA TreeGeneral
So far, you&#39;ve learned how to write the driver codes.
And you might have a question now: how to put my own
driver into the ALSA driver tree?
Here (finally :) the standard procedure is described briefly.

Suppose that you create a new PCI driver for the card
xyz.  The card module name would be
snd-xyz.  The new driver is usually put into the alsa-driver
tree, alsa-driver/pci directory in
the case of PCI cards.
Then the driver is evaluated, audited and tested
by developers and users.  After a certain time, the driver
will go to the alsa-kernel tree (to the corresponding directory,
such as alsa-kernel/pci) and eventually
will be integrated into the Linux 2.6 tree (the directory would be
linux/sound/pci).

In the following sections, the driver code is supposed
to be put into alsa-driver tree. The two cases are covered:
a driver consisting of a single source file and one consisting
of several source files.
Driver with A Single Source File
Modify alsa-driver/pci/Makefile

Suppose you have a file xyz.c.  Add the following
two lines

snd-xyz-objs := xyz.o
obj-$(CONFIG_SND_XYZ) += snd-xyz.o



Create the Kconfig entry

Add the new entry of Kconfig for your xyz driver.

config SND_XYZ
tristate &quot;Foobar XYZ&quot;
depends on SND
select SND_PCM
help
Say Y here to include support for Foobar XYZ soundcard.

To compile this driver as a module, choose M here: the module
will be called snd-xyz.



the line, select SND_PCM, specifies that the driver xyz supports
PCM.  In addition to SND_PCM, the following components are
supported for select command:
SND_RAWMIDI, SND_TIMER, SND_HWDEP, SND_MPU401_UART,
SND_OPL3_LIB, SND_OPL4_LIB, SND_VX_LIB, SND_AC97_CODEC.
Add the select command for each supported component.

Note that some selections imply the lowlevel selections.
For example, PCM includes TIMER, MPU401_UART includes RAWMIDI,
AC97_CODEC includes PCM, and OPL3_LIB includes HWDEP.
You don&#39;t need to give the lowlevel selections again.

For the details of Kconfig script, refer to the kbuild
documentation.

Run cvscompile script to re-generate the configure script and
build the whole stuff again.
Drivers with Several Source Files
Suppose that the driver snd-xyz have several source files.
They are located in the new subdirectory,
pci/xyz.


Add a new directory (xyz) in
alsa-driver/pci/Makefile as below


obj-$(CONFIG_SND) += xyz/



Under the directory xyz, create a Makefile

Sample Makefile for a driver xyz
ifndef SND_TOPDIR
SND_TOPDIR=../..
endif

include $(SND_TOPDIR)/toplevel.config
include $(SND_TOPDIR)/Makefile.conf

snd-xyz-objs := xyz.o abc.o def.o

obj-$(CONFIG_SND_XYZ) += snd-xyz.o

include $(SND_TOPDIR)/Rules.make



Create the Kconfig entry

This procedure is as same as in the last section.

Run cvscompile script to re-generate the configure script and
build the whole stuff again.

&lt;!-- ****************************************************** --&gt;&lt;!-- Useful Functions  --&gt;&lt;!-- ****************************************************** --&gt;Useful Functionssnd_printk() and friends
ALSA provides a verbose version of the
printk() function. If a kernel config
CONFIG_SND_VERBOSE_PRINTK is set, this
function prints the given message together with the file name
and the line of the caller. The KERN_XXX
prefix is processed as
well as the original printk() does, so it&#39;s
recommended to add this prefix, e.g.


snd_printk(KERN_ERR &quot;Oh my, sorry, it&#39;s extremely bad!\n&quot;);



There are also printk()&#39;s for
debugging. snd_printd() can be used for
general debugging purposes. If
CONFIG_SND_DEBUG is set, this function is
compiled, and works just like
snd_printk(). If the ALSA is compiled
without the debugging flag, it&#39;s ignored.
snd_printdd() is compiled in only when
CONFIG_SND_DEBUG_VERBOSE is set. Please note
that CONFIG_SND_DEBUG_VERBOSE is not set as default
even if you configure the alsa-driver with
--with-debug=full option. You need to give
explicitly --with-debug=detect option instead.
snd_BUG()
It shows the BUG? message and
stack trace as well as snd_BUG_ON at the point.
It&#39;s useful to show that a fatal error happens there.

When no debug flag is set, this macro is ignored.
snd_BUG_ON()snd_BUG_ON() macro is similar with
WARN_ON() macro. For example,


snd_BUG_ON(!pointer);



or it can be used as the condition,

if (snd_BUG_ON(non_zero_is_bug))
return -EINVAL;




The macro takes an conditional expression to evaluate.
When CONFIG_SND_DEBUG, is set, if the
expression is non-zero, it shows the warning message such as
BUG? (xxx)
normally followed by stack trace.

In both cases it returns the evaluated value.
&lt;!-- ****************************************************** --&gt;&lt;!-- Acknowledgments  --&gt;&lt;!-- ****************************************************** --&gt;Acknowledgments
I would like to thank Phil Kerr for his help for improvement and
corrections of this document.

Kevin Conder reformatted the original plain-text to the
DocBook format.

Giuliano Pochini corrected typos and contributed the example codes
in the hardware constraints section.
Writing USB Device DriversGregKroah-Hartmangreg@kroah.com2001-2002Greg Kroah-Hartman
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.

This documentation is based on an article published in
Linux Journal Magazine, October 2001, Issue 90.
Introduction
The Linux USB subsystem has grown from supporting only two different
types of devices in the 2.2.7 kernel (mice and keyboards), to over 20
different types of devices in the 2.4 kernel. Linux currently supports
almost all USB class devices (standard types of devices like keyboards,
mice, modems, printers and speakers) and an ever-growing number of
vendor-specific devices (such as USB to serial converters, digital
cameras, Ethernet devices and MP3 players). For a full list of the
different USB devices currently supported, see Resources.

The remaining kinds of USB devices that do not have support on Linux are
almost all vendor-specific devices. Each vendor decides to implement a
custom protocol to talk to their device, so a custom driver usually needs
to be created. Some vendors are open with their USB protocols and help
with the creation of Linux drivers, while others do not publish them, and
developers are forced to reverse-engineer. See Resources for some links
to handy reverse-engineering tools.

Because each different protocol causes a new driver to be created, I have
written a generic USB driver skeleton, modelled after the pci-skeleton.c
file in the kernel source tree upon which many PCI network drivers have
been based. This USB skeleton can be found at drivers/usb/usb-skeleton.c
in the kernel source tree. In this article I will walk through the basics
of the skeleton driver, explaining the different pieces and what needs to
be done to customize it to your specific device.
Linux USB Basics
If you are going to write a Linux USB driver, please become familiar with
the USB protocol specification. It can be found, along with many other
useful documents, at the USB home page (see Resources). An excellent
introduction to the Linux USB subsystem can be found at the USB Working
Devices List (see Resources). It explains how the Linux USB subsystem is
structured and introduces the reader to the concept of USB urbs
(USB Request Blocks), which are essential to USB drivers.

The first thing a Linux USB driver needs to do is register itself with
the Linux USB subsystem, giving it some information about which devices
the driver supports and which functions to call when a device supported
by the driver is inserted or removed from the system. All of this
information is passed to the USB subsystem in the usb_driver structure.
The skeleton driver declares a usb_driver as:

static struct usb_driver skel_driver = {
.name        = &quot;skeleton&quot;,
.probe       = skel_probe,
.disconnect  = skel_disconnect,
.fops        = &amp;amp;skel_fops,
.minor       = USB_SKEL_MINOR_BASE,
.id_table    = skel_table,
};

The variable name is a string that describes the driver. It is used in
informational messages printed to the system log. The probe and
disconnect function pointers are called when a device that matches the
information provided in the id_table variable is either seen or removed.

The fops and minor variables are optional. Most USB drivers hook into
another kernel subsystem, such as the SCSI, network or TTY subsystem.
These types of drivers register themselves with the other kernel
subsystem, and any user-space interactions are provided through that
interface. But for drivers that do not have a matching kernel subsystem,
such as MP3 players or scanners, a method of interacting with user space
is needed. The USB subsystem provides a way to register a minor device
number and a set of file_operations function pointers that enable this
user-space interaction. The skeleton driver needs this kind of interface,
so it provides a minor starting number and a pointer to its
file_operations functions.

The USB driver is then registered with a call to usb_register, usually in
the driver&#39;s init function, as shown here:

static int __init usb_skel_init(void)
{
int result;

/* register this driver with the USB subsystem */
result = usb_register(&amp;amp;skel_driver);
if (result &amp;lt; 0) {
err(&quot;usb_register failed for the &quot;__FILE__ &quot;driver.&quot;
&quot;Error number %d&quot;, result);
return -1;
}

return 0;
}
module_init(usb_skel_init);

When the driver is unloaded from the system, it needs to deregister
itself with the USB subsystem. This is done with the usb_deregister
function:

static void __exit usb_skel_exit(void)
{
/* deregister this driver with the USB subsystem */
usb_deregister(&amp;amp;skel_driver);
}
module_exit(usb_skel_exit);

To enable the linux-hotplug system to load the driver automatically when
the device is plugged in, you need to create a MODULE_DEVICE_TABLE. The
following code tells the hotplug scripts that this module supports a
single device with a specific vendor and product ID:

/* table of devices that work with this driver */
static struct usb_device_id skel_table [] = {
{ USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
{ }                      /* Terminating entry */
};
MODULE_DEVICE_TABLE (usb, skel_table);

There are other macros that can be used in describing a usb_device_id for
drivers that support a whole class of USB drivers. See usb.h for more
information on this.
Device operation
When a device is plugged into the USB bus that matches the device ID
pattern that your driver registered with the USB core, the probe function
is called. The usb_device structure, interface number and the interface ID
are passed to the function:

static int skel_probe(struct usb_interface *interface,
const struct usb_device_id *id)

The driver now needs to verify that this device is actually one that it
can accept. If so, it returns 0.
If not, or if any error occurs during initialization, an errorcode
(such as -ENOMEM or -ENODEV)
is returned from the probe function.

In the skeleton driver, we determine what end points are marked as bulk-in
and bulk-out. We create buffers to hold the data that will be sent and
received from the device, and a USB urb to write data to the device is
initialized.

Conversely, when the device is removed from the USB bus, the disconnect
function is called with the device pointer. The driver needs to clean any
private data that has been allocated at this time and to shut down any
pending urbs that are in the USB system.

Now that the device is plugged into the system and the driver is bound to
the device, any of the functions in the file_operations structure that
were passed to the USB subsystem will be called from a user program trying
to talk to the device. The first function called will be open, as the
program tries to open the device for I/O. We increment our private usage
count and save a pointer to our internal structure in the file
structure. This is done so that future calls to file operations will
enable the driver to determine which device the user is addressing.  All
of this is done with the following code:

/* increment our usage count for the module */
++skel-&amp;gt;open_count;

/* save our object in the file&#39;s private structure */
file-&amp;gt;private_data = dev;

After the open function is called, the read and write functions are called
to receive and send data to the device. In the skel_write function, we
receive a pointer to some data that the user wants to send to the device
and the size of the data. The function determines how much data it can
send to the device based on the size of the write urb it has created (this
size depends on the size of the bulk out end point that the device has).
Then it copies the data from user space to kernel space, points the urb to
the data and submits the urb to the USB subsystem.  This can be seen in
the following code:

/* we can only write as much as 1 urb will hold */
bytes_written = (count &amp;gt; skel-&amp;gt;bulk_out_size) ? skel-&amp;gt;bulk_out_size : count;

/* copy the data from user space into our urb */
copy_from_user(skel-&amp;gt;write_urb-&amp;gt;transfer_buffer, buffer, bytes_written);

/* set up our urb */
usb_fill_bulk_urb(skel-&amp;gt;write_urb,
skel-&amp;gt;dev,
usb_sndbulkpipe(skel-&amp;gt;dev, skel-&amp;gt;bulk_out_endpointAddr),
skel-&amp;gt;write_urb-&amp;gt;transfer_buffer,
bytes_written,
skel_write_bulk_callback,
skel);

/* send the data out the bulk port */
result = usb_submit_urb(skel-&amp;gt;write_urb);
if (result) {
err(&quot;Failed submitting write urb, error %d&quot;, result);
}

When the write urb is filled up with the proper information using the
usb_fill_bulk_urb function, we point the urb&#39;s completion callback to call our
own skel_write_bulk_callback function. This function is called when the
urb is finished by the USB subsystem. The callback function is called in
interrupt context, so caution must be taken not to do very much processing
at that time. Our implementation of skel_write_bulk_callback merely
reports if the urb was completed successfully or not and then returns.

The read function works a bit differently from the write function in that
we do not use an urb to transfer data from the device to the driver.
Instead we call the usb_bulk_msg function, which can be used to send or
receive data from a device without having to create urbs and handle
urb completion callback functions. We call the usb_bulk_msg function,
giving it a buffer into which to place any data received from the device
and a timeout value. If the timeout period expires without receiving any
data from the device, the function will fail and return an error message.
This can be shown with the following code:

/* do an immediate bulk read to get data from the device */
retval = usb_bulk_msg (skel-&amp;gt;dev,
usb_rcvbulkpipe (skel-&amp;gt;dev,
skel-&amp;gt;bulk_in_endpointAddr),
skel-&amp;gt;bulk_in_buffer,
skel-&amp;gt;bulk_in_size,
&amp;amp;count, HZ*10);
/* if the read was successful, copy the data to user space */
if (!retval) {
if (copy_to_user (buffer, skel-&amp;gt;bulk_in_buffer, count))
retval = -EFAULT;
else
retval = count;
}

The usb_bulk_msg function can be very useful for doing single reads or
writes to a device; however, if you need to read or write constantly to a
device, it is recommended to set up your own urbs and submit them to the
USB subsystem.

When the user program releases the file handle that it has been using to
talk to the device, the release function in the driver is called. In this
function we decrement our private usage count and wait for possible
pending writes:

/* decrement our usage count for the device */
--skel-&amp;gt;open_count;

One of the more difficult problems that USB drivers must be able to handle
smoothly is the fact that the USB device may be removed from the system at
any point in time, even if a program is currently talking to it. It needs
to be able to shut down any current reads and writes and notify the
user-space programs that the device is no longer there. The following
code (function skel_delete)
is an example of how to do this:
static inline void skel_delete (struct usb_skel *dev)
{
kfree (dev-&amp;gt;bulk_in_buffer);
if (dev-&amp;gt;bulk_out_buffer != NULL)
usb_free_coherent (dev-&amp;gt;udev, dev-&amp;gt;bulk_out_size,
dev-&amp;gt;bulk_out_buffer,
dev-&amp;gt;write_urb-&amp;gt;transfer_dma);
usb_free_urb (dev-&amp;gt;write_urb);
kfree (dev);
}

If a program currently has an open handle to the device, we reset the flag
device_present. For
every read, write, release and other functions that expect a device to be
present, the driver first checks this flag to see if the device is
still present. If not, it releases that the device has disappeared, and a
-ENODEV error is returned to the user-space program. When the release
function is eventually called, it determines if there is no device
and if not, it does the cleanup that the skel_disconnect
function normally does if there are no open files on the device (see
Listing 5).
Isochronous Data
This usb-skeleton driver does not have any examples of interrupt or
isochronous data being sent to or from the device. Interrupt data is sent
almost exactly as bulk data is, with a few minor exceptions.  Isochronous
data works differently with continuous streams of data being sent to or
from the device. The audio and video camera drivers are very good examples
of drivers that handle isochronous data and will be useful if you also
need to do this.
Conclusion
Writing Linux USB device drivers is not a difficult task as the
usb-skeleton driver shows. This driver, combined with the other current
USB drivers, should provide enough examples to help a beginning author
create a working driver in a minimal amount of time. The linux-usb-devel
mailing list archives also contain a lot of helpful information.
Resources
The Linux USB Project: http://www.linux-usb.org/

Linux Hotplug Project: http://linux-hotplug.sourceforge.net/

Linux USB Working Devices List: http://www.qbik.ch/usb/devices/

linux-usb-devel Mailing List Archives: http://marc.theaimsgroup.com/?l=linux-usb-devel

Programming Guide for Linux USB Device Drivers: http://usb.cs.tum.edu/usbdoc

USB Home Page: http://www.usb.org
Z8530 Programming GuideAlanCoxalan@lxorguk.ukuu.org.uk2000Alan Cox
This documentation is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307 USA

For more details see the file COPYING in the source
distribution of Linux.
Introduction
The Z85x30 family synchronous/asynchronous controller chips are
used on a large number of cheap network interface cards. The
kernel provides a core interface layer that is designed to make
it easy to provide WAN services using this chip.

The current driver only support synchronous operation. Merging the
asynchronous driver support into this code to allow any Z85x30
device to be used as both a tty interface and as a synchronous
controller is a project for Linux post the 2.4 release
Driver Modes
The Z85230 driver layer can drive Z8530, Z85C30 and Z85230 devices
in three different modes. Each mode can be applied to an individual
channel on the chip (each chip has two channels).

The PIO synchronous mode supports the most common Z8530 wiring. Here
the chip is interface to the I/O and interrupt facilities of the
host machine but not to the DMA subsystem. When running PIO the
Z8530 has extremely tight timing requirements. Doing high speeds,
even with a Z85230 will be tricky. Typically you should expect to
achieve at best 9600 baud with a Z8C530 and 64Kbits with a Z85230.

The DMA mode supports the chip when it is configured to use dual DMA
channels on an ISA bus. The better cards tend to support this mode
of operation for a single channel. With DMA running the Z85230 tops
out when it starts to hit ISA DMA constraints at about 512Kbits. It
is worth noting here that many PC machines hang or crash when the
chip is driven fast enough to hold the ISA bus solid.

Transmit DMA mode uses a single DMA channel. The DMA channel is used
for transmission as the transmit FIFO is smaller than the receive
FIFO. it gives better performance than pure PIO mode but is nowhere
near as ideal as pure DMA mode.
Using the Z85230 driver
The Z85230 driver provides the back end interface to your board. To
configure a Z8530 interface you need to detect the board and to
identify its ports and interrupt resources. It is also your problem
to verify the resources are available.

Having identified the chip you need to fill in a struct z8530_dev,
which describes each chip. This object must exist until you finally
shutdown the board. Firstly zero the active field. This ensures
nothing goes off without you intending it. The irq field should
be set to the interrupt number of the chip. (Each chip has a single
interrupt source rather than each channel). You are responsible
for allocating the interrupt line. The interrupt handler should be
set to z8530_interrupt. The device id should
be set to the z8530_dev structure pointer. Whether the interrupt can
be shared or not is board dependent, and up to you to initialise.

The structure holds two channel structures.
Initialise chanA.ctrlio and chanA.dataio with the address of the
control and data ports. You can or this with Z8530_PORT_SLEEP to
indicate your interface needs the 5uS delay for chip settling done
in software. The PORT_SLEEP option is architecture specific. Other
flags may become available on future platforms, eg for MMIO.
Initialise the chanA.irqs to &amp;amp;z8530_nop to start the chip up
as disabled and discarding interrupt events. This ensures that
stray interrupts will be mopped up and not hang the bus. Set
chanA.dev to point to the device structure itself. The
private and name field you may use as you wish. The private field
is unused by the Z85230 layer. The name is used for error reporting
and it may thus make sense to make it match the network name.

Repeat the same operation with the B channel if your chip has
both channels wired to something useful. This isn&#39;t always the
case. If it is not wired then the I/O values do not matter, but
you must initialise chanB.dev.

If your board has DMA facilities then initialise the txdma and
rxdma fields for the relevant channels. You must also allocate the
ISA DMA channels and do any necessary board level initialisation
to configure them. The low level driver will do the Z8530 and
DMA controller programming but not board specific magic.

Having initialised the device you can then call
z8530_init. This will probe the chip and
reset it into a known state. An identification sequence is then
run to identify the chip type. If the checks fail to pass the
function returns a non zero error code. Typically this indicates
that the port given is not valid. After this call the
type field of the z8530_dev structure is initialised to either
Z8530, Z85C30 or Z85230 according to the chip found.

Once you have called z8530_init you can also make use of the utility
function z8530_describe. This provides a
consistent reporting format for the Z8530 devices, and allows all
the drivers to provide consistent reporting.
Attaching Network Interfaces
If you wish to use the network interface facilities of the driver,
then you need to attach a network device to each channel that is
present and in use. In addition to use the generic HDLC
you need to follow some additional plumbing rules. They may seem
complex but a look at the example hostess_sv11 driver should
reassure you.

The network device used for each channel should be pointed to by
the netdevice field of each channel. The hdlc-&amp;gt; priv field of the
network device points to your private data - you will need to be
able to find your private data from this.

The way most drivers approach this particular problem is to
create a structure holding the Z8530 device definition and
put that into the private field of the network device. The
network device fields of the channels then point back to the
network devices.

If you wish to use the generic HDLC then you need to register
the HDLC device.

Before you register your network device you will also need to
provide suitable handlers for most of the network device callbacks.
See the network device documentation for more details on this.
Configuring And Activating The Port
The Z85230 driver provides helper functions and tables to load the
port registers on the Z8530 chips. When programming the register
settings for a channel be aware that the documentation recommends
initialisation orders. Strange things happen when these are not
followed.
z8530_channel_load takes an array of
pairs of initialisation values in an array of u8 type. The first
value is the Z8530 register number. Add 16 to indicate the alternate
register bank on the later chips. The array is terminated by a 255.

The driver provides a pair of public tables. The
z8530_hdlc_kilostream table is for the UK &#39;Kilostream&#39; service and
also happens to cover most other end host configurations. The
z8530_hdlc_kilostream_85230 table is the same configuration using
the enhancements of the 85230 chip. The configuration loaded is
standard NRZ encoded synchronous data with HDLC bitstuffing. All
of the timing is taken from the other end of the link.

When writing your own tables be aware that the driver internally
tracks register values. It may need to reload values. You should
therefore be sure to set registers 1-7, 9-11, 14 and 15 in all
configurations. Where the register settings depend on DMA selection
the driver will update the bits itself when you open or close.
Loading a new table with the interface open is not recommended.

There are three standard configurations supported by the core
code. In PIO mode the interface is programmed up to use
interrupt driven PIO. This places high demands on the host processor
to avoid latency. The driver is written to take account of latency
issues but it cannot avoid latencies caused by other drivers,
notably IDE in PIO mode. Because the drivers allocate buffers you
must also prevent MTU changes while the port is open.

Once the port is open it will call the rx_function of each channel
whenever a completed packet arrived. This is invoked from
interrupt context and passes you the channel and a network
buffer (struct sk_buff) holding the data. The data includes
the CRC bytes so most users will want to trim the last two
bytes before processing the data. This function is very timing
critical. When you wish to simply discard data the support
code provides the function z8530_null_rx
to discard the data.

To active PIO mode sending and receiving the
z8530_sync_open is called. This expects to be passed
the network device and the channel. Typically this is called from
your network device open callback. On a failure a non zero error
status is returned. The z8530_sync_close
function shuts down a PIO channel. This must be done before the
channel is opened again    and before the driver shuts down
and unloads.

The ideal mode of operation is dual channel DMA mode. Here the
kernel driver will configure the board for DMA in both directions.
The driver also handles ISA DMA issues such as controller
programming and the memory range limit for you. This mode is
activated by calling the z8530_sync_dma_open
function. On failure a non zero error value is returned.
Once this mode is activated it can be shut down by calling the
z8530_sync_dma_close. You must call the close
function matching the open mode you used.

The final supported mode uses a single DMA channel to drive the
transmit side. As the Z85C30 has a larger FIFO on the receive
channel    this tends to increase the maximum speed a little.
This is activated by calling the z8530_sync_txdma_open
. This returns a non zero error code on failure. The
z8530_sync_txdma_close function closes down
the Z8530 interface from this mode.
Network Layer Functions
The Z8530 layer provides functions to queue packets for
transmission. The driver internally buffers the frame currently
being transmitted and one further frame (in order to keep back
to back transmission running). Any further buffering is up to
the caller.

The function z8530_queue_xmit takes a network
buffer in sk_buff format and queues it for transmission. The
caller must provide the entire packet with the exception of the
bitstuffing and CRC. This is normally done by the caller via
the generic HDLC interface layer. It returns 0 if the buffer has been
queued and non zero values for queue full. If the function accepts
the buffer it becomes property of the Z8530 layer and the caller
should not free it.

The function z8530_get_stats returns a pointer
to an internally maintained per interface statistics block. This
provides most of the interface code needed to implement the network
layer get_stats callback.
Porting The Z8530 Driver
The Z8530 driver is written to be portable. In DMA mode it makes
assumptions about the use of ISA DMA. These are probably warranted
in most cases as the Z85230 in particular was designed to glue to PC
type machines. The PIO mode makes no real assumptions.

Should you need to retarget the Z8530 driver to another architecture
the only code that should need changing are the port I/O functions.
At the moment these assume PC I/O port accesses. This may not be
appropriate for all platforms. Replacing
z8530_read_port and z8530_write_port
is intended to be all that is required to port this
driver layer.
Known Bugs And AssumptionsInterrupt Locking
The locking in the driver is done via the global cli/sti lock. This
makes for relatively poor SMP performance. Switching this to use a
per device spin lock would probably materially improve performance.
Occasional Failures
We have reports of occasional failures when run for very long
periods of time and the driver starts to receive junk frames. At
the moment the cause of this is not clear.
Public Functions Provided
Internal Functions

</plainxml>
