<?xml version="1.0" encoding="utf-8" ?>
<plainxml>$Date: 2001-08-02 14:27:50 +0400 (Чт, 02 авг 2001) $ $Revision: 546 $ Installation Installing the DocBook DTD DocBook DTD installation 

This appendix describes how to install the DocBook DTD on your system
so that popular command-line tools like  SP  can
use it. If you are installing DocBook for use with a commercial application,
consult the documentation for your application as well. 
This appendix describes the installation of DocBook V3.1. If you are using
another distribution, the process should be about the same, but there
may be minor differences.  DocBook V3.1 is backward compatible with DocBook
V3.0, and is the recommended distribution at the time of this writing.
 Unpacking the DocBook V3.1 Distribution DocBook DTD online copies 
DocBook is distributed on the  DocBook web
site . You will also find a copy of the distribution on
the  CD-ROM . files DocBook DTD distribution 

The distribution consists of 14 files: 31chg.txt Describes the changes in DocBook
V3.1 from the preceding version (3.0) 40issues.txt Summarizes backwards-incompatible
changes planned for DocBook V4.0 50issues.txt Summarizes backwards-incompatible
changes planned for DocBook V5.0 cals-tbl.dtd The CALS Table Model DTD ChangeLog A GNU-style ChangeLog
summarizing the individual edits made on each file in the distribution
since V3.0.
 dbcent.mod The character entity module
 dbgenent.mod The general entity module
 dbhier.mod The document hierarchy module dbnotn.mod The notations module dbpool.mod The information pool module
 docbook.cat A sample OASIS catalog
for DocBook docbook.dcl An SGML Declaration suitable
for DocBook docbook.dtd The DocBook DTD readme.txt The DocBook V3.1  readme  file Unpack the distribution into a directory on your system. The exact location
is irrelevant. On UNIX systems it&#39;s common to put it somewhere under  
/usr/local  or  /share  (for example,  /usr/local/sgml/docbook  or  /share/sgml/docbook ).
On a PC, perhaps  c:\sgml\docbook . Getting the ISO Entity Sets entity sets ISO standard, obtaining entities entity sets entity sets ISO standards entity sets obtaining OASIS entity sets (ISO standard), obtaining 

DocBook refers to a number of standard entity sets that
are not distributed with DocBook. (They aren&#39;t distributed with
DocBook because they aren&#39;t maintained by the DocBook
TC. They&#39;re maintained by ISO.) If you&#39;ve installed other SGML
DTDs or tools, they may already be on your system. If you are missing some of them, they are available from
Robin Cover&#39;s pages at OASIS:  
http://www.oasis-open.org/cover/ISOEnts.zip . The names of the entity files in this distribution do not
exactly match the names of the files used in the catalog file
distributed with DocBook ( docbook.cat ). Make sure your
catalog file points to the right files.  See  http://www.oasis-open.org/cover/topics.html#entities 
for more information.
 The DocBook Catalog public identifiers DocBook DTD V3.1 DocBook DTD public identifiers 

DocBook uses public identifiers to refer to its
constituent parts. In some sense, DocBook  is 
DocBook because it has the formal public
identifier  -//OASIS//DTD DocBook V3.1//EN .
In order for tools on your system to
find your locally installed copy of DocBook, you must map these
public identifiers into system identifiers, i.e., filenames, on
your system. For a complete discussion of catalog files, 
see  . catalog files DocBook distribution, installing 

The DocBook distribution includes a sample catalog,  docbook.cat
 , which provides a mapping for all of the public identifiers referenced
by DocBook. This mapping won&#39;t work  out of the box  for two
reasons: first, your tools won&#39;t be able to find it, and second, the mappings
for the ISO entity sets probably don&#39;t point to the right place on your system.
 Finding the Catalog If you&#39;ve already got some other SGML DTDs installed, you probably already
have a catalog file. In this case, the easiest thing to do is append
the DocBook catalog entries to the end of your existing catalog and then change
them to point to the files on your system. If DocBook is the first DTD that you&#39;re installing, make a
copy of  docbook.cat  and call it
 catalog . Put this file in a higher-level
directory and edit the relative pathnames that it contains to point to
the actual locations of the files on your system. For example, if you installed DocBook
in  /share/sgml/docbk30/ , put the
 catalog  in  /share/sgml/ . environment variables, setting (catalog files) SGML_CATALOG_FILES environment variable, setting 

In order for applications to find your catalog file(s), you may have
to change the application preferences or set an environment variable. For  
SP  and  Jade , set the environment
variable  SGML_CATALOG_FILES  to the delimited list of catalog
filenames. On my system, this looks like: SGML_CATALOG_FILES=./catalog;n:/share/sgml/catalog;n:/adept80/doctypes/catalog.jade;j:/jade/catalog
 
(On a UNIX machine, use colons instead of semicolons to delimit the
filenames.) If you don&#39;t wish to set the environment variable, you can explicitly
pass the name of each catalog to the  SP  application
with the  -c  option, like this: nsgmls -c ./catalog -c n:/share/sgml/catalog  -c othercatalogs
  ... Fixing the Catalog catalog files mapping to system 

The basic format of each entry in the DocBook catalog is: PUBLIC &quot;some public id&quot; &quot;some filename&quot; What you have to do is change each of the  some filenames 
to point to the actual name of the file on your system. filenames catalog file 

Filenames should be supplied using absolute filenames,
or paths relative to the location of
the  catalog  file. To continue with the example above, let&#39;s say that you&#39;ve got: DocBook in  /share/sgml/docbk30/ , The ISO entities in  /share/sgml/entities/8879/ ,
and Your catalog in  /share/sgml/catalog Then you would change the catalog entry for the DTD to be: PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot; &quot;docbk30/docbook.dtd&quot;
 You would change the catalog entry for the general technical character entities to:
 PUBLIC &quot;ISO 8879:1986//ENTITIES General Technical//EN&quot; &quot;entities/8879/iso-tech.gml&quot;
 And similarly for the other public identifiers used by DocBook. In each
case, the filename specified for the public identifier should be the name
of the file on your system, specified as an absolute filename, or 
relative to the location of the  catalog 
in which it occurs. Mapping System Identifiers for XML XML system identifiers mapping system identifiers XML mapping for 
Since XML documents are required to have system identifiers, but are not
required to have public identifiers, it&#39;s likely that some of the documents
you want to process will only have system identifiers.
 
It turns out that you can still take advantage of the catalog in this case.
The  SYSTEM  directive allows you to map the system
identifier used in the document to the actual location on your system.
 
Suppose that you work with a colleague who uses the system identifier
 file:///c:/sgml/db3xml/db3xml.dtd  to identify the XML version
of DocBook on her system.  On your system, you want to map that to
 /share/sgml/db3xml/db3xml.dtd .  The following entry in
your catalog will do the trick:
 
SYSTEM &quot;http://docbook.org/docbook/xml/1.4/db3xml.dtd&quot; &quot;/share/sgml/db3xml/db3xml.dtd&quot;
 
Unfortunately, this technique only works with applications that read and
understand catalog files.
 Testing Your Installation DocBook DTD installation testing nsgmls parser DocBook installation, testing testing DocBook installation 

The best way to test your installation is with a simple command-line
parser like  nsgmls  from  SP .
Create a small test document, like this: &lt;!DOCTYPE chapter PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot;&gt;
&lt;chapter&gt;&lt;title&gt;Test Chapter&lt;/title&gt;
&lt;para&gt;
This is a test document.
&lt;/para&gt;
&lt;/chapter&gt; and run the following command: nsgmls -sv test.sgm declarations passing explicitly DTDDECL warnings (unsupported) 

If the  nsgmls  command produces errors, review your
catalog and resolve the errors. You can ignore warnings about  DTDDECL
  being unsupported. It is unsupported, and there&#39;s no way to disable
the warning message. Note, however, that this may also affect which SGML declaration
gets used. When in doubt, pass the correct declaration explicitly and see
if that corrects any problems. (To parse  test.sgm  with
the declaration  docbook.dcl  explicitly, run  
nsgmls -sv docbook.dcl test.sgm .) For some suggestions about how to work around these problems in  
SP  and  Jade , see the next section,
 .
 Installing Jade Jade installing 

For simplicity, the instructions assume that you are working with
Jade on a Microsoft Windows machine. These instructions should be just as
useful if you are working on another platform, except for the normal cross-platform
idiosyncracies (path and filename separator characters, use of drive letters,
etc.). Download and unpack the  Jade
  distribution. Binary distributions are available for some platforms,
which makes installation a simple matter of unpacking the distribution. Or
you can build Jade from the source (consult the documentation that comes with
Jade for more detail about building it from source). You may wish to add the directory where you installed Jade to your  
PATH . If not, make sure that you use the fully qualified name of the
executable when you run the commands below. Setting Up the Catalog catalog files Jade, setting up for 

First, the catalog needs to be set up as described in
 
in order for Jade to be able to parse your DocBook documents. In addition,
Jade comes with its own  catalog  file that you must add
to the  SGML_CATALOG_FILES  environment variable or otherwise
make available to Jade. Testing Jade testing Jade 

Download  jtest.sgm  and  jtest.dsl . (Or get them off the CD-ROM in
FIXME.) These are self-contained
test documents. Test Jade by running: jade -t rtf -d jtest.dsl jtest.sgm This command should silently produce  
jtest.rtf . If you encounter warnings or errors here, Jade is not installed
correctly. One possible culprit is your catalog setup. See  . DTDDECL Warnings DTDDECL Jade, not supporting 

One annoying shortcoming in Jade is that it does not support the  
DTDDECL  catalog directive and it complains loudly if it encounters
one. In Jade, it&#39;s almost always possible to work around the problems that  
DTDDECL  would solve, so you can generally ignore the warnings. If you also use applications that do understand  DTDDECL ,
and find the warnings too distracting to bear, setup alternate catalogs
for  SP  applications,  catalog.jade ,
that are identical to your normal catalogs but do not contain any  
DTDDECL  entries. You can then avoid the warnings by putting  catalog.jade
  in your  SGML_CATALOG_FILES  path, instead of  
catalog . Installing the Modular DocBook Stylesheets stylesheets installing modular (DocBook) DocBook DTD stylesheets installing DSSSL stylesheets downloading Norman Walsh  (one of your
intrepid authors ;-) maintains two DSSSL stylesheets for DocBook, one for
print and one for online (HTML) output. You can obtain both of these stylesheets
from  http://nwalsh.com/docbook/dsssl/
 . (A recent version is also on
the CD-ROM.) If you have not already done so, download and install the DocBook
DTD as described in  . Likewise, if Jade is not installed on your system, download
and install it as described in  .
 Download and unpack the  
stylesheet distribution . testing DSSSL stylesheets installation HTML stylesheets testing (DocBook) 

Test the installation by processing  test.sgm 
(from the previous section) with Jade: jade -t rtf -d d:\where-you-unpacked-the-stylesheets\docbook\print\docbook.dsl test.sgm
 This command should silently produce  
test.rtf . If not, and the preceding test succeeded, something
has gone wrong contact
the maintainer . To test the HTML stylesheet, run: jade -t sgml -d d:\where-you-unpacked-the-stylesheets\docbook\html\docbook.dsl test.sgm
 This command should silently produce  
c01.htm . If not, and the preceding test succeeded, something
has gone wrong contact
the maintainer . $Date: 2001-08-02 14:27:50 +0400 (Чт, 02 авг 2001) $ $Revision: 546 $ DocBook and  DocBook DTD XML XML DocBook and SGML XML and XML SGML, processing 

 , the  Extensible
Markup Language , is a simple dialect of  . In the words of the
  specification,  the goal [of  ] is to enable generic   to be
served, received, and processed on the Web in the way that is now possible
with  .  raises two issues with respect to DocBook: Are DocBook   instances valid   instances? Can the DocBook   be made into a valid    ? If you have an existing   system, and your primary goal is
to serve DocBook documents over the Web as  , only the first of
these issues is relevant.  As the popularity of   grows, we will
see more and more  -aware tools that don&#39;t implement full
 ISO  8879  . If your goal is to author DocBook
documents with one of this new generation of tools, you will only be
able to achieve validity with an   DocBook  . OASIS XML DocBook version 

Although not yet officially adopted by the  OASIS  DocBook Technical 
Committee, an   version of DocBook is available now and
provided on the  CD-ROM .
 DocBook Instances as  DocBook DTD instances, converting to XML XML DocBook instances, converting to 

Most DocBook documents can be made into well-formed   documents very
easily. With few exceptions, valid DocBook   instances are also well-formed
  instances. The following areas may need to be addressed. System Identifiers system identifiers SGML public identifiers SGML parameter entities SGML declarations declarations document type and parameter entity (SGML) 

It is common for   instances to use only a public identifier in document
type and parameter entity declarations:  requires a system identifier:
 catalog files system identifiers, resolving URN XML system identifiers, future public identifiers system identifiers, overriding 

If you&#39;re used to using catalog files to resolve system identifiers,
you may be dismayed to learn that system identifiers are required. Because most
tools favor system identifiers over public identifiers, all of the portability
that was gained by the use of catalog files seems to have been lost. In the
long run, it&#39;ll be regained by the fact that   system identifiers can be
 URN s, which will have a resolution scheme like catalogs, but what about the
short run? Luckily, there are a couple of options.  First, you can tell your tools to use the public identifiers even
though system identifiers are present. Simply add: OVERRIDE YES system identifiers remapping with SYSTEM catalog directive 

to your catalog files. Alternatively, you can remap system identifers
with the  SYSTEM  catalog directive.  If you are faced with 
documents that don&#39;t use public identifiers at all, this is probably your
only option.
 Minimization markup minimization SGML/XML conversion problems minimization markup SGML/XML conversion problems 

If you have used   minimization features in your instances: they will not be well-formed   instances. In particular,  quotes attribute values attributes values quoting 

Requires that all attribute values
be quoted. Does not allow short tag minization.
 
  also forbids tag omission, and there are
probably a half dozen or so more exotic
examples of minimization that you have used. They&#39;re all illegal. The
easiest way to remove these minimizations is probably with a tool like  
sgmlnorm  (included in the  SP  and Jade distributions, on
the  CD-ROM ). The result will be something like this: Attribute Default Values attributes default values 

Correct processing of this document may require access to the default
attributes: Address  expresses
that its content is line-specific with an attribute. Some   processing environments are going to ignore the doctype declaration
in your document, even if it&#39;s present. This is relevant when your instance
uses elements that have attributes with default values. The default values
are expressed in the  , but may not be expressed in your instance. In the
case of DocBook, there are relatively few of these, and your stylesheet can
probably be constructed to do the right thing in either case. (It essentially
treats the attributes as if they had implied values.) The result will be something like this: Character and  SDATA  Entities characters entities SDATA entities entities characters entities SDATA XML SDATA entities, not allowing ISO standards entity sets SDATA entities, problems with (XML) Unicode character set ISO standard entity sets and 

The DocBook   defines all of the standard  ISO 
entities automatically, but the  ISO  definitions use
 SDATA , which is not allowed in  . Eventually,
 ISO  (or someone else) will release official
 ISO  standard entity sets that make reference to the
appropriate Unicode character for each entity. Until then, the  
version of DocBook is
distributed with an unofficial set. internal subset entity declarations external subset entity declarations (SGML/XML conversion) 

If you use entities in your document, it may be wise to put declarations
for them in the internal subset of each instance, because some
  browsers are going to parse the internal subset but not the external subset.
If the entity declarations are in your  , and the browser does not parse
the external subset, the browser won&#39;t know how to display the entities in
your document. The result will be something like this: Case-Sensitivity case sensitivity DocBook SGML declaration elements case sensitivity (DocBook) attributes case sensitivity (DocBook) XML case sensitivity 

With the standard DocBook   declaration, DocBook instances are not
case-sensitive with respect to element and attribute names.   is always
case-sensitive. As long as you have used the same case consistently, your
  instances will be well-formed, but it may still be advantageous to do some
case-folding because it will simplify the construction of stylesheets. Keywords in   are case-sensitive,
and must be in uppercase.
 keywords case sensitivity, XML 
 The name declared in the document
type declaration, like all other names, is case-sensitive.
 names case sensitivity 

 Start and end tags must use the same
case.
 start tags case sensitivity 
 end tags case sensitivity 
 In  ,  Para  is not the
same as  PARA . Note that this is a validity error (against
the   version of DocBook), but it is not an   well-formedness error. The use of  
para  and  PARA  as distinct names is as legitimate
as using  foo  and  bar , as long as they
are properly nested.
 Para element PARA vs. (XML) 
 The result will be something like this: No #CONREF Attributes #CONREF attributes Startref attribute IndexTerm element OtherTerm attribute GlossSee element GlossSeeAlso element empty tags #CONREF attributes 

The  StartRef  attribute on  
indexterm  and the  OtherTerm 
attribute on  GlossSee  and  GlossSeeAlso 
are  #CONREF  attributes. In   terms, this means that when these attributes are used, the content
of the tag is taken to be the same as the content of the tag pointed to by
the attribute.  If you
have used these attributes, your instance will contain both empty and non-empty
versions of these tags. Your best bet is to transform the  #CONREF 
version into an empty tag and let your stylesheet deal with it appropriately.
 The result will be something like this: Only Explicit CDATA-Marked Sections Are Allowed parameter entities XML document body XML parameter entities internal subset parameter entities (XML) 

Parameter entities are not
allowed in the body of   documents (they are allowed in the internal subset).
  instances cannot contain  
IGNORE ,  INCLUDE ,  TEMP , or  
RCDATA  marked sections.
 marked sections XML, restrictions 
 IGNORE keyword (marked section) 
 INCLUDE keyword (marked section) XML, not allowing 
 TEMP marked section (XML) 
 RCDATA 
 CDATA  marked sections
must use the  CDATA  keyword literally because
parameter entities are not allowed.
 CDATA marked sections 
 The result will be something like this: No SUBDOC or CDATA External Entities external general entities XML restrictions XML external entities, restrictions CDATA XML instances, restrictions 
  instances cannot use  CDATA  or  SUBDOC
  external entities. One option for integrating external  
CDATA  content into a document is to employ a pre-processing pass
that inserts the content inline, wrapped in a  CDATA  marked
section. SUBDOC entities namespaces SUBDOC  entities may be more problematic. If you do
not require validation, it may be sufficient to simply put them inline.  
namespaces may offer another possible solution. The result will be something like this: No Data Attributes on Notations They&#39;re not allowed in  , so don&#39;t add any.
 data attributes, notations (XML prohibiting) 

 No Attribute Value Specifications on Entity Declarations attributes values specifying (entity declarations) declarations entities attribute values, prohibiting (XML) entities declarations, attribute values (XML) 

They&#39;re not allowed in  , so don&#39;t add any. The DocBook   as  DocBook DTD XML converting to XML DocBook DTD, converting to Converting the DocBook   to   is much more challenging
than converting the instances. It is probably not possible to
construct an     that is identical to the validation power
of DocBook. The list below identifies most of the issues that
must be addressed, and describes how the DocBook    ; deals with
them: Comments are not allowed inside markup declarations comments markup declarations (DocBook XML) declarations comment declarations 

Most of them have been moved to comment declarations preceding the markup
declaration that used to contain them. A few small, inline comments that seemed
like they would be out of context if moved before the declaration were simply
deleted. Name groups are not allowed in element or attribute list
declarations name groups (DocBook XML) elements declarations name groups, prohibiting attributes declarations name groups, prohibiting 

The small number of places in which DocBook uses name groups have
been expanded. There&#39;s one downside: DocBook uses  %admon.class;  in a name
group to define the content model, and attribute lists for elements in the
admonitions class. In DocBook XML, this convenience cannot be expressed. If additional
admonitions are added, the element and attribute list declarations will have
to be copied for them. No  CDATA  or  RCDATA 
declared content CDATA declared content, prohibiting RCDATA Graphic  and  InlineGraphic  have
been made  EMPTY . The content model for  SynopFragmentRef
 , the only  RCDATA  element in DocBook, has been
changed to  (arg | group)+ . No exclusions or inclusions on element declarations inclusions element declarations, prohibiting (DocBook XML) exclusions element declarations, prohibiting (DocBook XML) 

They had to be removed. exclusions DocBook, uses 

In DocBook, exclusions are used to exclude the following: Ubiquitous elements ( indexterm 
and  BeginPage ) from a number of contexts in which they
should not occur (such as metadata, for example). formal objects, exclusions (DocBook) 

Formal objects from  Highlights ,  
Example s,  Figure s and  LegalNotice s.
 tables exclusions (DocBook) InformalTable element excluding from tables 

Formal objects and  InformalTable s
from tables. footnotes, exclusions (DocBook) block elements excluding from footnotes 

Block elements and  Footnote s
from  Footnote s Admonitions,  EntryTbl s, and  
Acronym s from themselves.
 admonitions exclusions (DocBook) 
 acronyms (DocBook XML) 
 Removing these exclusions from DocBook   means that it is now valid, in
the   sense, to do some things that don&#39;t make a lot of sense (like put
a  Footnote  in a  Footnote ). Be careful.
 inclusions DocBook, uses IndexTerm element inclusions, DocBook BeginPage element (DocBook inclusions) parameter entities DbXML, ubiquitous element inclusions #PCDATA keyword DbXML, ubiquitous elements 

Inclusions in DocBook are used to add the ubiquitious elements ( 
indexterm  and  BeginPage ) unconditionally to a
large number of contexts. In order to make these elements available in
DocBook  ,
they have been added to most of the parameter entities that include  
#PCDATA . If new locations are discovered where these terms are desired, DocBook  
will be updated. Elements with mixed content must have  #PCDATA
  first. elements mixed content (DocBook XML) content models elements, updating (DocBook XML) 

The content models of many elements have been updated to make them a
repeatable OR group beginning with  #PCDATA . Many declared attribute types ( NAME ,  
NUMBER ,  NUTOKEN , and so on) are not allowed attributes declared types, prohibiting (DocBook XML) NMTOKEN(S) attribute DbXML CDATA DbXML 

They have all been replaced by  NMTOKEN  or  
CDATA . No  #CONREF  attributes allowed. #CONREF attributes DbXML, prohibiting #IMPLIED attribute (DocBook XML) GlossSee element DbXML GlossSeeAlso element DbXML IndexTerm element empty (DocBook XML) 

The  #CONREF  attributes on  indexterm ,  
GlossSee , and  GlossSeeAlso  were changed to  
#IMPLIED . The content model of  indexterm  was
modified so that it can be empty. Attribute default values must be quoted. quotes attribute values DbXML attributes values quoting 

Quotes were added wherever necessary.
 
 
 $Date: 2009-01-05 12:25:13 +0300 (Пн, 05 янв 2009) $ $Revision: 8201 $ DocBook Versions DocBook DTD versions versions DocBook DTD OASIS DocBook Technical Committee DocBook Technical Committee (OASIS) TC DocBook Technical Committee (OASIS) 

The  OASIS  DocBook Technical Committee ( TC ) is committed to the continued
evolution of DocBook.  As new needs are expressed by the DocBook-user
community, the committee will adapt DocBook so it
continues to meet the needs of its users.
 compatibility, DocBook versions 
The  TC  observes a very cautious policy regarding changes to the  .
Backward-incompatible changes can only be introduced:
 major releases, DocBook DTD 

In major releases (4.0, 5.0, 6.0, and so on)
 comments DocBook DTD, changes to 

Only if the change was described in comments in the   in the
previous major release
 
 point-releases (DocBook DTD), compatibility 

Changes made at point-releases are always backward-compatible to the
previous major release. This policy assures that DocBook users always
have time to prepare for any coming changes.
 This appendix describes the changes planned for
DocBook. DocBook V3.1 DocBook  V3.1 , released in February 1999,
introduced a number of new elements:
 elements new (DocBook V3.1) 
 MediaObject elements 
 VideoObject element 
 AudioObject element 
 ImageObject element 
 TextObject element 

 MediaObject MediaObject  is a wrapper around
 VideoObject ,  AudioObject ,
 ImageObject , and  TextObject .  The
purpose of  MediaObject  is twofold: first, it introduces
new element types to include video and audio content; second, it
provides the option of alternative representations, including text, for
objects in a document.   MediaObject s also allow
 Caption s that may be longer than a simple title.
 InlineMediaObject element MediaObjectCO element Callout (MediaObject) 

Parallel to  MediaObject  are  InlineMediaObject ,
an inline version, and  MediaObjectCO , a media object
with  Callout s.
 Graphic element removal (v5.0) InlineGraphic element removal (v5.0) 
For now, media objects and graphics exist together
in version 5.0.  Graphic  and  InlineGraphic  will
be removed from DocBook.
 InformalFigure InformalFigure element 

A figure wrapper without a title. This element was added
largely for symmetry.
 Colophon colophon element elements Colophon 

An end-of-the-book  Colophon .
 Section Section element Section  is a recursive section.  It exists
parallel to, and must be used as an alternative to,
 Sect1 .
 QandASet QandASet element 

A set of questions and answers.
 Constant Constant element elements Constant Class attribute constant element 

The  Constant  inline is for identifying
constants.  It has a  Class  attribute for
identifying  limits  as a specific kind of constant.
 VarName VarName element elements VarName names variable (VarName element) 

Many authors have requested a tag for identifying
variable names.  Most often  Literal  (with or without a role)
has been chosen as a compromise, but you can&#39;t question the utility of identifying variable
names, so  VarName  was added.
 A tag for identifying variable values does not seem as necessary.
For immutable values, a specific tag other than  Literal 
seems unnecessary, and  Replaceable  exists for values that
are supposed to be filled in by the user.
 DocBook V4.1 and DocBook   V4.1.2 DocBook DTD versions V4.1 versions DocBook DTD V4.1 DocBook XML DTD versions V4.1.2 versions DocBook XML DTD V4.1.2 
DocBook  V4.1  and DocBook    V4.1.2 
became an OASIS Standard in
February 2001. DocBook  V4  introduced
a number of backward-incompatible
changes. The policy of the DocBook  TC  is that backward-incompatible changes
can only be introduced in a full version release.  They must also be described
in comments in the   at least one full version earlier.  In other words,
all the planned version 4.0 incompatibilities were announced with version 3.0.
 
Backward-incompatible changes to DocBook that are planned for version 4.0:
 DocInfo element changes V4.0 ChapterInfo element (V4.0) AppendixInfo element (V4.0) ArtHeader element V4.0 ArticleInfo element (V4.0) SeriesInfo element, changes V4.0 BiblioSet element BookBiblio element, changes V4.0 BookInfo element changes, v4.0 

The  DocInfo  element will be split out into  ChapterInfo ,  AppendixInfo ,
  and so on.  ArtHeader  will be renamed to  ArticleInfo .   SeriesInfo  may be
  discarded because it has become a special case of  BiblioSet .
   BookBiblio  will be discarded in favor of a new, more inclusive,
  structure for  BookInfo  (and for  ArticleInfo , whose earlier  ArtHeader 
  form contained  BookBiblio ).
 article.class entity, removing (V4.0) Book element article.class entity, removing (V4.0) 

The  article.class  entity may be removed from the  Book  content model,
  and made part of a new top-level document hierarchy.
 nav.class entity, changes V4.0 ToC changes, V4.0 

The  nav.class  entity, which appears in several divisions, will allow
   ToCchap  instead of  ToC .
 MsgText element changes, V4.0 tech.char.class parameter entity redefining MsgText  will be moved from  tech.char.class  to a more appropriate
  parameter entity.
 smallcptr.char.mix parameter entity, changes V4.0 Action element changes, V4.0 Command element changes, V4.0 Database element changes, V4.0 Filename element changes, V4.0 Hardware element changes, V4.0 Interface element changes, V4.0 KeyCap element changes, V4.0 Literal element changes, V4.0 Option element changes, V4.0 Parameter element changes, V4.0 Property element changes, V4.0 SystemItem element changes, V4.0 

The following elements will have their content constrained to the
   smallcptr.char.mix  mixture:  Action ,  Command ,  Database ,  Filename ,
   Hardware ,  Interface ,  KeyCap ,  Literal ,  Option ,  Parameter ,  Property , and
   SystemItem .
 AuthorBlurb element, changes V4.0 person.ident.mix parameter entity, changes V4.0 Author element changes, V4.0 Affiliation element, changes V4.0 AuthorBlurb  and  Affiliation  will be removed from  person.ident.mix 
  and a new wrapper element will be created to allow association of those two
  elements with  Author  name information.
 Epigraph element changes, V4.0 BlockQuote element changes, V4.0 Epigraph  will not be appearing in  BlockQuote .
 Comment element, changes V4.0 Remark element, changes V4.0 Comment  will be renamed to  Remark  and will be excluded from itself.
 GlossTerm element changes, V4.0 Glossary element changes, V4.0 GlossTerm  will be excluded from itself, and may be split into an
  element that appears in a  Glossary  and an element that can appear in
  the main text.
 Subject attribute, changes V4.0 GlossDef element, changes V4.0 Keyword attribute (V4.0) 

The  Subject  attribute on  GlossDef  will be renamed  Keyword .
 SetTitle elements (V4.0) SegmentedList element changes, V4.0 

Two  SegTitle  elements will be required in  SegmentedList .
 Graphic element InlineGraphic element empty elements Graphic and InlineGraphic, V4.0 EntityRef attribute (graphics), V4.0 graphics embedded, storing outside SGML source Graphic  and  InlineGraphic  will be declared EMPTY.  This change will
  require that end tags be removed and that any embedded graphic content
  be stored outside the   source and pointed to from an  Entityref  or
   Fileref  attribute.
 OptMult attribute value (Choice), V4.0 ReqMult attribute value (Choice), V4.0 Choice attribute, changes V4.0 Group element, changes V4.0 Rep attribute, changes V4.0 

The  OptMult  and  ReqMult  values for the  Choice  attribute on  Group 
  will be removed.  Use the  Rep  attribute instead to indicate that the
  choice is repeatable.
 FuncSynopsis element changes, V4.0 FuncDef element, changes V4.0 FuncPrototype element, changes V4.0 FuncSynopsisInfo element (V4.0) 

The content model group inside  FuncSynopsis  starting with  FuncDef 
  will not be available; you will have to use  FuncPrototype .  Also, you
  will be able to have a mixture of  FuncPrototypes  and  FuncSynopsisInfos 
  (this is not backward-incompatible all by itself).
 EnvironVar element (V4.0) Prompt element changes, V4.0 Class attribute changes, V4.0 SysItem element (V4.0) EnVar element V4.0 

The  EnvironVar  and  Prompt  values for the  Class  attribute on  SystemItem 
  will be eliminated; use the  EnVar  and  Prompt  elements instead.
 DocBook V4.2 DocBook V4.2 fixed a couple of small bugs and introduced a number of
new features. Changes in DocBook V4.2 are explained in the
 DocBook
Document Type Version 4.2 . EBNF Module FIXME: write this section HTML Forms Module FIXME: write this section MathML Module FIXME: write this section SVG Module FIXME: write this section $Date: 2009-01-05 12:25:13 +0300 (Пн, 05 янв 2009) $ $Revision: 8201 $ Resources XML resources, reference SGML resources, reference The quantity of information about   and   is growing
on a daily basis.  This appendix strives to provide both a
complete bibliography of the references mentioned explicitly in
this book, and a sampling of resources for additional
information about DocBook and about   and   in general.
Although not all of these resources are focused specifically on
DocBook, they still provide helpful information for DocBook
users. Latest Versions of DocBook As of July 1998, responsibility for the advancement and maintenance
of the DocBook   has been transferred from the Davenport Group, which originated
it, to the DocBook Technical Committee of  OASIS  (Organization for the Advancement
of Structured Information Standards) at  
http://www.oasis-open.org/ . 
The latest releases of DocBook can be obtained from the official DocBook
home page at  
http://www.oasis-open.org/docbook/ .
 Resources for Resources Here&#39;s where to find pointers to the subjects you want to find. The Most Recent Version of This Book 
The most recent online version of this book can be found at
 http://docbook.org/ .
 The Most Recent Version of DocBook 
The most recent version of DocBook, and the most recent information
about the  , can be found at the DocBook home page:
 http://www.oasis-open.org/docbook/ .
 Robin Cover&#39;s  /  Web page Easily the largest and most up-to-date list of  /  resources; can be found at  http://www.oasis-open.org/cover/ . comp.text.sgml 
and  comp.text.xml USENET  newsgroups devoted to   and   issues. FAQ s For pointers to several    FAQ s, see 
 http://www.oasis-open.org/cover/general.html#faq . 
The    FAQ  is
available at  http://www.ucc.ie/xml .
 .com .com , run jointly
by Songline Studios and Seybold, is a site devoted to making  
accessible. Introductory Material on the Web These documents provide a good background for a better understanding of
  and  . A Gentle Introduction to  A useful and simple document available in its original form at  http://www-tei.uic.edu/orgs/tei/sgml/teip3sg/index.html
 . A Technical Introduction to  A close look at the ins-and-outs of   is available at  
http://nwalsh.com/docs/articles/xml/ . References and Technical Notes  on the Web Entity Management OASIS  Technical
Resolution 9401:1997 (Amendment 2 to  TR  9401) . 
This document describes  OASIS  catalog files.
 The   Declaration The   Declaration,  by Wayne Wholer.
 Table Interoperability: Issues for the   Table Model
 OASIS 
Technical Research Paper 9501:1995 . Exchange Table Model Document Type Definition OASIS 
Technical Resolution  TR  9503:1995 .  Table Model Document Type Definition OASIS 
Technical Memorandum  TM  9502:1995 XML Exchange Table Model Document Type Definition OASIS
Technical Memorandum TM 9901:1999 . Internet  RFC s RFC s ( Request for Comments ) are standards documents
produced by the Internet Engineering Task Force ( IETF ).
 RFC  1630 Universal Resource Identifiers in  WWW . RFC  1736 Functional recommendations for Internet Resource Locators. RFC  1737 Functional requirements for Uniform Resource Names. RFC  1738 Uniform Resource Locators ( URL ). RFC  3066 Tags for the identification of languages Specifications Here are pointers to the specifications. The   Specification
 The  W3C  technical recommendation that defines   1.0. Namespaces
in  The  W3C  technical recommendation that defines   namespaces. Mathematical
Markup Language (MathML) 1.0 Specification The  W3C  technical recommendation that defines MathML, an  
representation of mathematical equations. 
The Unicode Standard, Version 2.0 The Unicode standard. 
Unicode Technical Report #8 Version 2.1 of the Unicode standard. 
Dublin Core Metadata Element Set, Version 1.1: Reference Description Version 1.1 of the Dublin Core Metadata Initiative&#39;s Metadata Element
Set. 
Getty Thesaurus of Geographic Names A controlled vocabulary of geographic place names. Books and Printed Resources There are also a number of books worth checking out: Developing    s From Text to Model to Markup Eve Maler Jeanne El Andaloussi 0-13-309881-8 Prentice-Hall PTR Upper Saddle River New Jersey 1996 Practical  Erik van Herwijnen 2 0-7923-9434-8 Kluwer Academic Press 1994 An introductory book, but not a simple one. The   Handbook Charles Goldfarb Yuri Rubinksy 0-7923-9434-8 1991 Oxford University Press A reference book by the author of the    ISO  Standard. SGML: an author&#39;s guide to the Standard Generalized Markup Language Martin Bryan 0-201-17535-5 1988 Addison-Wesley Publishing Company $GML: The Billion Dollar Secret Chet Ensign 0-13-226705-5 1998 Prentice Hall Effective   evangelism. Creating Documents with  Chris Maden 1-56592-518-1 1999 O&#39;Reilly &amp; Associates An introductory book about  . : A Primer Simon St. Laurent 1-5582-8592-X 1998 MIS:Press/IDG Books Worldwide Another introductory book about  . Understanding SGML and XML Tools Peter Flynn 0-7923-8169-6 1998 Kluwer Academic Publishers The standard work on SGML/XML software. The LaTeX Web Companion Integrating TeX, HTML, and XML Michel Goosens Sebastian Rahtz 0-201-43311-7 1999 Addison-Wesley Publishing Company /  Tools An attempt to provide a detailed description of all of the  / 
tools available is outside the scope of this book.
 
For a list of recent
of   tools, check out Robin Cover&#39;s  /  page at  OASIS :  
http://www.oasis-open.org/cover .
 For a list of   tools,
check out  .com:  http://www.xml.com/ .
 $Date: 2003-06-04 16:22:51 +0400 (Ср, 04 июн 2003) $ $Revision: 2902 $ What&#39;s on the CD-ROM ? DocBook DTD CD-ROM, resources Appendix D in this book 
The  CD-ROM  that accompanies the print version of this book contains
a number of useful resources.
 
Please read the  readme.txt  file in the root directory
of the  CD-ROM . It describes any last-minute changes or additions
that were made to the  CD-ROM  after this appendix was written.
 DocBook: The Definitive Guide /sgml/  contains the sources for this book in  .
 /html/  contains an online version of this book in  .
 /help/  contains a compiled   Help version of this book.
 /examples/  contains the complete examples from
this book.
 The DocBook  /dtds/docbook/db30  contains DocBook  V3.0 .
 /dtds/docbook/db31  contains DocBook  V3.1 .
 /dtds/docbk/db315  contains DocBk    V3.1.5 .
 /dtds/docbk/sdb3151  contains a simplified DocBk  
 V3.1.5.1 .
 /dtds/isoents  contains  ISO  entity sets
needed for the  s.
 /dtds/usadod  contains the  CALS  table
model   needed for the   DocBook  s.
 Stylesheets /style/  contains various stylesheets.
 /style/dsssl/docbook/  contains the Modular DocBook
 DSSSL  stylesheets. These are the Jade stylesheets
described in  .
 /dtds/dsssl/anotess/  contains the Annotated
 DSSSL  stylesheet   and related files.
 /style/xsl/  contains various  XSL  stylesheets.
 /style/xsl/docbook/  contains the  XSL  DocBook
Stylesheets  V0.12 .
 Other Programs 
The  /apps  directory contains source and binary releases
of other, related software, including the Jade and XT
distributions. The  /bin  directory contains the format
script briefly discussed in  .
 $Date: 2001-08-14 01:42:26 +0400 (Вт, 14 авг 2001) $ $Revision: 625 $ Interchanging DocBook Documents DocBook DTD documents interchanging questionnaire, DocBook document interchange issues 
One of the early factors that motivated the development of the DocBook
  was the desire for companies to interchange documents.  In particular,
  vendors wanted to be able to interchange common   documentation.
 
A great deal of effort went into making sure that DocBook could handle
most (probably all) of the documents that were likely to be exchanged.
This avoids the guaranteed interchange problem of   extension.
 However, simply using DocBook or a subset of it is not
enough to ensure successful interchange. If you send someone
your DocBook files, you must also tell the recipient about the
markup your documents use and any of your additional markup
conventions and processing expectations that impose constraints
on processing.
 
This appendix provides a sample interchange questionnaire to
help draw your attention to those areas that might be problematic.
 For maximum portability, delivered DocBook documents
should be accompanied by a filled-out interchange
questionnaire. Because each situation is unique, you may need to
supply additional information (such as layout specifications) in
order to deliver a complete package. DocBook and   Usage What version of the   are you using? Did you use any markup features of the   that
have been flagged as obsolete (to be removed at the next major version
of DocBook)? If so, which ones? Did you extend DocBook in any way, inside or outside
the provided customization mechanisms? How? All extensions must be negotiated
with the recipient. Did you remove markup from DocBook to create a
subset? If you used a subset of DocBook, supply the subset you used. (Note
that even the removal of references to  ISO  entity sets creates a subset.)
 Did you use the supplied   declaration or another
one? If you used another one, provide it. Did you use the supplied catalog or another one,
or none at all? If you used a catalog other than the one supplied, provide
it. If your documents bear no document type declaration,
and you parsed them with a document declaration (with or without an internal
subset), supply it. Did you add  NOTATION  declarations?
If so, what are they? List all data content notations used in your documents.
 Did you use the  SUBDOC  feature?
If so, how did you manage the name spaces of their  ID s, if you managed
them at all? Did you use character sets other than  ISO  8859-1
(Latin 1)? If so, which ones? How did you use them? Did you declare and use character entities and
other general entities besides the  ISO  entity sets? If so, supply the entity
declarations and the desired appearance of the additional character entities.
 Are your document files normalized to include all
markup explicitly? Are you supplying a document fragment? If so, have
you provided any necessary auxiliary information (such as meta-information)
for the fragment? Are there any attribute values that haven&#39;t been specified
that you expect to inherit from a parent that isn&#39;t present? Processing Requirements and Markup Interpretation What formatting that you applied do you
require your interchange partner to apply? For example,
where and how must text be generated in order for the documents to make sense?
 Did you supply your stylesheet and
information regarding its format and version? How did you create tables of contents,
lists of titles, and indexes? Are they stored in DocBook form? If so,
did you generate them (and according to what rules) or create them by
hand? If you used the  Lang  common attribute, why, and to what
effect? If you used the  Remap  common attribute, why, and to what
effect? If you used the  Role  common attribute, why, and to what
effect? If you used the effectivity
attributes, which did you use, why, and to what effect? What values did you give to the  Label  attribute and how are they to be
interpreted for rendering? What
values did you give to the  Mark 
and  Override  attributes for lists
and how are they to be interpreted for rendering? Did you use the  Renderas  attribute on sections and/or
 BridgeHead s? Did you supply all keyword values you used for
attributes whose declared values are not enumerated tokens, along with
the expected processing for the occurrence of each keyword? Did you use markup to control width, size,
and/or positioning settings (such as  fold-out  or
 centered ) for graphics, line specific regions, and
tables? If so, how? For rendering of
 Sidebar s, must these appear in the flow of the text
where they appear in your files, or may they float? Did you use  Callout s? If so, what are the
processing expectations for callout marks?
 Did you use  ItemizedList s? If so, what are the
processing expectations for the marks on list items and nested lists?
 For  Graphic  and  InlineGraphic , what method(s) did
you use for providing graphic data: element content,  Fileref  attribute, or
 Entityref  attribute? For  MediaObject  and  InlineMediaObject ,
what method(s) did
you use for selecting between alternative presentations? How did you specify column widths in tables? Did
you use vertical spans? Did you use horizontal spans? Did you use  EntryTbl s?
 If you used the  Type  attribute on the link elements,
why, and to what effect? If you used  XRef , do your interchange
partners need additional information about the semantic of the link?
Have you provided it, perhaps with  Role ? Did you use the  Subject  attribute on  GlossDef ?
If so, did you use a thesaurus of terms? If so, what is it? If you used the  Class  attribute on  RefMiscInfo ,
why and to what effect? If you used  ULink  and provided  URL s that are queries,
what back-end processing is required to resolve those queries? FileRef  or 
 EntityRef  is supplied on every
 Graphic ,
 InlineGraphic ,
 AudioData , 
 ImageData , and
 VideoData  element.  If one is not present, what is the expectation?
 If your  Bibliography s or
 Glossary s have special processing expectations,
such as the ability to display only those entries that are cited,
have you described them?
 If your  Bibliography s contain
 BiblioEntry s, what are the processing expectations?
Which fields are selected for display?
What punctuation is added, and where?
 Do  GlossTerm s or other elements have
implicit linking relationships that must be obeyed or handled in
presentation?
 Did you use any processing instructions? Why and what for?
Are they in entities?
 What copyfitting have you already done, and for what outputs?
 Are the  Revision s in your
 RevHistory s sorted in any particular way?
 Miscellaneous Have you checked your
files for viruses? If you used  BridgeHead , have you joined a recovery
support group? DocBook Quick Reference DocBook  V3.1 Element Brief Description Abbrev Abstract Accel Ackno Acronym Action Address Affiliation Alt Anchor Answer Appendix Application Area AreaSet AreaSpec Arg ArtHeader ArtPageNums Article Attribution AudioData AudioObject Author AuthorBlurb AuthorGroup AuthorInitials BeginPage BiblioDiv BiblioEntry BiblioMSet BiblioMisc BiblioMixed BiblioSet Bibliography BlockQuote Book BookBiblio BookInfo BridgeHead CO Callout CalloutList Caption Caution Chapter Citation CiteRefEntry CiteTitle City ClassName CmdSynopsis ColSpec Collab CollabName Colophon Command Comment ComputerOutput ConfDates ConfGroup ConfNum ConfSponsor ConfTitle Constant ContractNum ContractSponsor Contrib Copyright CorpAuthor CorpName Country Database Date Dedication DocInfo Edition Editor Email Emphasis EnVar Entry EntryTbl Epigraph Equation ErrorCode ErrorName ErrorType Example Fax Figure Filename FirstName FirstTerm Footnote FootnoteRef ForeignPhrase FormalPara FuncDef FuncParams FuncPrototype FuncSynopsis FuncSynopsisInfo Function GUIButton GUIIcon GUILabel GUIMenu GUIMenuItem GUISubmenu GlossDef GlossDiv GlossEntry GlossList GlossSee GlossSeeAlso GlossTerm Glossary Graphic GraphicCO Group Hardware Highlights Holder Honorific ISBN ISSN ITermSet ImageData ImageObject ImageObjectCO Important Index IndexDiv IndexEntry IndexTerm InformalEquation InformalExample InformalFigure InformalTable InlineEquation InlineGraphic InlineMediaObject Interface InterfaceDefinition InvPartNumber IssueNum ItemizedList JobTitle KeyCap KeyCode KeyCombo KeySym Keyword KeywordSet LegalNotice LineAnnotation Lineage Link ListItem Literal LiteralLayout LoT LoTentry ManVolNum Markup MediaLabel MediaObject MediaObjectCO Member MenuChoice ModeSpec MouseButton Msg MsgAud MsgEntry MsgExplan MsgInfo MsgLevel MsgMain MsgOrig MsgRel MsgSet MsgSub MsgText Note OLink ObjectInfo Option Optional OrderedList OrgDiv OrgName OtherAddr OtherCredit OtherName POB PageNums Para ParamDef Parameter Part PartIntro Phone Phrase Postcode Preface Primary PrimaryIE PrintHistory Procedure ProductName ProductNumber ProgramListing ProgramListingCO Prompt Property PubDate Publisher PublisherName PubsNumber QandADiv QandAEntry QandASet Question Quote RefClass RefDescriptor RefEntry RefEntryTitle RefMeta RefMiscInfo RefName RefNameDiv RefPurpose RefSect1 RefSect1Info RefSect2 RefSect2Info RefSect3 RefSect3Info RefSynopsisDiv RefSynopsisDivInfo Reference ReleaseInfo Replaceable ReturnValue RevHistory RevNumber RevRemark Revision Row SBR SGMLTag Screen ScreenCO ScreenInfo ScreenShot Secondary SecondaryIE Sect1 Sect1Info Sect2 Sect2Info Sect3 Sect3Info Sect4 Sect4Info Sect5 Sect5Info Section SectionInfo See SeeAlso SeeAlsoIE SeeIE Seg SegListItem SegTitle SegmentedList SeriesInfo SeriesVolNums Set SetIndex SetInfo ShortAffil Shortcut Sidebar SimPara SimpleList SimpleSect SpanSpec State Step Street StructField StructName SubSteps Subject SubjectSet SubjectTerm Subscript Subtitle Superscript Surname Symbol SynopFragment SynopFragmentRef Synopsis SystemItem TBody TFoot TGroup THead Table Term Tertiary TertiaryIE TextObject Tip Title TitleAbbrev ToC ToCback ToCchap ToCentry ToCfront ToClevel1 ToClevel2 ToClevel3 ToClevel4 ToClevel5 ToCpart Token Trademark Type ULink UserInput VarArgs VarListEntry VarName VariableList VideoData VideoObject Void VolumeNum Warning WordAsWord XRef Year DocBook  V4.1.2 All of the elements in DocBook V3.1  except 
 ArtHeader BookBiblio Comment DocInfo InterfaceDefinition SeriesInfo  plus the following additional elements: Element Brief Description appendixinfo articleinfo bibliographyinfo chapterinfo classsynopsis classsynopsisinfo constructorsynopsis destructorsynopsis exceptionname fieldsynopsis glossaryinfo indexinfo initializer interfacename methodname methodparam methodsynopsis modifier ooclass ooexception oointerface partinfo prefaceinfo refentryinfo referenceinfo remark revdescription setindexinfo sidebarinfo simplemsgentry DocBook  EBNF  Module V1.0 The following elements in addition to the elements in the version
of DocBook to which this module is added: Element Brief Description constraint constraintdef lhs nonterminal production productionrecap productionset rhs DocBook HTML Forms Module V1.0 The  HTML Forms Module  adds
the HTML  Form  element and related elements.
 DocBook MathML Module V1.0 The  MathML Module  adds
the elements from the MathML namespace.
 DocBook SVG Module V1.0 The  SVG Module  adds
the elements from the SVG namespace.
 GNU Free Documentation License Version 1.1, March 2000 Copyright (C) 2000  Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed. PREAMBLE The purpose of this License is to make a manual, textbook,
    or other written document &quot;free&quot; in the sense of freedom: to
    assure everyone the effective freedom to copy and redistribute it,
    with or without modifying it, either commercially or
    noncommercially.  Secondarily, this License preserves for the
    author and publisher a way to get credit for their work, while not
    being considered responsible for modifications made by
    others. This License is a kind of &quot;copyleft&quot;, which means that
    derivative works of the document must themselves be free in the
    same sense.  It complements the GNU General Public License, which
    is a copyleft license designed for free software. We have designed this License in order to use it for manuals
    for free software, because free software needs free documentation:
    a free program should come with manuals providing the same
    freedoms that the software does.  But this License is not limited
    to software manuals; it can be used for any textual work,
    regardless of subject matter or whether it is published as a
    printed book.  We recommend this License principally for works
    whose purpose is instruction or reference. APPLICABILITY AND DEFINITIONS This License applies to any manual or other work that
    contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License.  The &quot;Document&quot;,
    below, refers to any such manual or work.  Any member of the
    public is a licensee, and is addressed as &quot;you&quot;. A &quot;Modified Version&quot; of the Document means any work
    containing the Document or a portion of it, either copied
    verbatim, or with modifications and/or translated into another
    language. A &quot;Secondary Section&quot; is a named appendix or a front-matter
    section of the Document that deals exclusively with the
    relationship of the publishers or authors of the Document to the
    Document&#39;s overall subject (or to related matters) and contains
    nothing that could fall directly within that overall subject.
    (For example, if the Document is in part a textbook of
    mathematics, a Secondary Section may not explain any mathematics.)
    The relationship could be a matter of historical connection with
    the subject or with related matters, or of legal, commercial,
    philosophical, ethical or political position regarding
    them. The &quot;Invariant Sections&quot; are certain Secondary Sections
    whose titles are designated, as being those of Invariant Sections,
    in the notice that says that the Document is released under this
    License. The &quot;Cover Texts&quot; are certain short passages of text that
    are listed, as Front-Cover Texts or Back-Cover Texts, in the
    notice that says that the Document is released under this
    License. A &quot;Transparent&quot; copy of the Document means a
    machine-readable copy, represented in a format whose specification
    is available to the general public, whose contents can be viewed
    and edited directly and straightforwardly with generic text
    editors or (for images composed of pixels) generic paint programs
    or (for drawings) some widely available drawing editor, and that
    is suitable for input to text formatters or for automatic
    translation to a variety of formats suitable for input to text
    formatters.  A copy made in an otherwise Transparent file format
    whose markup has been designed to thwart or discourage subsequent
    modification by readers is not Transparent.  A copy that is not
    &quot;Transparent&quot; is called &quot;Opaque&quot;. Examples of suitable formats for Transparent copies include
    plain ASCII without markup, Texinfo input format, LaTeX input
    format, SGML or XML using a publicly available DTD, and
    standard-conforming simple HTML designed for human modification.
    Opaque formats include PostScript, PDF, proprietary formats that
    can be read and edited only by proprietary word processors, SGML
    or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML produced by some word
    processors for output purposes only. The &quot;Title Page&quot; means, for a printed book, the title page
    itself, plus such following pages as are needed to hold, legibly,
    the material this License requires to appear in the title page.
    For works in formats which do not have any title page as such,
    &quot;Title Page&quot; means the text near the most prominent appearance of
    the work&#39;s title, preceding the beginning of the body of the
    text. VERBATIM COPYING You may copy and distribute the Document in any medium,
    either commercially or noncommercially, provided that this
    License, the copyright notices, and the license notice saying this
    License applies to the Document are reproduced in all copies, and
    that you add no other conditions whatsoever to those of this
    License.  You may not use technical measures to obstruct or
    control the reading or further copying of the copies you make or
    distribute.  However, you may accept compensation in exchange for
    copies.  If you distribute a large enough number of copies you
    must also follow the conditions in section 3. You may also lend copies, under the same conditions stated
    above, and you may publicly display copies. COPYING IN QUANTITY If you publish printed copies of the Document numbering more
    than 100, and the Document&#39;s license notice requires Cover Texts,
    you must enclose the copies in covers that carry, clearly and
    legibly, all these Cover Texts: Front-Cover Texts on the front
    cover, and Back-Cover Texts on the back cover.  Both covers must
    also clearly and legibly identify you as the publisher of these
    copies.  The front cover must present the full title with all
    words of the title equally prominent and visible.  You may add
    other material on the covers in addition.  Copying with changes
    limited to the covers, as long as they preserve the title of the
    Document and satisfy these conditions, can be treated as verbatim
    copying in other respects. If the required texts for either cover are too voluminous to
    fit legibly, you should put the first ones listed (as many as fit
    reasonably) on the actual cover, and continue the rest onto
    adjacent pages. If you publish or distribute Opaque copies of the Document
    numbering more than 100, you must either include a
    machine-readable Transparent copy along with each Opaque copy, or
    state in or with each Opaque copy a publicly-accessible
    computer-network location containing a complete Transparent copy
    of the Document, free of added material, which the general
    network-using public has access to download anonymously at no
    charge using public-standard network protocols.  If you use the
    latter option, you must take reasonably prudent steps, when you
    begin distribution of Opaque copies in quantity, to ensure that
    this Transparent copy will remain thus accessible at the stated
    location until at least one year after the last time you
    distribute an Opaque copy (directly or through your agents or
    retailers) of that edition to the public. It is requested, but not required, that you contact the
    authors of the Document well before redistributing any large
    number of copies, to give them a chance to provide you with an
    updated version of the Document. MODIFICATIONS You may copy and distribute a Modified Version of the
    Document under the conditions of sections 2 and 3 above, provided
    that you release the Modified Version under precisely this
    License, with the Modified Version filling the role of the
    Document, thus licensing distribution and modification of the
    Modified Version to whoever possesses a copy of it.  In addition,
    you must do these things in the Modified Version: Use in the Title Page
      (and on the covers, if any) a title distinct from that of the
      Document, and from those of previous versions (which should, if
      there were any, be listed in the History section of the
      Document).  You may use the same title as a previous version if
      the original publisher of that version gives permission. List on the Title Page,
      as authors, one or more persons or entities responsible for
      authorship of the modifications in the Modified Version,
      together with at least five of the principal authors of the
      Document (all of its principal authors, if it has less than
      five). State on the Title page
      the name of the publisher of the Modified Version, as the
      publisher. Preserve all the
      copyright notices of the Document. Add an appropriate
      copyright notice for your modifications adjacent to the other
      copyright notices. Include, immediately
      after the copyright notices, a license notice giving the public
      permission to use the Modified Version under the terms of this
      License, in the form shown in the Addendum below. Preserve in that license
      notice the full lists of Invariant Sections and required Cover
      Texts given in the Document&#39;s license notice. Include an unaltered
      copy of this License. Preserve the section
      entitled &quot;History&quot;, and its title, and add to it an item stating
      at least the title, year, new authors, and publisher of the
      Modified Version as given on the Title Page.  If there is no
      section entitled &quot;History&quot; in the Document, create one stating
      the title, year, authors, and publisher of the Document as given
      on its Title Page, then add an item describing the Modified
      Version as stated in the previous sentence. Preserve the network
      location, if any, given in the Document for public access to a
      Transparent copy of the Document, and likewise the network
      locations given in the Document for previous versions it was
      based on.  These may be placed in the &quot;History&quot; section.  You
      may omit a network location for a work that was published at
      least four years before the Document itself, or if the original
      publisher of the version it refers to gives permission. In any section entitled
      &quot;Acknowledgements&quot; or &quot;Dedications&quot;, preserve the section&#39;s
      title, and preserve in the section all the substance and tone of
      each of the contributor acknowledgements and/or dedications
      given therein. Preserve all the
      Invariant Sections of the Document, unaltered in their text and
      in their titles.  Section numbers or the equivalent are not
      considered part of the section titles. Delete any section
      entitled &quot;Endorsements&quot;.  Such a section may not be included in
      the Modified Version. Do not retitle any
      existing section as &quot;Endorsements&quot; or to conflict in title with
      any Invariant Section. If the Modified Version includes new front-matter sections
    or appendices that qualify as Secondary Sections and contain no
    material copied from the Document, you may at your option
    designate some or all of these sections as invariant.  To do this,
    add their titles to the list of Invariant Sections in the Modified
    Version&#39;s license notice.  These titles must be distinct from any
    other section titles. You may add a section entitled &quot;Endorsements&quot;, provided it
    contains nothing but endorsements of your Modified Version by
    various parties--for example, statements of peer review or that
    the text has been approved by an organization as the authoritative
    definition of a standard. You may add a passage of up to five words as a Front-Cover
    Text, and a passage of up to 25 words as a Back-Cover Text, to the
    end of the list of Cover Texts in the Modified Version.  Only one
    passage of Front-Cover Text and one of Back-Cover Text may be
    added by (or through arrangements made by) any one entity.  If the
    Document already includes a cover text for the same cover,
    previously added by you or by arrangement made by the same entity
    you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous
    publisher that added the old one. The author(s) and publisher(s) of the Document do not by
    this License give permission to use their names for publicity for
    or to assert or imply endorsement of any Modified Version. COMBINING DOCUMENTS You may combine the Document with other documents released
    under this License, under the terms defined in section 4 above for
    modified versions, provided that you include in the combination
    all of the Invariant Sections of all of the original documents,
    unmodified, and list them all as Invariant Sections of your
    combined work in its license notice. The combined work need only contain one copy of this
    License, and multiple identical Invariant Sections may be replaced
    with a single copy.  If there are multiple Invariant Sections with
    the same name but different contents, make the title of each such
    section unique by adding at the end of it, in parentheses, the
    name of the original author or publisher of that section if known,
    or else a unique number.  Make the same adjustment to the section
    titles in the list of Invariant Sections in the license notice of
    the combined work. In the combination, you must combine any sections entitled
    &quot;History&quot; in the various original documents, forming one section
    entitled &quot;History&quot;; likewise combine any sections entitled
    &quot;Acknowledgements&quot;, and any sections entitled &quot;Dedications&quot;.  You
    must delete all sections entitled &quot;Endorsements.&quot; COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and
    other documents released under this License, and replace the
    individual copies of this License in the various documents with a
    single copy that is included in the collection, provided that you
    follow the rules of this License for verbatim copying of each of
    the documents in all other respects. You may extract a single document from such a collection,
    and distribute it individually under this License, provided you
    insert a copy of this License into the extracted document, and
    follow this License in all other respects regarding verbatim
    copying of that document. AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other
    separate and independent documents or works, in or on a volume of
    a storage or distribution medium, does not as a whole count as a
    Modified Version of the Document, provided no compilation
    copyright is claimed for the compilation.  Such a compilation is
    called an &quot;aggregate&quot;, and this License does not apply to the
    other self-contained works thus compiled with the Document, on
    account of their being thus compiled, if they are not themselves
    derivative works of the Document. If the Cover Text requirement of section 3 is applicable to
    these copies of the Document, then if the Document is less than
    one quarter of the entire aggregate, the Document&#39;s Cover Texts
    may be placed on covers that surround only the Document within the
    aggregate.  Otherwise they must appear on covers around the whole
    aggregate. TRANSLATION Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section
    4.  Replacing Invariant Sections with translations requires
    special permission from their copyright holders, but you may
    include translations of some or all Invariant Sections in addition
    to the original versions of these Invariant Sections.  You may
    include a translation of this License provided that you also
    include the original English version of this License.  In case of
    a disagreement between the translation and the original English
    version of this License, the original English version will
    prevail. TERMINATION You may not copy, modify, sublicense, or distribute the
    Document except as expressly provided for under this License.  Any
    other attempt to copy, modify, sublicense or distribute the
    Document is void, and will automatically terminate your rights
    under this License.  However, parties who have received copies, or
    rights, from you under this License will not have their licenses
    terminated so long as such parties remain in full
    compliance. FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised
    versions of the GNU Free Documentation License from time to time.
    Such new versions will be similar in spirit to the present
    version, but may differ in detail to address new problems or
    concerns.  See  http://www.gnu.org/copyleft/ . Each version of the License is given a distinguishing
    version number.  If the Document specifies that a particular
    numbered version of this License &quot;or any later version&quot; applies to
    it, you have the option of following the terms and conditions
    either of that specified version or of any later version that has
    been published (not as a draft) by the Free Software Foundation.
    If the Document does not specify a version number of this License,
    you may choose any version ever published (not as a draft) by the
    Free Software Foundation. How to use this License for your documents To use this License in a document you have written, include
    a copy of the License in the document and put the following
    copyright and license notices just after the title page: 
      Copyright (c)  YEAR  YOUR NAME.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
      A copy of the license is included in the section entitled &quot;GNU
      Free Documentation License&quot;.
 If you have no Invariant Sections, write &quot;with no Invariant
    Sections&quot; instead of saying which ones are invariant.  If you have
    no Front-Cover Texts, write &quot;no Front-Cover Texts&quot; instead of
    &quot;Front-Cover Texts being LIST&quot;; likewise for Back-Cover
    Texts. If your document contains nontrivial examples of program
    code, we recommend releasing these examples in parallel under your
    choice of free software license, such as the GNU General Public
    License, to permit their use in free software. $Date: 2006-02-17 00:11:15 +0300 (Пт, 17 фев 2006) $ $Revision: 5566 $ ChangeLog This appendix details the changes made between versions. Version 2.0.14: Changes since version 2.0.12 (2005-04-18) I forgot to update the  ChangeLog  for
version 2.0.13. That&#39;s the difference between 2.0.13 and 2.0.14.
This change log is slightly abbreviated; there were hundreds of uninteresting
changes to generated files. Version 2.0.12: Changes since version 2.0.10 (2004-05-19) I forgot to update the  ChangeLog  for
version 2.0.11. That&#39;s the difference between 2.0.11 and 2.0.12.
This change log is slightly abbreviated; there were hundreds of uninteresting
changes to generated files. Version 2.0.10: Changes since version 2.0.9 (2003-12-31) Version 2.0.9: Changes since version 2.0.8 (2003-01-01) Changes since version 2.0.7 (2002-06-17) 
 
 
 
 

 Introduction 
 
 
 
 
 
 

 

 Appendixes 
 
 
 
 
 
 
 
 
 
 

 

 
 
 $Date: 2002-12-29 22:37:30 +0300 (Вс, 29 дек 2002) $ $Revision: 2356 $ Preface 
DocBook provides a system for writing structured documents using
  or  . It is particularly well-suited to books and papers
about computer hardware and software, though it is by no means limited
to them.  DocBook is a document type definition ( ).
Because it is a large and robust  , and because its
main structures correspond to the general notion of what constitutes a
book, DocBook has been adopted by a large and growing community of
authors. DocBook is supported  out of the box  by a number
of commercial tools, and support for it is rapidly growing in a number
of free software environments. In short, DocBook is an
easy-to-understand and widely used  . Dozens of organizations use
DocBook for millions of pages of documentation, in various print
and online formats, worldwide.
 Why Read This Book? 
This book is designed to be the clear, concise, normative reference to
the DocBook  . This book is the official documentation for the
DocBook  .
 
We hope to answer, definitively, all the questions you might
have about all the elements and entities in DocBook.  In
particular, we cover the following subjects: The general nature of DocBook. With over 300 elements,
DocBook can be a bit overwhelming at first. We quickly get you up to
speed on how the pieces fit together. How to write DocBook documents. Where should you start
and what should you do? Parsing and validation. After you&#39;ve written a
document, how can you tell if it really conforms to the DocBook
 ? How to publish DocBook documents. After you&#39;ve written
one, what do you do with it? We provide a guide to using some popular
free tools to publish DocBook documents both in print and on the
Web. Customizing the  . Many individuals and
corporations have standardized on the DocBook  . Whether your
subject matter is computer software documentation or not,
we explain how you can write a  customization layer  to
tailor DocBook explicitly for your information. Understanding all of the elements. Each element is
extensively documented, including the intended semantics and the
purpose of all its attributes. An example of proper usage is given
for every element. The parameter entities and character entities are
also described.
 Stylesheets. Several standard stylesheet
languages are briefly described.  compatability. We outline all of the points that
you&#39;ll need to consider
as you or your organization contemplate   for authoring, publishing, or
both. Additional resources and a
 CD-ROM . Finally, we direct you to other places you
can go for all the latest info, and offer a complete set of online
documentation on the  CD-ROM . This Book&#39;s Audience 
We expect that most readers will have some familiarity with   or
 . Even if your experience goes no farther than writing a few
  pages, you&#39;re probably in good shape.  Although we provide an
introduction to  ,  , and structured markup, this book may
not suffice as your only tutorial about   and  . This
depends, naturally, on your needs and experience.  For a list of some
other good resources, consult  .
 
Some sections of this book describe tools and applications. For
the most part, these are Microsoft Windows or   applications,
although there&#39;s nothing about DocBook that makes it unsuitable for the
Mac or  VM/CMS  or any other operating system of your
choice.
 Organization of This Book This book is divided into three parts.  Part I: Introduction
  is an introduction to structured markup and DocBook: A quick introduction to structured markup. How to make DocBook documents. Parsing and validating DocBook documents. How to publish DocBook documents. How to customize DocBook. Part II: Reference 
is a complete reference to every element and parameter entity in
the DocBook    .
 
is a complete reference to every element in the DocBook
    and provides a concise summary of the
parameter entities. For a detailed reference to the parameter
entities, consult the online version available either on  the  CD-ROM  or the
 web site .
 A reference guide to the DocBook elements. A reference guide to the DocBook parameter entities. A reference guide to the character entities declared in DocBook. Part III: Appendixes  discusses other resources:
 How to install DocBook, Jade, and the stylesheets. DocBook as  . A guide to DocBook versions, including a summary of the features
expected in future releases. Other resources. What&#39;s on the  CD ? An interchange checklist. Things to consider when you&#39;re sharing
DocBook documents with others. A Quick Reference to the elements in DocBook. At the end of this book you&#39;ll find a  Glossary
  and an
 
 Index . 
 Index. 
 Conventions Used in This Book Garamond Book  is used for element and
attribute names.
 Constant Willison 
is used for program examples, attribute value
literals, start- and end-tags, and source code example text.
 Constant Willison Oblique  is used for
 replaceable  text or variables.  Replaceable text is text
that describes something you&#39;re supposed to type, like a
 filename , in which the word
 filename  is a placeholder for the actual filename. Garamond Italic  is used for filenames and (in the print version
of the book)  URL s.
 URL s  are
presented in parentheses after the name of the resource they describe
in the print version of the book.
 Getting This Book 
If you want to hold this book in your hand and flip through its pages,
you have to buy it as you would any other book. You can also get this
book in electronic form, as a DocBook   document, and in  ,
either on the  CD  that accompanies the bound book or
from this book&#39;s web site:
 .
 Getting Examples from This Book 
All of the examples are included on the  CD-ROM  and
online at the book&#39;s web site.  You can get the most up-to-date
information about this book from the web site:  http://docbook.org/ . Getting DocBook 
The DocBook   is included  on the
 CD-ROM . You can get the most up-to-date
version and information about DocBook from the DocBook web page:
 http://www.oasis-open.org/docbook/ . Request for Comments 
Please help us improve future editions of this book by reporting any
errors, inaccuracies, bugs, misleading or confusing statements, and
plain old typos that you find. An online errata list is maintained at
 http://docbook.org/tdg/errata.html .
Email your bug reports and comments to us at  bookcomments@docbook.org . Acknowledgements from Norm This book has been in the works for a long
time. It could not have been completed without the help and
encouragement of a lot of people, most especially my wife,
Deborah, who supported me through the long hours and the late
nights.
 
I also want to thank Lenny for collaborating with me and developing
real prose out of my rough outlines, cryptic email messages, and
scribbled notes. 
A number of people contributed technical feedback as this book
was being written, in particular Terry Allen and Eve Maler. I
owe most of what I know about   to them, and to the other
members of the Davenport Group who answered all my questions so
many years ago, especially Jon Bosak, Eduardo Guttentag, and
Murray Maloney. Paul Prescod, Mark Galassi, and Dave Pawson also
provided invaluable feedback on the technical review draft. It&#39;s
a better book because of them.
 Acknowledgements from Lenny My gratitude goes back to Dale Dougherty and Terry Allen, who
long ago encouraged me and the production department at O&#39;Reilly to learn
 ; and to Lar Kaufman, who also made large contributions to my 
knowledge and appreciation of  . But my greatest debt of thanks goes to 
Norm for all that he patiently taught me about DocBook, and for his
supreme graciousness in keeping me a part of this project. 
 Acknowledgements from Norm and Lenny 
Thanks finally to the great people at O&#39;Reilly who encouraged us to
write it (Frank Willison and Sheryl Avruch), agreed to edit it
(Frank), helped design it (Alicia Cech, who worked on the interior
design, and Edie Freeman, who designed the cover), proofed and
produced it (Chris Maden, Madeline Newell, and David Futato), and
indexed it (Ellen Troutman).
 

 
 $Date: 2002-12-29 23:20:58 +0300 (Вс, 29 дек 2002) $ $Revision: 2357 $ Getting Started with  / SGML getting started XML getting started 

This chapter is intended to provide a quick introduction to structured
markup (  and  ). If you&#39;re already familiar with   or
 , you only need to skim this chapter.
 
To work with DocBook, you need to understand a few basic concepts of
structured editing in general, and DocBook, in particular. That&#39;s
covered here. You also need some concrete experience with the way a
DocBook document is structured. That&#39;s covered in the next chapter.
  and   vs.  HTML XML vs. Hypertext Markup Language HTML SGML HTML vs. 

This chapter doesn&#39;t assume that you know what   is, but if you
do, you have a starting point for understanding structured
markup.   (Hypertext Markup Language) is a way of marking up text
and graphics so that the most popular web browsers can interpret
them.   consists of a set of markup tags with specific
meanings. Moreover,   is a very basic type of   markup that
is easy to learn and easy for computer applications to generate. But
the simplicity of   is both its virtue and its weakness. Because
of  &#39;s limitations, web users and programmers have had to extend
and enhance it by a series of customizations and revisions that still
fall short of accommodating current, to say nothing of future, needs.
 


 , on the other hand, is an international standard that describes
how markup languages are defined.   does not consist of
particular tags or the rules for their usage.   is an example of
a markup language defined in  .
 XML HTML and SGML vs. 

  promises an intelligent improvement over  , and
compatibility with it is already being built into the most popular web
browsers.   is not a new markup language designed to compete with
 , and it&#39;s not designed to create conversion headaches for people
with tons of   documents.   is intended to alleviate
compatibility problems with browser software; it&#39;s a new, easier
version of the standard rules that govern the markup itself, or, in
other words, a new version of  . The rules of   are designed
to make it easier to write both applications that interpret its type
of markup and applications that generate its markup.   was
developed by a team of   experts who understood and sought to
correct the problems of learning and implementing  .   is
also  extensible  markup, which means that it is
customizable. A browser or word processor that is  -capable will
be able to read any  -based markup language that an individual
user defines.
 
In this book, we tend to describe things in terms of  , but where
there are differences between   and   (and there are only a
few), we point them out. For our purposes, it doesn&#39;t really matter
whether you use   or  .
 
During the coming months, we anticipate that  -aware web browsers
and other tools will become available. Nevertheless, it&#39;s not
unreasonable to do your authoring in   and your online publishing
in   or  . By the same token, it&#39;s not unreasonable to do
your authoring in  .
 Basic  /  Concepts SGML basic concepts XML basic concepts XML basic concepts structured semantic markup language SGML 

Here are the basic  /  concepts you need to grasp: structured, semantic markup elements attributes entities Structured and Semantic Markup appearance SGML and structured markup semantic markup 

An essential characteristic of structured markup is that it explicitly
distinguishes (and accordingly  marks up  within a
document) the structure and semantic content of a document. It does
not mark up the way in which the document will appear to the reader,
in print or otherwise.
 
In the days before word processors it was common for a typed
manuscript to be submitted to a publisher. The manuscript identified
the logical structures of the documents (chapters, section titles, and
so on), but said nothing about its appearance. Working independently
of the author, a designer then developed a specification for the
appearance of the document, and a typesetter marked up and applied the
designer&#39;s format to the document.
 presentation appearance HTML appearance, limitions of specification 

Because presentation or appearance is usually based on structure and
content,   markup logically precedes and generally determines the
way a document will look to a reader. If you are familiar with strict,
simple   markup, you know that a given document that is
structurally the same can also look different on different
computers. That&#39;s because the markup does not specify many aspects of
a document&#39;s appearance, although it does specify many aspects of a
document&#39;s structure.
 text formatting word processors, SGML/XML vs. 
Many writers type their text into a word processor, line-by-line and
word-for-word, italicizing technical terms, underlining words for
emphasis, or setting section headers in a font complementary to the
body text, and finally, setting the headers off with a few carriage
returns fore and aft. The format such a writer imposes on the words on
the screen imparts structure to the document by changing its
appearance in ways that a reader can more or less reliably decode.
The reliability depends on how consistently and unambiguously the
changes in type and layout are made. By contrast, an  / 
markup of a section header explicitly specifies that a specific piece
of text is a section header. This assertion does not specify the
presentation or appearance of the section header, but it makes the
fact that the text is a section header completely unambiguous.
 elements SGML/XML, using titles top-level sections top-level sections characters character sets SGML documents ASCII character set XML Unicode character set Unicode character set XML documents, using 

  and   use named elements, delimited by angle brackets
( &lt;  and  &gt; ) to identify the markup in a
document. In DocBook, a top-level section is  sect1 , so the title of a top-level section
named  My First-Level Header  would be identified
like this:
 &lt;sect1&gt;&lt;title&gt;My First-Level Header&lt;/title&gt;  Note the following features of this markup: Clarity A title begins with  
title  and ends with  title . The  sect1  also has
an ending  sect1 , but we haven&#39;t
shown the whole section so it&#39;s not visible. Hierarchy My First-Level
Header  is the title of a top-level section because it occurs
inside a title in a  sect1 . A
 title  element occurring somewhere else, say in a
 Chapter  element, would be the title of the
chapter. Plain text  documents can have varying character sets, but
most are  ASCII .   documents use the Unicode
character set. This makes   and   documents highly portable
across systems and tools. appearance SGML and formatting SGML documents filenames tags, specifying semantic content, SGML marking for 

In an   document, there is no obligatory difference between the
size or face of the type in a first-level section header and the title
of a book in a footnote or the first sentence of a body paragraph. All
  files are simple text files without font changes or special
characters. Some structured editors apply style to the
document while it&#39;s being edited, using fonts and color to make the
editing task easier, but this stylistic information is not stored in
the actual  /  document. Instead, it is provided by the
editing application.  Similarly, an   document
does not specify the words in a text that are to be set in italic,
bold, or roman type. Instead,   marks certain kinds of texts for
their semantic content. For example, if a particular word is the name
of a file, then the tags around it should specify that it is a
filename:
 Many mail programs read configuration information from the
users  filename .mailrc filename  file. stylesheets SGML documents, specifying appearance appearance structure or content vs. CSS stylesheets FOSI stylesheets DSSSL stylesheets XSL stylesheets XML XSL stylesheets 

If the meaning of a phrase is particularly audacious, it might get
tagged for boldness of thought instead of appearance. An  
document contains all the information that a typesetter needs to lay
out and typeset a printed page in the most effective and consistent
way, but it does not specify the layout or the
type. The distinction between appearance or
presentation and structure or content is essential to  , but
there is a way to specify the appearance of an   document: attach
a stylesheet to it. There are several standards for such stylesheets:
 CSS ,  XSL ,  FOSI s,
and  DSSSL .
See  . 
 DocBook DTD document type definition declarations SGML documents document type definitions DTDs tags names document type definition combination rules (DTD) DTDs DTDs DocBook DocBook DTD 


Not only is the structure of an  /  document explicit, but it
is also carefully controlled. An   document makes reference to a
set of declarations a document type definition
( ) that contains an inventory of tag names and specifies
the combination rules for the various structural and semantic features
that make up a document. What the distinctive features are and how
they should be combined is  arbitrary  in the sense that
almost any selection of features and rules of composition is
theoretically possible. The DocBook   chooses a particular set of
features and rules for its users.
 sections ordering, DocBook DTD rules (example) 
Here is a specific example of how the DocBook   works. DocBook
specifies that a third-level section can follow a second-level section
but cannot follow a first-level section without an intervening
second-level section.
 This is valid: &lt;sect1&gt;&lt;title&gt;...&lt;/title&gt;
  &lt;sect2&gt;&lt;title&gt;...&lt;/title&gt;
    &lt;sect3&gt;&lt;title&gt;...&lt;/title&gt;
      ...
    &lt;/sect3&gt;
  &lt;/sect2&gt;
&lt;/sect1&gt;
 This is not: &lt;sect1&gt;&lt;title&gt;...&lt;/title&gt;
  &lt;sect3&gt;&lt;title&gt;...&lt;/title&gt;
    ...
  &lt;/sect3&gt;
&lt;/sect1&gt;
 parsers validating validation SGML documents DTDs validating SGML documents against instance (DocBook document) 

Because an  /  document has an associated   that
describes the valid, logical structures of the document, you can test
the logical structure of any particular document against the
 . This process is performed by a  parser . An
  processor must begin by parsing the document and determining if
it is valid, that is, if it conforms to the rules specified in the
 .   processors are not required to
check for validity, but it&#39;s always a good idea to check for validity
when authoring.  Because you can test and validate the
structure of an  /  document with software, a DocBook
document containing a first-level section followed immediately by a
third-level section will be identified as invalid, meaning that it&#39;s
not a valid  instance  or example of a document
defined by the DocBook  . Presumably, a document with a logical
structure won&#39;t normally jump from a first- to a third-level section,
so the rule is a safeguard but not a guarantee of good
writing, or at the very least, reasonable structure. A parser also
verifies that the names of the tags are correct and that tags
requiring an ending tag have them. This means that a valid document is
also one that should format correctly, without runs of paragraphs
incorrectly appearing in bold type or similar monstrosities that
everyone has seen in print at one time or another. For more
information about  /  parsers, see  .
 
In general, adherence to the explicit rules of structure and markup in
a   is a useful and reassuring guarantee of consistency and
reliability within documents, across document sets, and over
time. This makes  /  markup particularly desirable to
corporations or governments that have large sets of documents to
manage, but it is a boon to the individual writer as well.
 How can this markup help you? semantic markup presentation media, different 
Semantic markup makes your documents more amenable to interpretation
by software, especially publishing software. You can publish a white
paper, authored as a DocBook  Article , in the
following formats:
 articles formats, listed 
 journal articles 

 On the Web in  As a standalone document on 8 11 paper As part of a quarterly journal, in a 6 9 format
 In Braille In audio 
You can produce each of these publications from exactly the same
source document using the presentational techniques best suited to
both the content of the document and the presentation medium. This
versatility also frees the author to concentrate on the document
content. For example, as we write this book, we don&#39;t know exactly how
O&#39;Reilly will choose to present chapter headings, bulleted lists,
  terms, or any of the other semantic features. And we don&#39;t
care. It&#39;s irrelevant; whatever presentation is chosen, the  
sources will be transformed automatically into that style.
 
Semantic markup can relieve the author of other, more significant
burdens as well (after all, careful use of paragraph and character
styles in a word processor document theoretically allows us to change
the presentation independently from the document). Using semantic
markup opens up your documents to a world of possibilities. Documents
become, in a loose sense, databases of information. Programs can
compile, retrieve, and otherwise manipulate the documents in
predictable, useful ways.
 links SGML documents, maintaining elements linking to references 

Consider the online version of this book: almost every element name
( Article ,  Book , and so on) is a
hyperlink to the reference page that describes that
element. Maintaining these links by hand would be tedious and might be
unreliable, as well. Instead, every element name is marked as an
element using  SGMLTag : a  Book  is
a  sgmltag Book sgmltag .
 
Because each element name in this book is tagged semantically, the
program that produces the online version can determine which
occurrences of the word  book  in the text are actually
references to the  Book  element. The program can
then automatically generate the appropriate hyperlink when it should.
 
There&#39;s one last point to make about the versatility of  
documents: how much you have depends on the  . If you take a good
photo with a high resolution lens, you can print it and copy it and
scan it and put it on the Web, and it will look good. If you start
with a low-resolution picture it will not survive those
transformations so well. DocBook  /  has this advantage over,
say,  : DocBook has specific and unambiguous semantic and
structural markup, because you can convert its documents with ease
into other presentational forms, and search them more precisely. If
you start with  , whose markup is at a lower resolution than
DocBook&#39;s, your versatility and searchability is substantially
restricted and cannot be improved.
 What are the shortcomings to structural authoring? 
There are a few significant shortcomings to structured authoring:
 It requires a significant change in the authoring
process. Writing structured documents is very different from writing
with a typical word processor, and change is difficult. In particular,
authors don&#39;t like giving up control over the appearance of their
words especially now that they have acquired it with the advent of
word processors. But many publishing companies need authors to
relinquish that control, because book design and production remains
their job, not their authors&#39;. Because semantics are separate from appearance, in
order to publish an  /  document, a stylesheet or other tool
must create the presentational form from the structural form. Writing
stylesheets is a skill in its own right, and though not every author
among a group of authors has to learn how to write them, someone has
to. Authoring tools for   documents can generally be
pretty expensive. While it&#39;s not entirely unreasonable to edit
 /  documents with a simple text editor, it&#39;s a bit tedious
to do so. However, there are a few free tools that are
 -aware. The widespread interest in   may well produce new,
clever, and less expensive   editing tools. Elements and Attributes elements attributes attributes elements and elements attributes attributes empty elements end tags empty elements, not requiring cross references entities SGML/XML markup 

 /  markup consists primarily of
 elements ,  attributes ,
and  entities . Elements are the terms we have
been speaking about most, like  sect1 , that describe
a document&#39;s content and structure. Most elements are represented by pairs
of tags and
mark the start and end of the construct they surround for
example, the   source for this particular paragraph begins with a
 para  tag and ends with a  para  tag. Some elements are
 empty  (such as DocBook&#39;s cross-reference element,
 xref ) and require no end
tag. In  , this is written as
 &lt;xref/&gt; , as we&#39;ll see in the section  . 
 ID attribute SGML start tags tags identifiers (SGML) end tags attributes and start tags attribute ID, containing 

Elements can, but don&#39;t necessarily, include one or more attributes,
which are additional terms that extend the function or refine the
content of a given element. For instance, in DocBook a  sect1  start tag can contain an
identifier an  id 
attribute that will ultimately allow the writer to
cross-reference it or enable a reader to retrieve it. End tags cannot
contain attributes. A  sect1 
element with an  id  attribute
looks like this:
 &lt;sect1 id=&quot; idvalue &quot;&gt; namespaces XML tags tags namespaces (XML) validation namespace tags (XML), problems XML namespaces, using 

In  , the catalog of attributes that can occur on an element is
predefined. You cannot add arbitrary attribute names to an
element. Similarly, the values allowed for each attribute are
predefined. In  , the use of  namespaces  may allow you
to add additional attributes to an element, but as of this writing,
there&#39;s no way to perform validation on those attributes.
 SystemItem element subdividing into URL and email addresses Role attribute systemitem tags, subdividing 

The  id  attribute is one half of a
cross reference. An  idref 
attribute on another element, for example  xref linkend= idvalue 
 , provides the other half. These attributes provide whatever
application might process the   source with the data needed
either to make a hypertext link or to substitute a named and/or numbered cross
reference in place of the  
xref . Another use for attributes is to specify subclasses of
certain elements. For instance, you can subdivide DocBook&#39;s  systemitem  into  URL s and
email addresses by making the content of the  role  attribute the distinction between
them, as in  systemitem role=&quot;URL&quot; 
versus  systemitem
role=&quot;emailaddr&quot; .
 Entities entities functions parsed entities unparsed entities names assigning to data (entities) 

Entities are a fundamental concept in   and  , and can be
somewhat daunting at first. They serve a number of related, but
slightly different functions, and this makes them a little bit
complicated.
 
In the most general terms, entities allow you to assign a name to some
chunk of data, and use that name to refer to that data. The complexity
arises because there are two different contexts in which you can use
entities (in the   and in your documents), two types of entities
(parsed and unparsed), and two or three different ways in which the
entities can point to the chunk of data that they name.
 
In the rest of this section, we&#39;ll describe each of the commonly
encountered entity types. If you find the material in this section
confusing, feel free to skip over it now and come back to it later.
We&#39;ll refer to the different types of entities as the need arises in
our discussion of DocBook. Come back to this section when you&#39;re
looking for more detail.
 
Entities can be divided into two broad categories,  general
entities  and  parameter entities .
Parameter entities are most often used in the  , not in documents,
so we&#39;ll describe them last. Before you can use any type of entity, it
must be formally declared. This is typically done in the document
prologue, as we&#39;ll explain in  , but we will
show you how to declare each of the entities discussed here.
 General Entities general entities external and internal entities general 
In use, general entities are introduced with an ampersand (&amp;) and end with
a semicolon (;). Within the category of general entities, there are
two types:  internal general entities  and
 external general entities .
 Internal general entities internal general entities names text, associating with (internal general entities) text entity, declaring as 

With internal entities, you can associate an essentially arbitrary
piece of text (which may have other markup, including references to
other entities) with a name. You can then include that text by
referring to its name. For example, if your document frequently refers
to, say,  O&#39;Reilly &amp; Associates,  you might declare it
as an entity:
 &lt;!ENTITY ora &quot;O&#39;Reilly &amp;amp; Associates&quot;&gt; 
Then, instead of typing it out each time, you can insert it as needed
in your document with the entity reference  ora , simply to save time. Note that this
entity declaration includes another entity reference within it.
That&#39;s perfectly valid as long as the reference isn&#39;t directly or
indirectly recursive.
 entities adding directly to DTD 

If you find that you use a number of entities across many documents,
you can add them directly to the   and avoid having to include the
declarations in each document. See the discussion of
 dbgenent.mod  in  .
 External general entities external general entities SGML external documents, referencing (external general entities) parsers external file text, inserting files external, referencing 

With external entities, you can reference other documents from within
your document. If these entities contain document text (  or
 ), then references to them cause the parser to insert the text of
the external file directly into your document (these are called parsed
entities). In this way, you can use entities to divide your single,
logical document into physically distinct chunks. For example, you
might break your document into four chapters and store them in
separate files. At the top of your document, you would include entity
declarations to reference the four files:
 &lt;!ENTITY ch01 SYSTEM &quot;ch01.sgm&quot;&gt;
&lt;!ENTITY ch02 SYSTEM &quot;ch02.sgm&quot;&gt;
&lt;!ENTITY ch03 SYSTEM &quot;ch03.sgm&quot;&gt;
&lt;!ENTITY ch04 SYSTEM &quot;ch04.sgm&quot;&gt; 
Your  Book  now consists simply of references to the
entities:
 &lt;book&gt;
&amp;ch01;
&amp;ch02;
&amp;ch03;
&amp;ch04;
&lt;/book&gt; unparsed entities notations (unparsed entities) 

Sometimes it&#39;s useful to reference external files that don&#39;t contain
document text. For example, you might want to reference an external
graphic. You can do this with entities by declaring the type of data
that&#39;s in the entity using a notation (these are called unparsed
entities). For example, the following declaration declares the entity
 tree  as an encapsulated PostScript image:
 &lt;!ENTITY tree SYSTEM &quot;tree.eps&quot; NDATA EPS&gt; elements entity attributes 

Entities declared this way cannot be inserted directly into your
document. Instead, they must be used as entity attributes to elements:
 &lt;graphic entityref=&quot;tree&quot;&gt;&lt;/graphic&gt; 
Conversely, you cannot use entities declared without a notation as the
value of an entity attribute.
 Special characters markup distinguishing from content start tags beginning end tags beginning 
In order for the parser to recognize markup in your document, it must
be able to distinguish markup from content. It does this with two
special characters:  &lt;,  which identifies the beginning
of a start or end tag, and  &amp;,  which identifies the
beginning of an entity reference. start characters, changing 
In  , these characters are fixed. In  , it is possible to
change the markup start characters, but we won&#39;t consider that case
here. If you change the markup start characters, you know what you&#39;re
doing. While we&#39;re on the subject, in  , these characters only
have their special meaning if they are followed by a name character.
It is, in fact, valid in an   (but not an  )
document to write  O&#39;Reilly &amp; Associates  because the
ampersand is not followed by a name character. Don&#39;t do this, however.
 characters entities encoding as 
 entities characters 
 angle brackets coding as entities 
 
If you want these characters to have their literal value, they must be
encoded as entity references in your document. The entity reference
 lt  produces a left angle bracket;
 amp  produces the
ampersand. marked sections character sequence, ending 

The sequence of characters that end a marked section (see  ), such as ]]&gt; must also be encoded with at least
one entity reference if it is not being used to end a marked section.
For this purpose, you can use the entity reference  gt  for the final right angle bracket.
 
 parsers entity references, interpreting 

If you do not encode each of these as their respective entity
references, then an   parser or application is likely to
interpret them as characters introducing elements or entities (an
  parser will always interpret them this way); consequently, they
won&#39;t appear as you intended. If you wish to cite text that contains
literal ampersands and less-than signs, you need to transform these
two characters into entity references before they are included in a
DocBook document. The only other alternative is to incorporate text
that includes them in your document through some process that avoids
the parser.
 data entities numeric character references 

In  , character entities are frequently declared using a third
entity category (one that we deliberately chose to overlook), called
 data entities . In  , these are declared using
numeric character references. Numeric character references resemble
entity references, but technically aren&#39;t the same. They have the form
 &amp;# 999 ; , in which
 999  is the numeric character number.
 Unicode character set character numbers (XML) hexadecimal numeric character references (XML) 

In  , the numeric character number is always the Unicode character
number. In addition,   allows hexadecimal numeric character
references of the form
 &amp;#x hhhh ; . In  , the
numeric character number is a number from the document character set
that&#39;s declared in the   declaration.
 special characters, encoding as entities 

Character entities are also used to give a name to special characters
that can&#39;t otherwise be typed or are not portable across applications
and operating systems. You can then include these characters in your
document by refering to their entity name. Instead of using the often
obscure and inconsistent key combinations of your particular word
processor to type, say, an uppercase letter U with an umlaut ( ),
you type in an entity for it instead. For instance, the entity for an
uppercase letter U with an umlaut has been defined as the entity
 Uuml , so you would type in  Uuml  to reference it instead of the actual
character. The   application that eventually processes your
document for presentation will match the entity to your platform&#39;s
handling of special characters in order to render it
appropriately.
 Parameter Entities entities parameter entities parameter entities parameter entities 

Parameter entities are only recognized in markup declarations (in the
 , for example). Instead of beginning with an ampersand, they
begin with a percent sign.  Parameter entities are most frequently
used to customize the  . For a detailed discussion of this topic,
see  . Following are some other uses for
them.
 Marked sections marked sections SGML marked sections XML marked sections 

You might use a parameter entity reference in an   document in a
marked section. Marking sections is a mechanism for indicating that
special processing should apply to a particular block of text.  Marked
sections are introduced by the special sequence
 &lt;![ keyword [  and end
with  ]]&gt; .  In  , marked sections can appear
in both  s and document instances.  In  , they&#39;re only allowed
in the  . CDATA marked sections 
Actually, CDATA marked sections are allowed in an   document, but
the keyword cannot be a parameter entity, and it must be typed
literally. See the examples on this page.
 
 keywords marked sections INCLUDE keyword (marked section) IGNORE keyword (marked section) 

The most common keywords are  INCLUDE , which
indicates that the text in the marked section should be included in
the document;  IGNORE , which indicates that the text
in the marked section should be ignored (it completely disappears from
the parsed document); and  CDATA , which indicates
that all markup characters within that section should be ignored
except for the closing characters  ]]&gt; .
 SGML keywords as parameter entities 
In  , these keywords can be parameter entities. For example, you
might declare the following parameter entity in your document:
 &lt;!ENTITY % draft &quot;INCLUDE&quot;&gt; 
Then you could put the sections of the document that are only applicable
in a draft within marked sections:
 &lt;![%draft;[
&lt;para&gt;
This paragraph only appears in the draft version.
&lt;/para&gt;
]]&gt; 
When you&#39;re ready to print the final version, simply change the 
 draft  parameter entity declaration:
 &lt;!ENTITY % draft &quot;IGNORE&quot;&gt; 
and publish the document. None of the draft sections will appear.
 
 
 How Does DocBook Fit In? DocBook DTD history and overview 

DocBook is a very popular set of tags for describing books, articles,
and other prose documents, particularly technical
documentation. DocBook is defined using the native   syntax of
  and  . Like  , DocBook is an example of a markup
language defined in  / .
 A Short DocBook History 
DocBook is almost 10 years old. It began in 1991 as a joint project of
HaL Computer Systems and O&#39;Reilly. Its popularity grew, and eventually
it spawned its own maintenance organization, the Davenport Group. In
mid-1998, it became a Technical Committee ( TC ) of
the Organization for the Advancement of Structured Information
Standards ( OASIS ).
 The HaL and O&#39;Reilly era Open Software Foundation troff markup (UNIX documentation) UNIX DocBook DTD, development 

The DocBook   was originally designed and implemented by HaL
Computer Systems and O&#39;Reilly &amp; Associates around 1991. It was
developed primarily to facilitate the exchange of   documentation
originally marked up in  troff . Its design appears
to have been based partly on input from   interchange projects
conducted by the Unix International and Open Software Foundation
consortia.
 Davenport Group (DocBook maintenance) 
When DocBook  V1.1  was published, discussion about
its revision and maintenance began in earnest in the Davenport Group,
a forum created by O&#39;Reilly for computer documentation
producers. Version 1.2 was influenced strongly by
Novell and Digital.
 
In 1994, the Davenport Group became an officially chartered entity
responsible for DocBook&#39;s maintenance. DocBook
 V1.2.2  was published simultaneously. The founding
sponsors of this incarnation of Davenport include the following
people:
 Jon Bosak, Novell Dale Dougherty, O&#39;Reilly &amp; Associates Ralph Ferris, Fujitsu  OSSI Dave Hollander, Hewlett-Packard Eve Maler, Digital Equipment Corporation Murray Maloney,  SCO Conleth O&#39;Connell, HaL Computer Systems Nancy Paisner, Hitachi Computer Products Mike Rogers, SunSoft Jean Tappan, Unisys 
 The Davenport era 
Under the auspices of the Davenport Group, the DocBook   began to
widen its scope. It was now being used by a much wider audience, and
for new purposes, such as direct authoring with  -aware tools,
and publishing directly to paper. As the largest users of DocBook,
Novell and Sun had a heavy influence on its design.
 DocBook DTD releases, rules for new versions 

In order to help users manage change, the new Davenport charter established
the following rules for DocBook releases:
 Minor versions ( point releases  such as
 V2.2 ) could add to the markup model, but could not
change it in a backward-incompatible way. For example, a new kind of
list element could be added, but it would not be acceptable for the
existing itemized-list model to start requiring two list items inside
it instead of only one. Thus, any document conforming to version
 n .0 would also conform to
 n . m . Major versions (such as  V3.0 ) could
both add to the markup model and make backward-incompatible
changes. However, the changes would have to be announced in the last
major release. Major-version introductions must be separated by at
least a year. 
 DocBook DTD XML XML-compliant version XML DocBook version compliant with V3.0  was released in January 1997. After that time,
although DocBook&#39;s audience continued to grow, many of the Davenport
Group stalwarts became involved in the   effort, and development
slowed dramatically. The idea of creating an official  -compliant
version of DocBook was discussed, but not implemented. (For more
detailed information about DocBook  V3.0  and plans
for subsequent versions, see  .)
 OASIS DocBook Technical Committee 

The sponsors wanted to close out Davenport in an orderly way to ensure
that DocBook users would be supported. It was suggested that
 OASIS  become DocBook&#39;s new home. An
 OASIS  DocBook Technical Committee was formed in
July, 1998, with Eduardo Gutentag of Sun Microsystems as chair.
 The  OASIS  era 
The  DocBook Technical
Commitee  is continuing the work started by the
Davenport Group. The transition from Davenport to
 OASIS  has been very smooth, in part because the
core design team consists of essentially the same individuals (we all
just changed hats).
 
DocBook  V3.1 , published in February 1999, was the
first  OASIS  release.  It integrated a number of
changes that had been  in the wings  for some time.
 In February of 2001, OASIS made DocBook SGML V4.1 and DocBook XML V4.1.2
 official
OASIS Specifications .
 Version 4.2  of the DocBook  , for both   and  , was
released in July 2002. 
The committee continues new DocBook development to ensure
that the   continues to meet the needs of its users.  Forthcoming
and experimental work includes:
 A V5.0 DTD projected for release no earlier than the end of
2002.
 Experimental
 RELAX NG  schemas
 available . Experimental
 W3C XML Schema  versions
 available . Experimental
 RELAX  schemas
 available . Experimental
 TREX  schemas
 available . 

 
 $Date: 2006-03-08 16:42:23 +0300 (Ср, 08 мар 2006) $ $Revision: 5626 $ Creating DocBook Documents DocBook DTD documents creating in SGML documents creating DocBook This chapter explains in concrete, practical terms how to
make DocBook documents. It&#39;s an overview of all the kinds of markup
that are possible in DocBook documents. It explains how to create
several kinds of DocBook documents: books, sets of books, chapters,
articles, and reference manual entries. The idea is to give you enough
basic information to actually start writing. The information here is
intentionally skeletal; you can find  the details  in the
reference section of this book.
 
Before we can examine DocBook markup, we have to take a look at what
an   or   system requires.
 Making an   Document SGML documents, creating prologue SGML documents 
  requires that your document have a specific prologue. The
following sections describe the features of the prologue.
 An   Declaration SGML declarations declarations SGML documents 

  documents begin with an optional   Declaration. The
declaration can precede the document instance, but generally it is
stored in a separate file that is associated with the  . The
  Declaration is a grab bag of   defaults. DocBook includes
an   Declaration that is appropriate for most DocBook documents,
so we won&#39;t go into a lot of detail here about the   Declaration.
 markup delimiters (characters) tags names SGML declaration attributes names characters SGML declaration minimization markup markup minimization 

In brief, the   Declaration describes, among other things, what
characters are markup delimiters (the default is angle brackets), what
characters can compose tag and attribute names (usually the
alphabetical and numeric characters plus the dash and the period),
what characters can legally occur within your document, how long
   names  and  numbers  can be, what sort
of minimizations (abbreviation of markup) are allowed, and so
on. Changing the   Declaration is rarely necessary, and because
many tools only partially support changes to the declaration, changing
it is best avoided, if possible.
 tutorial, SGML Declaration 

Wayne Wholer has written an excellent tutorial on the  
Declaration; if you&#39;re interested in more details, see  http://www.oasis-open.org/cover/wlw11.html .
 A Document Type Declaration SGML document type declaration document type declaration SGML documents declarations document type declaration declarations document type declaration SGML 

All   documents must begin with a document type declaration. This
identifies the   that will be used by the document and what the
root element of the document will be. A typical doctype declaration
for a DocBook document looks like this:
 &lt;!DOCTYPE book PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot;&gt; root element document type declaration elements root element 
This declaration indicates that the  root element ,
which is the first element in the hierarchical structure of the
document, will be  book  and that
the   used will be the one identified by the public identifier
 -//OASIS//DTD DocBook V3.1//EN . See   later in this chapter.
 An Internal Subset internal subset SGML document declarations 

It&#39;s also possible to provide additional declarations in a document
by placing them in the document type declaration: &lt;!DOCTYPE book PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot; [
&lt;!ENTITY nwalsh &quot;Norman Walsh&quot;&gt;
&lt;!ENTITY chap1 SYSTEM &quot;chap1.sgm&quot;&gt;
&lt;!ENTITY chap2 SYSTEM &quot;chap2.sgm&quot;&gt;
]&gt; external subset SGML document declarations public identifiers SGML system identifiers SGML 

These declarations form what is known as the
 internal subset . The declarations stored in the
file referenced by the public or system identifier in the 
 DOCTYPE  declaration is called the  external
subset  and it is technically optional.
It is legal to put the   in the internal
subset and to have no external subset, but for a   as large
as DocBook that wouldn&#39;t make much sense.
 parsing order 
The internal subset is parsed  first 
and, if multiple declarations for an entity occur, the first
declaration is used. Declarations in the internal subset
override declarations in the external subset. The Document (or Root) Element elements root element root element placement 

Although comments and processing instructions may occur between the
document type declaration and the root element, the root element usually
immediately follows the document type declaration: &lt;!DOCTYPE book PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot; [
&lt;!ENTITY nwalsh &quot;Norman Walsh&quot;&gt;
&lt;!ENTITY chap1 SYSTEM &quot;chap1.sgm&quot;&gt;
&lt;!ENTITY chap2 SYSTEM &quot;chap2.sgm&quot;&gt;
]&gt;
&lt;book&gt;
&amp;chap1;
&amp;chap2;
&lt;/book&gt; You cannot place the root element of
the document in an external entity. Typing an   Document Emacs text editor vi text editor SGML text editors, entering through text editors SGML, entering 

If you are entering   using a text editor such as
 Emacs  or  vi , there are a few things to
keep in mind. 
Many of these things are influenced by the   declaration in use.
For the purpose of this discussion, we assume you are using the
standard DocBook declaration.
 
Using a structured text editor designed for   hides most of these
issues.
 elements case sensitivity (DocBook) case sensitivity elements (DocBook) attributes case sensitivity (DocBook) case sensitivity attributes (DocBook) 

DocBook element and attribute names are not case-sensitive.  There&#39;s
no difference between  Para  and  pArA .  Entity names are case-sensitive, however.
 SGML XML/SGML compatibility case sensitivity XML SGML/XML compatibility case sensitivity, attributes and elements compatibility, SGML/XML conversion case sensitivity, attribute and element names 
If you are interested in future   compatibility, input all
element and attribute names strictly in lowercase.
 SGML XML/SGML compatibility quotes, attribute values XML SGML/XML compatibility quotes, attribute values quotes attribute values spaces and punctuation characters attributes values quoting spaces, quoting (attribute values) punctuation characters, quoting (attribue values) 

If attribute values contain spaces or punctuation characters, you must
quote them. You are not required to quote attribute values if they
consist of a single word or number, although it is not wrong to do so.
 straight single quotes (attribute values) straight double quotes (attribute values) curly quotes (attribute values) 
When quoting attribute values, you can use either a straight single
quote (&#39;), or a straight double quote (&quot;).  Don&#39;t use the
 curly  quotes (  and  ) in your editing tool.
 compatibility, SGML/XML conversion attribute values, quoting 
If you are interested in future   compatibility, always
quote all attribute values.
 SGML XML/SGML compatibility empty tags XML SGML/XML compatibility empty tags compatibility, SGML/XML conversion empty tags tags empty empty tags 
Several forms of markup minimization are allowed, including empty
tags. Instead of typing the entire end tag for an element, you can
type simply  &lt;/&gt; . For example:
 
&lt;para&gt;
This is &lt;emphasis&gt;important&lt;/&gt;: never stick the tines of a fork
in an electrical outlet.
&lt;/para&gt;

 
You can use this technique for any and every tag, but it will make
your documents very hard to understand and difficult to debug if you 
introduce errors.  It is best to use this technique
only for inline elements containing a short string of text.
 start tags empty, using (SGML documents) parsing empty start tags, problems with 
Empty start tags are also possible, but may be even more confusing.
For the record, if you encounter an empty start tag, the   parser uses
the element that ended last:
 
&lt;para&gt;
This is &lt;emphasis&gt;important&lt;/emphasis&gt;.  So is &lt;&gt;this&lt;/emphasis&gt;.
&lt;/para&gt;

 
Both  important  and  this  are emphasized.
 markup minimization SGML/XML conversion problems minimization markup SGML/XML conversion problems 
If you are interested in future   compatibility, don&#39;t use any
of these tricks.
 
The null end tag (net) minimization feature allows constructions like this:
 
&lt;para&gt;
This is &lt;emphasis/important/: never stick the tines of a fork
in an electrical outlet.
&lt;/para&gt;

 start tags minimization 
If, instead of ending a start tag with  &gt; , you end
it with a slash, then the next occurrence of a slash ends the element.
 minimization markup net tag minimization XML SGML/XML compatibility net tag minimization SGML XML/SGML compatibility net tag minimization 

If you are interested in future   compatibility, don&#39;t use
net tag minimization either.
 
If you are willing to modify both the declaration and the  , even more
dramatic minimizations are possible, including completely omitted tags
and  shortcut  markup.
 Removing Minimizations markup minimization removing minimization removing 

Although we&#39;ve made a point of reminding you about which of these
minimization features are not valid in  , that&#39;s not really a
sufficient reason to avoid using them.  (The fact that many of the
minimization features can lead to confusing, difficult-to-author
documents might be.)
 SGML XML/SGML compatibility markup minimizations, removing XML SGML/XML compatibility markup minimizations, removing sgmlnorm (SGML to XML conversion) 
If you want to convert one of these documents to   at some point
in the future, you can run it through a program like
 sgmlnorm , which will remove all the minimizations and
insert the correct, verbose markup.  The  sgmlnorm  program
is part of the  SP and Jade
distributions , which are on  the
 CD-ROM .
 Making an   Document XML DocBook documents, creating DocBook DTD documents creating in XML documents creating in XML (DocBook) 

In order to create DocBook documents in  , you&#39;ll need an  
version of DocBook. We&#39;ve included one on the  CD , but it hasn&#39;t
been officially adopted by the  OASIS  DocBook Technical Committee yet.
If you&#39;re interested in the technical details,  , describes the specific differences between
  and   versions of DocBook.
 prologue XML documents 

 , like  , requires a specific prologue in your document.
The following sections describe the features of the   prologue.
 An   Declaration declarations XML XML declarations versions XML, identifying 
  documents should begin with an   declaration. Unlike the
  declaration, which is a grab bag of features, the  
declaration identifies a few simple aspects of the document: &lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt; Identifying the version of   ensures that future changes to
the   specification will not alter the semantics of this
document. The standalone declaration simply makes explicit the fact
that this document cannot  stand alone,  and that it
relies on an external  . The complete details of the  
declaration are described in the   specification .
 A Document Type Declaration declarations document type declaration XML XML document type declaration document type declaration XML documents DocBook DTD XML document type declaration 
Strictly speaking,   documents don&#39;t require a
 . Realistically, DocBook   documents will have one.
 elements root element root element document type declaration 
The document type declaration identifies the   that will be used
by the document and what the root element of the document will be. A
typical doctype declaration for a DocBook document looks like
this:
 &lt;?xml version=&#39;1.0&#39;?&gt;
&lt;!DOCTYPE book PUBLIC &quot;-//Norman Walsh//DTD DocBk XML V3.1.4//EN&quot;
                         &quot;http://nwalsh.com/docbook/xml/3.1.4/db3xml.dtd&quot;&gt;
 external declarations (XML) public identifiers XML documents system identifiers XML 
This declaration indicates that the root element will be  book  and that the   used will be the
one indentified by the public identifier  -//Norman Walsh//DTD
DocBk XML V3.1.4//EN . External declarations in   must
include a system identifier (the public identifier is optional). In
this example, the   is stored on a web server.
 URI XML system identifiers 
System identifiers in   must be  URI s. Many
systems may accept filenames and interpret them locally as
 file:   URL s, but it&#39;s always
correct to fully qualify them.
 An Internal Subset declarations document type declaration XML document type declaration internal subset internal subset XML document type declarations XML document type declarations internal subset 
It&#39;s also possible to provide additional declarations in a document by
placing them in the document type declaration:
 &lt;?xml version=&#39;1.0&#39;?&gt;
&lt;!DOCTYPE book PUBLIC &quot;-//Norman Walsh//DTD DocBk XML V3.1.4/EN&quot;
                         &quot;http://nwalsh.com/docbook/xml/3.1.4/db3xml.dtd&quot; [
&lt;!ENTITY nwalsh &quot;Norman Walsh&quot;&gt;
&lt;!ENTITY chap1 SYSTEM &quot;chap1.sgm&quot;&gt;
&lt;!ENTITY chap2 SYSTEM &quot;chap2.sgm&quot;&gt;
]&gt; 
These declarations form what is known as the internal subset. The
declarations stored in the file referenced by the public or system
identifier in the  DOCTYPE  declaration is called the
external subset, which is technically optional.  It is legal to put
the   in the internal subset and to have no external subset, but
for a   as large as DocBook, that would make very little sense.
 parsing order XML document declarations 

The internal subset is parsed  first  in   and,
if multiple declarations for an entity occur, the first declaration is used.
Declarations in the internal subset override declarations in the external
subset. The Document (or Root) Element root element elements root element 
Although comments and processing instructions may occur between the
document type declaration and the root element, the root element usually
immediately follows the document type declaration: &lt;?xml version=&#39;1.0&#39;?&gt;
&lt;!DOCTYPE book PUBLIC &quot;-//Norman Walsh//DTD DocBk XML V3.1.4//EN&quot;
                         &quot;http://nwalsh.com/docbook/xml/3.1.4/db3xml.dtd&quot; [
&lt;!ENTITY nwalsh &quot;Norman Walsh&quot;&gt;
&lt;!ENTITY chap1 SYSTEM &quot;chap1.sgm&quot;&gt;
&lt;!ENTITY chap2 SYSTEM &quot;chap2.sgm&quot;&gt;
]&gt;
&lt;book&gt;...&lt;/book&gt; The important point is that the root element must be physically
present immediately
after the document type declaration. You cannot place the root element of
the document in an external entity. Typing an   Document text editors 

If you are entering   using a text editor such as  Emacs 
or  vi , there are a few things to keep in mind.
Using a structured text editor designed for
  hides most of these issues.
 case sensitivity markup markup case sensitivity compatibility, SGML/XML conversion XML markup, case-sensitivity 

In  , all markup is case-sensitive.  In the   version of DocBook,
you must always type all element,
attribute, and entity names in lowercase.
 
You are required to quote all attribute values in  .
 quotes attribute values 

When quoting attribute values, you can use either a straight single
quote (&#39;), or a straight double quote (&quot;).  Don&#39;t use the
 curly  quotes (  and  ) in your editing tool.
 empty elements markup syntax 

Empty elements in   are marked with a distinctive syntax:
 &lt;xref/&gt; .
 XML question marks (?), processing instructions Processing instructions in   begin and end with a question mark:
 &lt;?pitarget data?&gt; .
 XML interoperability, SGML and XML 

  was designed to be served, received, and processed over the
Web. Two of its most important design principles are ease of
implementation and interoperability with both   and  .
 SGML XML/SGML compatibility markup minimization, problems SGML markup minimization XML/SGML compatibility XML markup minimization SGML/XML compatibility XML SGML/XML compatibility markup minization, problems 

The markup minimization features in   documents make it more
difficult to process, and harder to write a parser to interpret it; these
minimization features also run counter to the   design principles
named above. As a result,   does not support them.
 
Luckily, a good authoring environment can offer all of the features of
markup minimization without interfering with the interoperability of
documents.  And because   tools are easier to write, it&#39;s likely
that good, inexpensive   authoring environments will be available
eventually.
  and   Markup Considerations in This Book DocBook DTD markup considerations, SGML vs. XML 

Conceptually, almost everything in this book applies equally to  
and  .  But because DocBook V3.1 is an    , we naturally
tend to use   conventions in our writing.  If you&#39;re primarily
interested in  , there are just a few small details to keep in
mind.
 case sensitivity XML vs. SGML SGML case sensitivity elements case sensitivity (XML) 
  is case-sensitive, while the   version of DocBook is
not. In this book, we&#39;ve chosen to present the element names using
mixed case ( Book ,  indexterm ,
 XRef , and so on), but in the DocBook    ,
all element, attribute, and entity names are strictly
lowercase. empty elements start tags, XML vs. SGML start tags empty element 
Empty element start tags in   are marked with a distinctive
syntax:  &lt;xref/&gt; .  In  , the trailing slash
is not present, so some of our examples need slight revisions to be
valid   elements.
 question marks (?), processing instructions (XML) processing instructions XML documents XML processing instructions 

Processing instructions in   begin and end with a question
mark:  &lt;?pitarget data?&gt; .  In  , the
trailing question mark is not present, so some of our examples need
slight revisions to be valid   elements.
 system identifiers XML URI requirement Uniform Resource Indicators URI public identifiers DocBook DTD examples 
Generally we use public identifiers in examples, but whenever system
identifiers are used, don&#39;t forget that   system identifiers must
be Uniform Resource Indicators ( URI s), in which
  system identifiers are usually simple filenames.
 
For a more detailed discussion of DocBook and  , see
 .
 Public Identifiers, System Identifiers, and Catalog Files files external, referencing XML external file references, id 

When a   or other external file is referenced from a document, the
reference can be specified in three ways: using a  public
identifier , a  system identifier , or
both. In  , the system identifier is  generally  
required and the public identifier is optional. In  , neither is 
required, but at least one must be present. 
This is not absolutely true.   allows for the possibility that
the reference could be implied by the application, but this is very
rarely the case.
 
 public identifiers names, requirements 
A public identifier is a globally unique, abstract
name, such as the following, which is the official public identifier
for DocBook  V3.1 :
 -//OASIS//DTD DocBook V3.1//EN 
 SGML system identifiers URI XML system identifiers URL SGML system identifers, similarity to Uniform Resource Locator URL Uniform Resource Names URN URN XML system identifiers, future 
The introduction of   has added some small complications to system
identifiers.  In  , a system identifier generally points to a
single, local version of a file using local system conventions. In
 , it must point with a Uniform Resource Indicator
( URI ). The most common  URI 
today is the Uniform Resource Locator ( URL ), which
is familiar to anyone who browses the Web.   URL s
are a lot like   system identifiers, because they generally point
to a single version of a file on a particular machine.  In the future,
Uniform Resource Names ( URN ), another form of
 URI , will allow   system identifiers to have
the abstract characteristics of public identifiers.
 SGML system identifiers example system identifiers SGML example 

The following filename is an example of an   system identifier:
 /usr/local/sgml/docbook/3.1/docbook.dtd
 
An equivalent   system identifier might be:
 file:///usr/local/sgml/docbook/3.1/docbook.dtd
 
 
The advantage of using the public identifier is that it makes your
documents more portable. For any system on which DocBook is installed,
the public identifier will resolve to the appropriate local version of
the   (if public identifiers can be resolved at all).
 
Public identifiers have two disadvantages:
 Because   does not require them, and because system
identifiers are required, developing   tools may not provide
adequate support for public identifiers. To work with these systems
you must use system identifiers. public identifiers resolution, mapping to system identifiers OASIS public identifiers, resolution mechanism 

Public identifiers aren&#39;t magical. They&#39;re simply a method of
indirection. For them to work, there must be a resolution mechanism
for public identifiers. Luckily, several years ago,   Open (now
 OASIS )
described a standard mechanism for mapping public identifiers to
system identifers using catalog files. 
See  OASIS 
Technical Resolution 9401:1997 (Amendment 2 to  TR 
9401). 
 Public Identifiers uniqueness public identifiers 
An important characteristic of public identifiers is that they are
 globally unique . Referring to a document with a
public identifier should mean that the identifier will resolve to the
same actual document on any system even though the location of that
document on each system may vary.  As a rule, you should never reuse
public identifiers, and a published revision should have a new public
identifier. Not following these rules defeats one purpose of the
public identifier.
 public identifiers syntax, examples 
A public identifier can be any string of upper- and lowercase letters,
digits, any of the following symbols:  &#39; ,
 ( ,  ) ,  + ,  , ,
 - ,  . ,  / ,  : ,
 = ,  ? , and white space, including line
breaks.
 Formal public identifiers ISO standards formal public identifiers formal public identifier FPI FPI format, standard 
Most public identifiers conform to the  ISO  8879
standard that defines  formal public
identifiers . Formal public identifiers, frequently referred
to as  FPI , have a prescribed format that can ensure
uniqueness: 
Essentially, it can ensure that two different owners won&#39;t
accidentally tread on each other.  Nothing can prevent a given owner
from reusing public identifiers, except maybe common sense.
 
 prefix // owner-identifier // 
text-class text-description // 
language // display-version 
Here are descriptions of the identifiers in this string:
 prefix prefix (registered and unregistered public identifiers) registered public identifiers unregistered public identifiers ISO standards formal public identifiers 
The  prefix  is either a
 +  or a  - 
Registered public identifiers begin with
 + ; unregistered identifiers begin
with  - . 
( ISO  standards sometimes use a third form beginning
with  ISO  and the standard number, but this form is
only available to  ISO .)
 owner-identifiers registered public identifers uniqueness, guaranteeing 

The purpose of registration is to guarantee a unique owner-identifier.
There are few authorities with the power to issue registered public
identifiers, so in practice unregistered identifiers are more common.
 public identifiers registered, assigning authority Graphics Communication Association (GCA) registered public identifiers, assigning GCA (Graphics Communication Association) Graphics Communication Association (GCA) 

The  Graphics Communication
Association  ( GCA ) can assign registered
public identifiers.  They do this by issuing the applicant a unique
string and declaring the format of the owner identifier. For example,
the Davenport Group was issued the string  A00002  and
could have published DocBook using an  FPI  of the
following form:
 
+//ISO/IEC 9070/RA::A00002// ... 
 
 Internet domain names format (registered public identifiers) 
Another way to use a registered public identifier is to use the format
reserved for internet domain names.  For example, O&#39;Reilly can issue
documents using an  FPI  of the following form:
 
+//IDN oreilly.com// ... 
 
 
As of DocBook V3.1, the  OASIS  Technical Committee
responsible for DocBook has elected to use the unregistered owner
identifier,  OASIS , thus its prefix is
 - .
 
-//OASIS// ... 
 
 owner-identifier names individuals as owner-identifiers 
Identifies the person or organization that owns the identifier.
Registration guarantees a unique owner identifier. Short of
registration, some effort should be made to ensure that the owner
identifier is globally unique. A company name, for example, is a
reasonable choice as are Internet domain names. It&#39;s also not uncommon
to see the names of individuals used as the owner-identifier, although
clearly this may introduce collisions over time.
 DocBook DTD owner-identifier, version 3.1 

The owner-identifier for DocBook V3.1 is
 OASIS .  Earlier versions used the owner-identifier
 Davenport .
 text-class text text class DOCUMENT text class DTDs text class ELEMENTS text class ENTITIES text class NONSGML text class 

The text class identifies the kind of document that is
associated with this public identifier. Common text classes
are
   DOCUMENT An   or   document. DTD A   or part of a  . ELEMENTS A collection of element declarations. ENTITIES A collection of entity declarations. NONSGML Data that is not in   or  . 
 
DocBook is a  , thus its text class is DTD.
 text-description text text description DocBook DTD text description 

This field provides a description of the document. The text description is
free-form, but cannot include the string //.
 
The text description of DocBook is  DocBook V3.1 .
 proprietary DTDs, unavailable public texts DTDs proprietary 
In the uncommon case of unavailable public texts
( FPI s for proprietary  s, for example), there
are a few other options available (technically in front of or in place
of the text description), but they&#39;re rarely used.
 
See Appendix A of  , for more details.
 
 language languages document texts ISO standards language codes 

Indicates the language in which the document is written. It is
recommended that the  ISO  standard two-letter
language codes be used if possible.
 
DocBook is an English-language  , thus its language is
 EN .
 display-version display version 

This field, which is not frequently used, distinguishes between
public texts that are the same except for the display device or system
to which they apply.
 FPI ISO Latin 1 character set, examples 

For example, the  FPI  for the  ISO 
Latin 1 character set is:
 -//ISO 8879-1986//ENTITIES Added Latin 1//EN 
 
A reasonable  FPI  for an   version of this
character set is:
 -//ISO 8879-1986//ENTITIES Added Latin 1//EN//XML 
 
 System Identifiers system identifiers URI XML system identifiers 
System identifiers are usually filenames on the local system. In
 , there&#39;s no constraint on what they can be. Anything that your
  processing system recognizes is allowed. In  , system
identifiers must be  URI s (Uniform Resource
Identifiers).
 
The use of  URI s as system identifiers introduces
the possibility that a system identifier can be a
 URN . This allows the system identifier to benefit
from the same global uniqueness benefit as the public identifier. It
seems likely that   system identifiers will eventually move in
this direction.
 Catalog Files catalog files pubic identifiers, resolving to system Catalog files  are the standard mechanism for
resolving public identifiers into system identifiers. Some resolution
mechanism is necessary because DocBook refers to its component modules
with public identifiers, and those must be mapped to actual files on
the system before any piece of software can actually load them.
 OASIS catalog file format keywords catalog files 

The catalog file format was defined in 1994 by   Open (now
 OASIS ). The formal specification is contained in
 OASIS  Technical Resolution 9401:1997.
 
Informally, a catalog is a text file that contains a number of
keyword/value pairs. The most frequently used keywords are
 PUBLIC ,  SYSTEM ,
 SGMLDECL ,  DTDDECL ,
 CATALOG ,  OVERRIDE ,
 DELEGATE , and  DOCTYPE .
 PUBLIC PUBLIC keyword 

The  PUBLIC  keyword maps public identifiers to
system identifiers: 
PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot; &quot;docbook/3.1/docbook.dtd&quot;
 SYSTEM SYSTEM keyword 

The  SYSTEM  keyword maps system identifiers to
system identifiers: 
SYSTEM &quot;http://nwalsh.com/docbook/xml/1.3/db3xml.dtd&quot;
    &quot;docbook/xml/1.3/db3xml.dtd&quot;
 SGMLDECL SGMLDECL keyword 

The  SGMLDECL  keyword identifies the system
identifier of the   Declaration that should be used: 
SGMLDECL &quot;docbook/3.1/docbook.dcl&quot;
 DTDDECL DTDDECL 

Like  SGMLDECL ,  DTDDECL 
identifies the   Declaration that should be
used.  DTDDECL  associates a declaration with a
particular public identifier for a  :
 DTDDECL &quot;-//OASIS//DTD DocBook V3.1//EN&quot; &quot;docbook/3.1/docbook.dcl&quot;
 Unfortunately, it is not supported by the free tools that are
available. The practical benefit of  DTDDECL  can
usually be achieved, albeit in a slightly cumbersome way, with
multiple catalog files.
 CATALOG CATALOG keyword 

The  CATALOG  keyword allows one catalog to
include the content of another.  This can make maintenance somewhat
easier and allows a system to directly use the catalog files included
in   distributions. For example, the DocBook distribution includes
a catalog file. Rather than copying each of the declarations in that
catalog into your system catalog, you can simply include the contents
of the DocBook catalog:
 CATALOG &quot;docbook/3.1/catalog&quot; OVERRIDE OVERRIDE keyword 

The  OVERRIDE  keyword indicates whether or not
public identifiers override system identifiers. If a given declaration
includes both a system identifer and a public identifier, most systems
attempt to process the document referenced by the system identifier,
and consequently ignore the public identifier. Specifying
 OVERRIDE YES  in the catalog informs the processing
system that resolution should be attempted first with the public
identifier. DELEGATE DELEGATE keyword 

The  DELEGATE  keyword allows you to specify
that some set of public identifiers should be resolved by another
catalog. Unlike the  CATALOG  keyword, which loads
the referenced catalog,  DELEGATE  does nothing until
an attempt is made to resolve a public identifier. The
 DELEGATE  entry specifies a partial public
identifier and an alternate catalog:
 DELEGATE &quot;-//OASIS&quot; &quot;/usr/sgml/oasis/catalog&quot; 
 initial substring matches (public identifiers) public identifiers partial (initial substring matches) 

Partial public identifers are simply initial substring
matches. Given the preceding entry, if an attempt is made to match any
public identifier that begins with the string
 -//OASIS , the alternate catalog
 /usr/sgml/oasis/catalog  will be used instead
of the current catalog.
 DOCTYPE DOCTYPE keyword system identifiers default, specifying declarations system identifier, default (SGML) 

The  DOCTYPE  keyword allows you to specify a default
system identifier.  If an   document begins with a
 DOCTYPE  declaration that specifies neither a public
identifier nor a system identifier (or is missing a
 DOCTYPE  declaration altogether), the
 DOCTYPE  declaration may provide a default:
 
DOCTYPE BOOK n:/share/sgml/docbook/3.1/docbook.dtd
 catalog files sample 
A small fragment of an actual catalog file is shown in  .
 A Sample Catalog comments catalog files 
Catalog files may also include comments.
 
This catalog specifies that public identifiers should be used in favor
of system identifiers, if both are present.
 
The default declaration specified by this catalog is the DocBook 
declaration.
 
Given an explicit (or implied)    DOCTYPE  of
 
&lt;!DOCTYPE BOOK SYSTEM&gt;

 
use  n:/share/sgml/docbook/3.1/docbook.dtd  as the default
system identifier.  Note that this can only apply to   documents
because the DOCTYPE declaration above is not a valid   element.
 
Map the  OASIS  public identifer to the local copy of
the DocBook  V3.1   .
 
Map a system identifer for the   version of DocBook to a local
version.
 A few notes: It&#39;s not uncommon to have several catalog files. See below,
 . quotes public and system identifiers public identifiers quotes system identifiers quotes 

Like attributes on elements you can quote, the public
identifier and system identifier are surrounded by either single or double
quotes. whitespace catalog files catalog files whitespace 

White space in the catalog file is generally
irrelevant. You can use spaces, tabs, or new lines between keywords
and their arguments. relative system identifiers 

When a relative system identifier is used, it is
considered to be relative to the location of the catalog file, not the
document being processed. Locating catalog files catalog files locating locating catalog files files catalog 

Catalog files go a long way towards making documents more portable by
introducing a level of indirection. A problem still remains, however:
how does a processor locate the appropriate catalog file(s)?
 OASIS  outlines a complete interchange packaging
scheme, but for most applications the answer is simply that the
processor looks for a file called  catalog  or
 CATALOG .
 directories, specifying (catalog file location) 

Some applications allow you to specify a list of directories that
should be examined for catalog files. Other tools allow you to specify
the actual files.
 
Note that even if a list of directories or catalog files is provided,
applications may still load catalog files that occur in directories in
which other documents are found. For example,  SP 
and Jade always load the catalog file that occurs in the directory in
which a   or document resides, even if that directory is not on
the catalog file list.
 Physical Divisions: Breaking a Document into Physical Chunks documents dividing divisions documents (DocBook) 
The rest of this chapter describes how you can break documents into
logical chunks, such as books, chapters, sections, and so on. Before
we begin, and while the subject of the internal subset is fresh in
your mind, let&#39;s take a quick look at how to break documents into
separate physical chunks.
 
Actually, we&#39;ve already told you how to do it. If you recall, in the
preceding sections we had declarations of the form:
 &lt;!ENTITY  name  SYSTEM &quot; filename &quot;&gt;
 
 entities inserting files 

If you refer to the entity  name  in your
document after this declaration, the system will insert the contents
of the file  filename  into your document at that
point.  So, if you&#39;ve got a book that consists of three chapters and
two appendixes, you might create a file called
 book.sgm , which looks like this:
 &lt;!DOCTYPE book PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot; [
&lt;!ENTITY chap1 SYSTEM &quot;chap1.sgm&quot;&gt;
&lt;!ENTITY chap2 SYSTEM &quot;chap2.sgm&quot;&gt;
&lt;!ENTITY chap3 SYSTEM &quot;chap3.sgm&quot;&gt;
&lt;!ENTITY appa SYSTEM &quot;appa.sgm&quot;&gt;
&lt;!ENTITY appb SYSTEM &quot;appb.sgm&quot;&gt;
]&gt;
&lt;book&gt;&lt;title&gt;My First Book&lt;/title&gt;
&amp;chap1;
&amp;chap2;
&amp;chap3;
&amp;appa;
&amp;appb;
&lt;/book&gt;
 declarations document type declaration document type declaration divisions of documents 

You can then write the chapters and appendixes conveniently in
separate files.  Note that these files do not and must not have
document type declarations.
 
For example, Chapter 1 might begin like this:
 
&lt;chapter id=&quot;ch1&quot;&gt;&lt;title&gt;My First Chapter&lt;/title&gt;
&lt;para&gt;My first paragraph.&lt;/para&gt;
...

 
But it should not begin with its own document type declaration:
 
&lt;!DOCTYPE chapter PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot;&gt;
&lt;chapter id=&quot;ch1&quot;&gt;&lt;title&gt;My First Chapter&lt;/title&gt;
&lt;para&gt;My first paragraph.&lt;/para&gt;
...

 Logical Divisions: The Categories of Elements in DocBook divisions elements, categories of (DocBook) elements categories, DocBook divisions 

DocBook elements can be divided broadly into these categories:
 Sets Books Divisions, which divide books into parts Components, which divide books or divisions into chapters Sections, which subdivide components Meta-information elements Block elements Inline elements 
 
In the rest of this section, we&#39;ll describe briefly the elements that
make up these categories.  This section is designed to give you an
overview. It is not an exhaustive list of every element in DocBook.
 
For more information about any specific element and the elements that
it may contain, consult the reference page for the element in
question.
 Sets Sets 

A  Set  contains two or more
 Book s.  It&#39;s the hierarchical top of DocBook. You
use the  Set  tag, for example, for a series of books
on a single subject that you want to access and maintain as a single
unit, such as the manuals for an airplane engine or the documentation
for a programming language.
 Books customizing DocBook DTD book organization Book element elements, ordering 
A  Book  is probably the most common top-level
element in a document. The DocBook definition of a book is very loose
and general. Given the variety of books authored with DocBook and the
number of different conventions for book organization used in
countries around the world, attempting to impose a strict ordering of
elements can make the content model extremely complex.  But DocBook
gives you free reign.  It&#39;s very reasonable to use a local  customization layer  to impose a more
strict ordering for your applications.
 Book s consist of a mixture of the following elements:
 Dedication Dedication  pages almost always occur at the front of
a book.
 Dedication element 

 Navigational Components navigation, component-level elements elements components, navigation ToC LoT Lists of Titles LoT Index element tables of contents ToC 
There are a few component-level elements designed for
navigation:  ToC , for Tables of Contents;
 LoT , for Lists of Titles (for lists of figures,
tables, examples, and so on); and  Index , for
indexes. Divisions divisions Book Part element Reference element RefEntry element components 

Divisions are the first hierarchical level below  Book .
They contain  Part s and  Reference s.
 Part s, in turn, contain components.
 Reference s contain  RefEntry s.  These are
discussed more thoroughly in  .
 
Books can contain components directly and are not required to contain
divisions.
 Components Chapter element components, similarity to 

These are the chapter-like elements of a  Book .
 Components books components Part element Preface element Chapter element Appendix element Glossary element Bibliography element Article element block elements sections elements 
Components are the chapter-like elements of a  Book  or
 Part :  Preface ,
 Chapter ,  Appendix ,
 Glossary , and
 Bibliography .  Article s can also
occur at the component level. We describe  Article s
in more detail in the section titled  .  Components generally
contain block elements and/or sections, and some can contain
navigational components and  RefEntry s.
 Sections nesting section elements numbered sections, levels elements sections 

There are several flavors of sectioning elements in DocBook: Sect1 Sect5  elements The  Sect1 Sect5 
elements are the most common sectioning elements. They can occur in
most component-level elements. These numbered section elements must be
properly nested ( Sect2 s can only occur inside
 Sect1 s,  Sect3 s can only occur inside
 Sect2 s, and so on).  There are five levels of numbered
sections. Section  element Section element 

The  Section  element, introduced in DocBook V3.1, is
an alternative to numbered sections.   Section s are
recursive, meaning that you can nest them to any depth desired.
 SimpleSect  element SimpleSect element 

In addition to numbered sections, there&#39;s the
 SimpleSect  element.  It is a terminal section that
can occur at any level, but it cannot have any other sectioning
element nested within it. BridgeHead BridgeHead element 

A  BridgeHead  provides a section title without
any containing section. RefSect1 RefSect3  elements RefEntry element 
These elements, which occur only in  RefEntry s, are
analogous to the numbered section elements in components.  There are
only three levels of numbered section elements in a
 RefEntry . GlossDiv ,  BiblioDiv , and 
 IndexDiv GlossDiv element BiblioDiv element Glossary element Bibliography element Index element Glossary s,  Bibliography s,
and  Index es can be broken into top-level
divisions, but not sections.  Unlike sections, these elements do not
nest. Meta-Information meta-information elements, section-level and above wrappers meta-information, elements 
All of the elements at the section level and above include a wrapper
for meta-information about the content.  See, for example,
 BookInfo .
 Author element Title element Publisher element revision histories keywords keyword sets (meta-information) indexes metainformation 
The meta-information wrapper is designed to contain bibliographic
information about the content ( Author ,  Title ,
 Publisher , and so on) as well as other meta-information
such as revision histories, keyword sets, and index terms.
 Block Elements block elements paragraphs paragraph-level elements lists examples figures tables synopses admonitions line-specific environments 

The block elements occur immediately below the component and
sectioning elements. These are the (roughly) paragraph-level elements
in DocBook. They can be divided into a number of categories: lists,
admonitions, line-specific environments, synopses of several sorts,
tables, figures, examples, and a dozen or more miscellaneous elements.
 Block vs. Inline Elements block elements inline elements vs. inline elements block elements vs. 

At the paragraph-level, it&#39;s convenient to divide elements into two
classes,  block  and  inline .
From a structural point of view, this distinction is based loosely on
their relative size, but it&#39;s easiest to describe the difference in
terms of their presentation.
 sidebars block quotations quotations (block) 
Block elements are usually presented with a paragraph (or larger)
break before and after them.  Most can contain other block elements,
and many can contain character data and inline elements. Paragraphs,
lists, sidebars, tables, and block quotations are all common examples
of block elements.
 fonts changes (inline elements) characters inline elements cross references filenames commands options subscripts and superscripts glossaries glossary terms 
Inline elements are generally represented without any obvious breaks.
The most common distinguishing mark of inline elements is a font
change, but inline elements may present no visual distinction at all.
Inline elements contain character data and possibly other inline
elements, but they never contain block elements.  Inline elements are
used to mark up data such as cross references, filenames, commands,
options, subscripts and superscripts, and glossary terms.
 Lists lists elements elements lists 

There are seven list elements in DocBook: CalloutList CallOut element CalloutList element 

A list of  CallOut s and their descriptions.
 CallOut s are
marks, frequently numbered and  typically on a graphic or verbatim environment,
that are described in a  CalloutList , outside the element
in which they occur. GlossList GlossList element 

A list of glossary terms and their definitions. ItemizedList ItemizedList element 

An unordered (bulleted) list. There are attributes to control
the marks used. OrderedList OrderedList element 

A numbered list. There are attributes to control the type of
enumeration. SegmentedList SegmentedList element 

A repeating set of named items. For example, a list of states
and their capitals might be represented as a
 SegmentedList . SimpleList SimpleList element 

An unadorned list of items.  SimpleList s can
be inline or arranged in columns. VariableList VariableList element 

A list of terms and definitions or descriptions. (This list of
list types is a  VariableList .) Admonitions admonitions DocBook types Caution element Important element Note element Tip element Warning element 

There are five types of admonitions in DocBook:
 Caution ,  Important ,
 Note ,  Tip , and
 Warning .
 
All of the admonitions have the same structure: an optional  
Title  followed by paragraph-level elements. The DocBook
  does not impose any specific semantics on the individual
admonitions. For example, DocBook does not mandate that
 Warning s be reserved for cases where bodily harm
can result.
 Line-specific environments line-specific environments whitespace preserving in source text line breaks, preserving 

These environments preserve whitespace and line breaks in the source
text. DocBook does not provide the equivalent of  &#39;s
 BR  tag, so there&#39;s no way to interject a line break
into normal running text.
 Address Address element 

The  Address  element is intended for postal
addresses.  In addition to being line-specific,  Address 
contains additional elements suitable for marking up names and
addresses. LiteralLayout LiteralLayout element 

A  LiteralLayout  does not have any semantic
association beyond the preservation of whitespace and line breaks.  In
particular, while  ProgramListing  and
 Screen  are frequently presented in a fixed-width
font, a change of fonts is not necessarily implied by  LiteralLayout
 . ProgramListing ProgramListing element fonts fixed-width, programs and code 

A  ProgramListing  is a verbatim environment, usually
presented in Courier or some other fixed-width font, for program
sources, code fragments, and similar listings. Screen Screen element text screen-captures  

A  Screen  is a verbatim or literal environment
for text screen-captures, other fragments of an
 ASCII  display, and similar things.  
Screen  is also a frequent catch-all for any verbatim
text. ScreenShot ScreenShot element ScreenShot  is actually a wrapper for a
 Graphic  intended for screen shots of a
 GUI  for example. Synopsis Synopsis element 

A  Synopsis  is a verbatim environment for command
and function synopsis. Examples, figures, and tables block elements formal and informal elements formal elements informal elements Example element Figure element Table element InformalExample element InformalExample element InformalTable element 

Examples, Figures, and Tables are common block-level elements:
 Example ,  InformalExample ,
 Figure ,  InformalFigure ,
 Table , and  InformalTable .
 titles formal elements 

The distinction between formal and informal elements is that formal
elements have titles while informal ones do not. The
 InformalFigure  element was introduced in DocBook
 V3.1 . In prior versions of DocBook, you could only
achieve the effect of an informal figure by placing its content,
unwrapped, at the location where the informal figure was desired.
 Paragraphs Para element 

There are three paragraph elements:  Para ,  
SimPara  (simple paragraphs may not contain other block-level
elements), and  FormalPara  (formal paragraphs have
titles).
 Equations Equation element titles equation elements InlineEquation element 
There are two block-equation elements,  Equation  and
 InformalEquation  (for inline equations, use
 InlineEquation ).
 
Informal equations don&#39;t have titles. For reasons of
backward-compatibility,  Equation s are not required
to have titles. However, it may be more difficult for some stylesheet
languages to properly enumerate  Equation s if they
lack titles.
 Graphics graphics Figure element ScreenShot element block elements Graphic InlineGraphic element 

Graphics occur most frequently in  Figure s and
 ScreenShot s, but they can also occur without a
wrapper. DocBook considers a  Graphic  a block
element, even if it appears to occur inline. For graphics that you
want to be represented inline, use  InlineGraphic .
 MediaObject elements InlineMediaObject element 

DocBook  V3.1  introduced a new element to contain
graphics and other media types:  MediaObject  and its inline
cousin,  InlineMediaObject . These elements may contain
video, audio, image, and text data. A single media object can contain
several alternative forms from which the presentation system can
select the most appropriate object.
 Questions and answers QandASet element FAQ element frequently asked questions (FAQ) Question element Answer element 

DocBook  V3.1  introduced the  QandASet 
element, which is suitable for  FAQ s (Frequently
Asked Questions) and other similar collections of
 Question s and  Answer s.
 Miscellaneous block elements 
The following block elements are also available:
 BlockQuote BlockQuote element Attribution element 

A block quotation.  Block quotations may have
 Attribution s. CmdSynopsis CmdSynopsis element parameters (commands), markup options commands, marking up commands 

An environment for marking up all the parameters and options of a command.
 Epigraph Epigraph element 

A short introduction, typically a quotation, at the beginning of a document.
 Epigraph s may have  Attribution s.
 FuncSynopsis FuncSynopsis element MsgSet element 

An environment for marking up the return value and arguments of a function.
 Highlights Highlights element 

A summary of the main points discussed in a book component (chapter,
section, and so on).
 MsgSet error messages sets of related 

A set of related error messages. Procedure Procedure element Step element SubStep element 

A procedure.  Procedures contain  Step s, which
may contain  SubStep s. Sidebar A sidebar. Inline Elements inline elements text inline elements 

Users of DocBook are provided with a surfeit of inline elements.
Inline elements are used to mark up running text.  In published
documents, inline elements often cause a font change or other small
change, but they do not cause line or paragraph breaks.
 
In practice, writers generally settle on the tagging of inline elements that
suits their time and subject matter. This may be a large number of
elements or only a handful. What is important is that you choose to mark up
not every possible item, but only those for which distinctive tagging will
be useful in the production of the finished document for the readers who
will search through it.
 
The following comprehensive list may be a useful tool for the process
of narrowing down the elements that you will choose to mark up; it is
not intended to overwhelm you by its sheer length. For convenience,
we&#39;ve divided the inlines into several subcategories.
 
The classification used here is not meant to be authoritative, only
helpful in providing a feel for the nature of the inlines.  Several
elements appear in more than one category, and arguments could be made
to support the placement of additional elements in other categories or
entirely new categories.
 Traditional publishing inlines general writing (traditional publishing inlines) traditional publishing, inline elements 

These inlines identify things that commonly occur in general writing:
 Abbrev .
 Abbrev element Acronym .
 Acronym element Emphasis . Emphasis element Footnote .  The location of the  Footnote 
element identifies the location of the first reference to the
footnote. Additional references to the same footnote can be inserted with
 FootnoteRef .
 FootnoteRef element 
 Footnote element 
 Phrase . Phrase element Quote . Quote element Trademark . Trademark element Cross references cross references Link element GlossTerm element LinkEnd attribute 

The cross reference inlines identify both explicit cross references,
such as  Link , and implicit cross references like
 GlossTerm . You can make the most of the implicit
references explicit with a  LinkEnd 
attribute.
 Anchor . Anchor element Citation . Citation element CiteRefEntry . CiteRefEntry element CiteTitle . CiteTitle element FirstTerm . FirstTerm element GlossTerm . GlossTerm element Link . Link element OLink . OLink element ULink . ULink element XRef . XRef element Markup markup elements 

These inlines are used to mark up text for special presentation:
 ForeignPhrase . ForeignPhrase element WordAsWord . WordAsWord element ComputerOutput . ComputerOutput element Literal . Literal element Markup . Markup element Prompt . Prompt element Replaceable . Replaceable element SGMLTag . SGMLTag element UserInput . UserInput element Mathematics elements mathematics mathematics (DocBook) equations (elements) MathML, incorporating namespaces DocBook does not define a complete set of elements for
representing equations. No one has ever pressed the DocBook
maintainers to add this functionality, and the prevailing opinion is
that incorporating
 MathML  using a
mechanism like
 namespaces 
is probably the best long-term solution. DocBook V4.5 added a  mathphrase  element to support
simple, textual mathematics that doesn&#39;t require extensive markup. InlineEquation . InlineEquation element mathphrase . mathphrase element Subscript . Subscript element Superscript . Superscript element User interfaces 
These elements describe aspects of a user interface:
 user interfaces, describing (elements) 
 elements user interfaces, describing 

 Accel . Accel element GUIButton . GuIButton element GUIIcon . GUIIcon element GUILabel . GUIMenu . GUIMenu element GUIMenuItem . GUIMenuItem element GUISubmenu . GUISubmenu element KeyCap . KeyCap element KeyCode . KeyCode class KeyCombo . KeyCombo element KeySym . KeySym element MenuChoice . MenuChoice element MouseButton . MouseButton element Shortcut . Shortcut element Programming languages and constructs programming languages (elements) constructs (programming), elements inline elements programming languages and constructs elements programming languages and constructs inline elements technical 

Many of the technical inlines in DocBook are related to programming.
 Action . Action element ClassName . ClassName element Constant . Constant element ErrorCode . ErrorCode element ErrorName . ErrorName element ErrorType . ErrorType element Function . Function element Interface . Interface element InterfaceDefinition . InterfaceDefinition element Literal . Literal element MsgText . MsgText element Parameter . Parameter element Property . Property element Replaceable . Replaceable element ReturnValue . ReturnValue element StructField . StructField element StructName . StructName element Symbol . Symbol element Token . Token element Type . Type element VarName . VarName element Operating systems operating systems inline elements 

These inlines identify parts of an operating system, or an
operating environment:
 Application . Application element Command . Command element EnVar . EnVar element Filename . Filename element MediaLabel . MediaLabel element MsgText . MsgText element Option . Option element Parameter . Parameter element Prompt . Prompt element SystemItem . SystemItem element General purpose general-purpose technical inline elements inline elements technical (general-purpose) 

There are also a number of general-purpose technical inlines.
 Application . Application element Database . Database element Email . Email element Filename . Filename element Hardware . Hardware element InlineGraphic . InlineGraphic element Literal . Literal element MediaLabel . MediaLabel element Option . Option element Optional . Optional element Replaceable . Replaceable element Symbol . Symbol element Token . Token element Type . Type element Making a DocBook Book DocBook DTD Book, making books DocBook, making meta-information DocBook Book 

A typical  Book , in English at least, consists of 
some meta-information in a  BookInfo 
( Title ,  Author ,
 Copyright , and so on), one or more  
Preface s, several  Chapter s, and perhaps a
few  Appendix es. A  Book  may also
contain  Bibliography s,
 Glossary s,  Index es and a
 Colophon .
  shows the structure of a typical book.
Additional content is required where the ellipses occur.
 books typical structure 

 A Typical Book Making a Chapter Chapter element typical chapter, structure Preface element typical structure Appendix element typical structure Chapter s,  Preface s, and
 Appendix es all have a similar structure. They
consist of a  Title , possibly some additional
meta-information, and any number of block-level elements followed by
any number of top-level sections. Each section may in turn contain any
number of block-level elements followed by any number from the next
section level, as shown in  .
 A Typical Chapter Making an Article articles creating elements component-level components elements journal articles white papers, creating 

For documents smaller than a book, such as: journal articles, white
papers, or technical notes,  Article  is frequently
the most logical starting point. The body of an
 Article  is essentially the same as the body of a
 Chapter  or any other component-level element, as
shown in  
 Article s may include
 Appendix es,  Bibliography s,
 Index es and  Glossary s.
 A Typical Article Making a Reference Page reference pages creating manual page, creating UNIX manpage manpage (UNIX) 

The reference page or manual page in DocBook was inspired by, and in
fact designed to reproduce, the common    manpage 
concept. (We use the word &quot;page&quot; loosely here to mean a document of
variable length containing reference material on a specific topic.)
DocBook is rich in markup tailored for such documents, which often
vary greatly in content, however well-structured they may be. To
reflect both the structure and the variability of such texts, DocBook
specifies that reference pages have a strict sequence of parts, even
though several of them are actually optional.
 RefEntry element elements, obligatory RefNameDiv element RefSect1 element 

Of the following sequence of elements that may appear in a  RefEntry , only two are obligatory:  RefNameDiv  and  RefSect1 .
 DocInfo DocInfo element reference page, meta-information meta-information reference page 

The  DocInfo  element contains
meta-information about the reference page (which should not be
confused with  RefMeta , which it
precedes). It marks up information about the author of the document,
or the product to which it pertains, or the document&#39;s revision
history, or other such information. RefMeta RefMeta element titles reference pages volume number (reference page) ManVolNum UNIX ManVolNum uname command and uname function, distinguishing RefMeta  contains a title for
the reference page (which may be inferred if the
 RefMeta  element is not present) and an indication
of the volume number in which this reference page occurs. The
 ManVolNum  is a very  -centric concept.  In
traditional   documentation, the subject of a reference page is
typically identified by name and volume number; this allows you to
distinguish between the  uname  command,
 uname(1)  in volume 1 of the documentation and the
 uname  function,  uname(3)  in
volume 3.
 RefMiscInfo element miscellaneous information, reference pages 

Additional information of this sort such as conformance or
vendor information specific to the particular environment you are
working in, may be stored in  RefMiscInfo .
 RefNameDiv RefNameDiv element RefDescriptor element RefName element RefPurpose element purpose (reference pages) RefClass element operating systems configurations, software support 

The first obligatory element is  RefNameDiv , which is a wrapper for
information about whatever you&#39;re documenting, rather than the
document itself. It can begin with a  RefDescriptor  if several items are being
documented as a group and the group has a name. The  RefNameDiv  must contain at least one
 RefName , that is, the name of
whatever you&#39;re documenting, and a single short statement that sums up
the use or function of the item(s) at a glance: their  RefPurpose . Also available is the  RefClass , intended to detail the
operating system configurations that the software element in question
supports.
 titles reference pages RefEntryTitle element 

If no  RefEntryTitle  is given in the
 RefMeta , the title of the reference page is the
 RefDescriptor , if present, or the first
 RefName .
 RefSynopsisDiv RefSynopsisDiv element synopses reference topics commands syntax summary functions function prototype Title element 

A  RefSynopsisDiv  is intended
to provide a quick synopsis of the topic covered by the reference
page. For commands, this is generally a syntax summary of the command,
and for functions, the function prototype, but other options are
possible. A  Title  is allowed, but
not required, presumably because the application that processes
reference pages will generate the appropriate title if it is not
given. In traditional   documentation, its title is always
 Synopsis .
 RefSect1 RefSect3 sections RefEntry, levels RefSect1 RefSect3 

Within  RefEntry s, there are only three levels
of sectioning elements:  RefSect1 ,
 RefSect2 , and  RefSect3 . 
  shows the beginning of a  RefEntry  that illustrates one possible
reference page:
 reference pages sample page 
 A Sample Reference Page Making Front- and Backmatter frontmatter, books and articles backmatter, books and articles indexes creating, books and articles glossaries creating tables of contents creating, books and articles 

DocBook contains markup for the usual variety of front- and backmatter
necessary for books and articles: indexes, glossaries, bibliographies,
and tables of contents. In many cases, these components are generated
automatically, at least in part, from your document by an external
processor, but you can create them by hand, and in either case, store
them in DocBook.
 markup backmatter, books and articles 

Some forms of backmatter, like indexes and glossaries, usually require
additional markup  in the document  to make
generation by an application possible.  Bibliographies are usually
composed by hand like the rest of your text, unless you are
automatically selecting bibliographic entries out of some larger
database.  Our principal concern here is to acquaint you with the kind
of markup you need to include in your documents if you want to
construct these components.
 
Frontmatter, like the table of contents, is almost always generated
automatically from the text of a document by the processing
application. If you need information about how to mark up a table of
contents in DocBook, please consult the reference page for
 ToC .
 Making an Index indexes marking index terms 
In some highly-structured documents such as reference manuals, you can
automate the whole process of generating an index successfully without
altering or adding to the original source. You can design a processing
application to select the information and compile it into an adequate
index. But this is rare.
 
In most cases and even in the case of some reference
manuals a useful index still requires human intervention to mark
occurrences of words or concepts that will appear in the text of the
index.
 Marking index terms singular index markers ranges, index entries 

Docbook distinguishes two kinds of index markers: those that are
singular and result in a single page entry in the index itself, and
those that are multiple and refer to a range of pages.
 You put a singular index marker where the subject it refers to
actually occurs in your text:
 
&lt;para&gt;
The tiger&lt;indexterm&gt;
&lt;primary&gt;Big Cats&lt;/primary&gt;
&lt;secondary&gt;Tigers&lt;/secondary&gt;&lt;/indexterm&gt;
is a very large cat indeed.
&lt;/para&gt;
  
 primary level index entries 
 secondary level index entries 
 tertiary level index entries 
This index term has two levels,  primary  and
 secondary .  They correspond to an increasing amount
of indented text in the resultant index. DocBook allows for three
levels of index terms, with the third labeled
 tertiary .
 starting index terms (ranges) ending index terms (ranges) 

There are two ways that you can index a range of text. The first is to
put index marks at both the beginning and end of the discussion.  The
mark at the beginning asserts that it is the start of a range, and the
mark at the end refers back to the beginning. In this way, the
processing application can determine what range of text is
indexed. Here&#39;s the previous tiger example recast as starting and
ending index terms:
 
&lt;para&gt;
The tiger&lt;indexterm id=&quot;tiger-desc&quot; class=&quot;startofrange&quot;&gt;
&lt;primary&gt;Big Cats&lt;/primary&gt;
&lt;secondary&gt;Tigers&lt;/secondary&gt;&lt;/indexterm&gt;
is a very large cat indeed 
&lt;/para&gt;
 
&lt;para&gt;
So much for tigers&lt;indexterm startref=&quot;tiger-desc&quot; class=&quot;endofrange&quot;&gt;. Let&#39;s talk about
leopards.  
&lt;/para&gt;
 ID attribute index entries, ranges Class attribute index entries, ranges 

Note that the mark at the start of the range identifies itself as the
start of a range with the  Class 
attribute, and provides an  ID .
The mark at the end of the range points back to the start.
 IndexTerm element Zone attribute Zone attribute (indexterm) 

Another way to mark up a range of text is to specify that the entire
content of an element, such as a chapter or section, is the complete
range.  In this case, all you need is for the index term to point to
the  ID  of the element that
contains the content in question. The  Zone  attribute of  indexterm 
provides this functionality.
 
One of the interesting features of this method is that the actual
index marks do not have to occur anywhere near the text being
indexed. It is possible to collect all of them together, for example,
in one file, but it is not invalid to have the index marker occur near
the element it indexes.
 
Suppose the discussion of tigers in your document comprises a
whole text object (like a  Sect1 
or a  Chapter ) with an
 ID  value of 
 tiger-desc . You can put the following
tag anywhere in your document to index that range of text:
 
&lt;indexterm zone=&quot;tiger-desc&quot;&gt;
&lt;primary&gt;Big Cats&lt;/primary&gt;
&lt;secondary&gt;Tigers&lt;/secondary&gt;&lt;/indexterm&gt;
  
 see and see also index entries 
DocBook also contains markup for index hits that point to other index
hits (of the same type such as &quot;See Cats, big&quot; or &quot;See also
Lions&quot;). See the reference pages for  See  and
 SeeAlso .
 Printing an index indexes printing 

After you have added the appropriate markup to your document, an
external application can use this information to build an index. The
resulting index must have information about the page numbers on which
the concepts appear. It&#39;s usually the document formatter that builds
the index.  In this case, it may never be instantiated in DocBook.
 indexes index marked up in DocBook (example) 

However, there are applications that can produce an index marked up in
DocBook.  The following example includes some one- and two-level
 IndexEntry  elements (which
correspond to the primary and secondary levels in the
 indexterm s themselves) that begin with the letter D:
 
&lt;!DOCTYPE index PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot;&gt;
&lt;index&gt;&lt;title&gt;Index&lt;/title&gt;
&lt;indexdiv&gt;&lt;title&gt;D&lt;/title&gt;
&lt;indexentry&gt;
  &lt;primaryie&gt;database (bibliographic), 253, 255&lt;/primaryie&gt;
     &lt;secondaryie&gt;structure, 255&lt;/secondaryie&gt;
     &lt;secondaryie&gt;tools, 259&lt;/secondaryie&gt;
&lt;/indexentry&gt;
&lt;indexentry&gt;
  &lt;primaryie&gt;dates (language specific), 179&lt;/primaryie&gt;
&lt;/indexentry&gt;
&lt;indexentry&gt;
  &lt;primaryie&gt;DC fonts, &lt;emphasis&gt;172&lt;/emphasis&gt;, 177&lt;/primaryie&gt;
     &lt;secondaryie&gt;Math fonts, 177&lt;/secondaryie&gt;
&lt;/indexentry&gt;
&lt;/indexdiv&gt;
&lt;/index&gt;
  
 Making a Glossary glossaries creating Glossary s, like  Bibliography s, are often
constructed by hand.  However, some applications are capable of
building a skeletal index from glossary term markup in the document.
If all of your terms are defined in some glossary database, it may
even be possible to construct the complete glossary automatically.
 markup glossaries GlossTerm element LinkEnd attribute GlossTerm tag ID attribute glossary entries links glossary terms (text) to glossary entries 

To enable automatic glossary generation, or simply automatic linking
from glossary terms in the text to glossary entries, you must add
markup to your documents.  In the text, you markup a term for
compilation later with the inline  GlossTerm 
tag. This tag can have a  LinkEnd 
attribute whose value is the ID of the actual entry in the
glossary. 
Some sophisticated formatters might even be able to establish the link
simply by examining the content of the terms and the glossary. In that
case, the author is not required to make explicit links.
 
 
For instance, if you have this markup in your document:
 
&lt;glossterm linkend=&quot;xml&quot;&gt;Extensible Markup Language&lt;/glossterm&gt; is a new standard  
 glossaries example 

your glossary might look like this:
 
&lt;!DOCTYPE glossary PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot;&gt;
&lt;glossary&gt;&lt;title&gt;Example Glossary&lt;/title&gt;
 
&lt;glossdiv&gt;&lt;title&gt;E&lt;/title&gt;

&lt;glossentry id=&quot;xml&quot;&gt;&lt;glossterm&gt;Extensible Markup Language&lt;/glossterm&gt;
  &lt;acronym&gt;XML&lt;/acronym&gt;
&lt;glossdef&gt;
  &lt;para&gt;Some reasonable definition here.&lt;/para&gt;
  &lt;glossseealso otherterm=&quot;sgml&quot;&gt;
&lt;/glossdef&gt;
&lt;/glossentry&gt;

&lt;/glossdiv&gt;
 
Note that the  GlossTerm  tag
reappears in the glossary to mark up the term and distinguish it from
its definition within the  
GlossEntry . The  ID  that
the   GlossEntry  referenced in the
text is the  ID  of the  GlossEntry  in the  Glossary 
itself. You can use the link between source and glossary to create a
link in the online form of your document, as we have done with the
online form of the glossary in this book.
 Making a Bibliography bibliographies, creating raw data bibliographies cooked data bibliographies BiblioEntry element 

There are two ways to set up a bibliography in DocBook: you can have
the data  raw  or
 cooked . Here&#39;s an example of a raw
bibliographical item, wrapped in the  Biblioentry  element:
 
&lt;biblioentry xreflabel=&quot;Kites75&quot;&gt;
  &lt;authorgroup&gt;
    &lt;author&gt;&lt;firstname&gt;Andrea&lt;/firstname&gt;&lt;surname&gt;Bahadur&lt;/surname&gt;&lt;/author&gt;
    &lt;author&gt;&lt;firstname&gt;Mark&lt;/&gt;&lt;surname&gt;Shwarek&lt;/&gt;&lt;/author&gt;
  &lt;/authorgroup&gt;
  &lt;copyright&gt;&lt;year&gt;1974&lt;/year&gt;&lt;year&gt;1975&lt;/year&gt;
     &lt;holder&gt;Product Development International Holding N. V.&lt;/holder&gt;
     &lt;/copyright&gt;
  &lt;isbn&gt;0-88459-021-6&lt;/isbn&gt;    
  &lt;publisher&gt;
    &lt;publishername&gt;Plenary Publications International, Inc.&lt;/publishername&gt;
  &lt;/publisher&gt;
  &lt;title&gt;Kites&lt;/title&gt;
  &lt;subtitle&gt;Ancient Craft to Modern Sport&lt;/subtitle&gt;
  &lt;pagenums&gt;988-999&lt;/pagenums&gt;
  &lt;seriesinfo&gt;
    &lt;title&gt;The Family Creative Workshop&lt;/title&gt;
    &lt;seriesvolnums&gt;1-22&lt;/seriesvolnums&gt;
    &lt;editor&gt;
      &lt;firstname&gt;Allen&lt;/firstname&gt;
      &lt;othername role=middle&gt;Davenport&lt;/othername&gt;
      &lt;surname&gt;Bragdon&lt;/surname&gt;
      &lt;contrib&gt;Editor in Chief&lt;/contrib&gt;
    &lt;/editor&gt;
  &lt;/seriesinfo&gt;
&lt;/biblioentry&gt;
 
The  raw  data in a  Biblioentry  is comprehensive to a
fault there are enough fields to suit a host of different
bibliographical styles, and that is the point. An abundance of data
requires processing applications to select, punctuate, order, and
format the bibliographical data, and it is unlikely that all the
information provided will actually be output.
 Bibliomixed element 

All the  cooked  data in a  Bibliomixed  entry in a bibliography, on the
other hand, is intended to be presented to the reader in the form and
sequence in which it is provided. It even includes punctuation between
the fields of data:
 
&lt;bibliomixed&gt;
  &lt;bibliomset relation=article&gt;
    &lt;surname&gt;Walsh&lt;/surname&gt;, &lt;firstname&gt;Norman&lt;/firstname&gt;.
    &lt;title role=article&gt;Introduction to Cascading Style Sheets&lt;/title&gt;.
  &lt;/bibliomset&gt;
  &lt;bibliomset relation=journal&gt;
    &lt;title&gt;The World Wide Web Journal&lt;/title&gt; 
    &lt;volumenum&gt;2&lt;/volumenum&gt;&lt;issuenum&gt;1&lt;/issuenum&gt;.
    &lt;publishername&gt;O&#39;Reilly &amp; Associates, Inc.&lt;/publishername&gt; and
    &lt;corpname&gt;The World Wide Web Consortium&lt;/corpname&gt;.
    &lt;pubdate&gt;Winter, 1996&lt;/pubdate&gt;&lt;/bibliomset&gt;.
&lt;/bibliomixed&gt;
 
Clearly, these two ways of marking up bibliographical entries are
suited to different circumstances.  You should use one or the other
for your bibliography, not both. Strictly speaking, mingling the raw
and the cooked may be  kosher  as far as the   is
concerned, but it will almost certainly cause problems for most
processing applications.
 
 

 
 $Date: 2002-03-23 23:57:55 +0300 (Сб, 23 мар 2002) $ $Revision: 1322 $ Parsing DocBook Documents parsing DocBook documents DocBook DTD parsing documents 

A key feature of   and   markup is that you
 validate  it.  The DocBook   is a precise description
of valid nesting, the order of elements, and their content.  All
DocBook documents must conform to this description or they are not
DocBook documents (by definition).
 parsers validating validation parsers 

A  validating parser  is a program that can read
the   and a particular document and determine whether the exact
nesting and order of elements in the document is valid according to
the  .
 text editors unstructured, parsing and 

If you are not using a structured editor that can enforce the markup
as you type, validation with an external parser is a particularly
important step in the document creation process.  You cannot expect
to get rational results from subsequent processing (such as document
publishing) if your documents are not valid.
 SP nsgmls parser nsgmls parser 
The most popular free   parser is  SP  by James Clark,
available at  http://www.jclark.com/ .
 nsgmls parser parsers free XML parsers, free xp parser SP  includes  nsgmls , a fast command-line
parser. In the world of free validating   parsers,
James
Clark&#39;s  xp  is a popular choice.
 parsers non-validating 

Not all   parsers are validating, and although a
non-validating parser may have many uses, it cannot ensure that your
documents are valid according to the  . Validating Your Documents 
The exact way in which the parser is executed varies according to
the parser in use, naturally.  For information about your particular
parser, consult the documentation that came with it.
 Using nsgmls nsgmls parser SGML documents, validating 

The  nsgmls  command from  SP  is a
validating   parser.  The options used in the example below
suppress the normal output ( -s ), except for error messages,
print the version number ( -v ), and specify the catalog file
that should be used to map public identifiers to system
identifiers. Printing the version number guarantees that you always
get  some  output, so that you know the command ran
successfully:
 
[n:\dbtdg] nsgmls -sv -c \share\sgml\catalog test.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
 error messages nsgmls parser options error messages (parser), directing to file 

Because no error messages were printed, we know our document is valid.
If you&#39;re working with a document that you discover has many errors,
the  -f  option offers a handy way to direct the errors to a file
so they don&#39;t all scroll off your screen.
 nsgmls parser XML documents, validating declarations nsgmls parser xml.dcl declaration (nsgmls parser) XML nsgmls parser 

If you want to validate an   document with  SP ,
you must make sure that  SP  uses the correct
declaration.  An   declaration called  xml.dcl  is
included with  SP .
 
The easiest way to make sure that  SP  uses  xml.dcl  is to
include the declaration explicitly on the command line when you run
 nsgmls  (or Jade, or other  SP  tools):
 
[n:\dbtdg] nsgmls -sv -c \share\sgml\catalog m:\jade\xml.dcl test.xml
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
 Using xp xp parser Time program (xp parser) 

The  xp  distribution includes several sample programs.
One of these programs,  Time , performs a validating parse
of the document and prints the amount of time required to parse the
  and the document.  This program makes an excellent validity
checker:
 
java com.jclark.xml.apps.Time examples\simple.xml
6.639
 
The result states that it took 6.639 seconds to parse the   and
the document.  This indicates that the document is valid.  If the
document is invalid, additional error messages are displayed.
 Understanding Parse Errors errors parsing parsing errors error messages parsers 

Every parser produces slightly different error messages, but most
indicate exactly (at least technically) 
It is often the case that you can correct an error in the document in
several ways.  The parser suggests one possible fix, but this is not
always the right fix.  For example, the parser may suggest that you
can correct out of context data by adding another element, when in
fact it&#39;s  obvious  to human eyes that the problem is a
missing end tag.
  what is wrong and where the error occurred.  With a little
experience, this information is all you&#39;ll need to quickly identify
what&#39;s wrong.
 Jade SP parser, using 

In the rest of this section, we&#39;ll look at a number of common errors
and the messages they produce in  SP .  We&#39;ve
chosen  SP  for the rest of these examples because
that is the same parser used by Jade, which we&#39;ll be discussing
further in  .
  Cannot Be Found cannot be found errors DTDs cannot be found errors public identifiers errors 

The telltale sign that SP could not find the  , or some module of
the  , is the error message: &quot;cannot generate system identifier
for public text  &quot;.  Generally, the errors that occur after
this are spurious; if SP couldn&#39;t find some part of the  ,
it&#39;s likely to think that  everything  is wrong.
 
Careful examination of the following document will show that we&#39;ve
introduced a simple typographic error into the public identifier (the
word  DocBook  is misspelled with a lowercase  b ):
 
SP responds dramatically to this error:
 
hermes:/documents/books/tdg/examples/errs$ nsgmls -sv -c cat1 /usr/lib/sgml/declaration/xml.dcl nodtd.sgm
nsgmls:I: SP version &quot;1.3.4&quot;
nsgmls:nodtd.sgm:2:76:E: could not resolve host &quot;www.oasis-open.org&quot; (try again later)
nsgmls:nodtd.sgm:2:76:E: DTD did not contain element declaration for document type name
nsgmls:nodtd.sgm:3:8:E: element &quot;chapter&quot; undefined
nsgmls:nodtd.sgm:3:15:E: element &quot;title&quot; undefined
nsgmls:nodtd.sgm:4:5:E: element &quot;para&quot; undefined
nsgmls:nodtd.sgm:10:5:E: element &quot;para&quot; undefined
nsgmls:nodtd.sgm:11:15:E: there is no attribute &quot;role&quot;
nsgmls:nodtd.sgm:11:21:E: element &quot;emphasis&quot; undefined
nsgmls:nodtd.sgm:12:9:E: element &quot;emphasis&quot; undefined
nsgmls:nodtd.sgm:12:24:E: element &quot;emphasis&quot; undefined
nsgmls:nodtd.sgm:13:18:E: element &quot;superscript&quot; undefined
nsgmls:nodtd.sgm:14:16:E: element &quot;subscript&quot; undefined
nsgmls:nodtd.sgm:16:5:E: element &quot;para&quot; undefined
 catalog files errors 

Other things to look for, if you haven&#39;t misspelled the public
identifier, are typos in the catalog or failure to specify a catalog
that resolves the public identifier that can&#39;t be found.
 ISO  Entity Set Missing entity sets missing 

A missing entity set is another example of either a misspelled public
identifier, or a missing catalog or catalog entry.
 
In this case, there&#39;s nothing wrong with the document, but the catalog
that&#39;s been specified is missing the public identifiers for the
 ISO  entity sets:
 
[n:\dbtdg]nsgmls -sv -c examples\errs\cat2 examples\simple.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:53:65:W: cannot generate system identifier for public text &quot;ISO 8879:1986//ENTITIES Added Math Symbols:Arrow Relations//EN&quot;
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:54:8:E: reference to entity &quot;ISOamsa&quot; for which no system identifier could be generated
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:52:0: entity was defined here
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:60:66:W: cannot generate system identifier for public text &quot;ISO 8879:1986//ENTITIES Added Math Symbols:Binary Operators//EN&quot;
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:61:8:E: reference to entity &quot;ISOamsb&quot; for which no system identifier could be generated
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:59:0: entity was defined here
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:67:60:W: cannot generate system identifier for public text &quot;ISO 8879:1986//ENTITIES Added Math Symbols:Delimiters//EN&quot;
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:68:8:E: reference to entity &quot;ISOamsc&quot; for which no system identifier could be generated
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:66:0: entity was defined here
m:\jade\nsgmls.exe:n:/share/sgml/docbook/3.1/dbcent.mod:74:67:W: cannot generate system identifier for public text &quot;ISO 8879:1986//ENTITIES Added Math Symbols:Negated Relations//EN&quot;
...
 entity sets locating 

The  ISO  entity sets are required by the DocBook
 , but they are not distributed with it.  That&#39;s because they
aren&#39;t maintained by  OASIS . 
If you need to locate the entity sets, consult  http://www.oasis-open.org/cover/topics.html#entities .
 
 Character Data Not Allowed Here error messages character data out of context characters errors (out of context) start tags errors 

Out of context character data is frequently caused by a missing start
tag, but sometimes it&#39;s just the result of typing in the wrong place!
 
[n:\dbtdg] nsgmls -sv -c \share\sgml\catalog examples\errs\badpcdata.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
m:\jade\nsgmls.exe:examples\errs\badpcdata.sgm:9:0:E: character data is not allowed here
 Chapter element errors, character data Chapter s aren&#39;t allowed to contain character data
directly. Here, a wrapper element, such as  Para , is
missing around the sentence between the first two paragraphs.
 Misspelled Start Tag start tags errors misspelling 

If you spell it wrong, the parser gets confused.
 
[n:\documents\books\dbtdg]nsgmls -sv -c \share\sgml\catalog examples\errs\misspe
ll.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
m:\jade\nsgmls.exe:examples\errs\misspell.sgm:9:5:E: element &quot;PAAR&quot; undefined
m:\jade\nsgmls.exe:examples\errs\misspell.sgm:14:6:E: end tag for element &quot;PARA&quot; which is not open
m:\jade\nsgmls.exe:examples\errs\misspell.sgm:21:9:E: end tag for &quot;PAAR&quot; omitted, but OMITTAG NO was specified
m:\jade\nsgmls.exe:examples\errs\misspell.sgm:9:0: start tag was here
 
Luckily, these are pretty easy to spot, unless you accidentally spell
the name of another element.  In that case, your error might appear to
be out of context.
 Misspelled End Tag end tags errors, misspelling 

Spelling the end tag wrong is just as confusing.
 
[n:\dbtdg]nsgmls -sv -c \share\sgml\catalog examples\errs\misspell2.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
m:\jade\nsgmls.exe:examples\errs\misspell2.sgm:2:35:E: end tag for element &quot;TITEL&quot; which is not open
m:\jade\nsgmls.exe:examples\errs\misspell2.sgm:3:5:E: document type does not allow element &quot;PARA&quot; here; missing one of &quot;FOOTNOTE&quot;, &quot;MSGTEXT&quot; start-tag
m:\jade\nsgmls.exe:examples\errs\misspell2.sgm:9:5:E: document type does not allow element &quot;PARA&quot; here; missing one of &quot;FOOTNOTE&quot;, &quot;MSGTEXT&quot; start-tag
m:\jade\nsgmls.exe:examples\errs\misspell2.sgm:15:5:E: document type does not allow element &quot;PARA&quot; here; missing one of &quot;FOOTNOTE&quot;, &quot;MSGTEXT&quot; start-tag
m:\jade\nsgmls.exe:examples\errs\misspell2.sgm:21:9:E: end tag for &quot;TITLE&quot; omitted, but OMITTAG NO was specified
m:\jade\nsgmls.exe:examples\errs\misspell2.sgm:2:9: start tag was here
m:\jade\nsgmls.exe:examples\errs\misspell2.sgm:21:9:E: end tag for &quot;CHAPTER&quot; which is not finished
 
These are pretty easy to spot as well, but look at how confused the
parser became.  From the parser&#39;s point of view, failure to close the
open  Title  element means that all the following elements
appear out of context.
 Out of Context Start Tag start tags errors out of context tags context errors 

Sometimes the problem isn&#39;t spelling, but placing a tag in the wrong
context.  When this happens, the parser tries to figure out what it
can add to your document to make it valid.  Then it proceeds as if it
had seen what was added in order to recover from the error seen, which
can cause future errors.
 
[n:\dbtdg]nsgmls -sv -c \share\sgml\catalog examples\errs\badstarttag.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
m:\jade\nsgmls.exe:examples\errs\badstarttag.sgm:9:12:E: document type does not allow element &quot;TITLE&quot; here; missing one of &quot;CALLOUTLIST&quot;, &quot;SEGMENTEDLIST&quot;, &quot;VARIABLELIST&quot;, &quot;CAUTION&quot;, &quot;IMPORTANT&quot;, &quot;NOTE&quot;, &quot;TIP&quot;, &quot;WARNING&quot;, &quot;BLOCKQUOTE&quot;, &quot;EQUATION&quot;, &quot;EXAMPLE&quot;, &quot;FIGURE&quot;, &quot;TABLE&quot; start-tag
 titles formal elements errors paragraphs titles 

In this example, we probably wanted a  FormalPara , so that
we could have a title on the paragraph.  But note that the parser
didn&#39;t suggest this alternative.  The parser only tries to add
additional elements, rather than rename elements that it&#39;s already
seen.
 Missing End Tag end tags missing, errors 

Leaving out an end tag is a lot like an out of context start tag.  In
fact, they&#39;re really the same error.  The problem is never caused by
the missing end tag per se, rather it&#39;s caused by the fact that
something following it is now out of context.
 
[n:\dbtdg]nsgmls -sv -c \share\sgml\catalog examples\errs\noendtag.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
m:\jade\nsgmls.exe:examples\errs\noendtag.sgm:14:5:E: document type does not allow element &quot;PARA&quot; here; missing one of &quot;FOOTNOTE&quot;, &quot;MSGTEXT&quot;, &quot;CAUTION&quot;, &quot;IMPORTANT&quot;, &quot;NOTE&quot;, &quot;TIP&quot;, &quot;WARNING&quot;, &quot;BLOCKQUOTE&quot;, &quot;INFORMALEXAMPLE&quot; start-tag
m:\jade\nsgmls.exe:examples\errs\noendtag.sgm:20:9:E: end tag for &quot;PARA&quot; omitted, but OMITTAG NO was specified
m:\jade\nsgmls.exe:examples\errs\noendtag.sgm:9:0: start tag was here
 
In this case, the parser figured out that the best thing it could do
is end the paragraph.
 Bad Entity Reference entities errors, spelling 

If you spell an entity name wrong, the parser will catch it.
 
[n:\dbtdg]nsgmls -sv -c \share\sgml\catalog examples\errs\badent.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
m:\jade\nsgmls.exe:examples\errs\badent.sgm:10:26:E: general entity &quot;xyzzy&quot; not defined and no default entity
 
More often than not, you&#39;ll see this when you misspell a character
entity name.  For example, this happens when you type
 &amp;ldqou;  instead of
 &amp;ldquo; .
 Invalid 8-Bit Character characters character sets Unicode character set (SGML errors) 8-bit characters, errors (SGML) errors 8-bit characters (SGML) 

In  , the entire range of Unicode characters is available to you,
but in  , the declaration indicates what characters are valid.
The distributed DocBook declaration doesn&#39;t allow a bunch of fairly
common 8-bit characters.
 
[n:\dbtdg]nsgmls -sv -c \share\sgml\catalog examples\errs\badchar.sgm
m:\jade\nsgmls.exe:I: SP version &quot;1.3.2&quot;
m:\jade\nsgmls.exe:examples\errs\badchar.sgm:11:0:E: non SGML character number 147
m:\jade\nsgmls.exe:examples\errs\badchar.sgm:11:5:E: non SGML character number 148
 declarations character sets, errors entities characters errors 

In this example, the Windows code page values for
curly left and right quotes have been used, but they aren&#39;t in the
declared character set.  Fix this by converting them to character
entities.
 interchange partners 

You can also fix them by changing the declaration, but if you do that,
make sure all your interchange partners are aware of, and have a copy of,
the modified declaration. See  .
 
 
 
 Considering Other Schema Languages Historically,  s were the only way to describe the valid
stricture of SGML and XML documents, but that is no longer the case.
At the time of this writing (January, 2001), DocBook is experimentally
available in three other schema languages: XML Schema The schema language being defined by the
 W3C  as the successor to  s
for describing the structure of  . XML Schema are likely to become
a  W3C  Recommendation in 2001.
 RELAX RELAX, the Regular Language description for XML) is a less
complex alternative to XML Schemas. The RELAX Core module is defined by
ISO in  ISO/IEC DTR 22250-1, Document Description and
Processing Languages -- Regular Language Description for XML (RELAX)
-- Part 1: RELAX Core, 2000 . The RELAX Namespaces module
is currently under development.
 TREX TREX, Tree Regular Expressions for XML, is another less complex
alternative to XML Schemas. It is concise, powerful, and datatype
neutral. Parsing and Validation Before we look closer at these new schema languages, there&#39;s one
significant difference between  s and all of them that we should
get out of the way:   parsers (which may understand  s) build an
  information set out of a stream of characters, all of these other
schema languages begin with an information set and perform validation
on it. What I mean by that is that an   parser reads a stream of
bytes:

 &quot;&lt;&quot; &quot;?&quot; &quot;x&quot; &quot;m&quot; &quot;l&quot; &quot; &quot; &quot;v&quot; &quot;e&quot; ...
&quot;&lt;&quot; &quot;!&quot; &quot;D&quot; &quot;O&quot; &quot;C&quot; &quot;T&quot; &quot;Y&quot; &quot;P&quot; &quot;E&quot; &quot; &quot; &quot;b&quot; &quot;o&quot; &quot;o&quot; &quot;k&quot; ...
&quot;&lt;&quot; &quot;b&quot; &quot;o&quot; &quot;o&quot; &quot;k&quot; &quot; &quot; &quot;i&quot; &quot;d&quot; &quot;=&quot; &quot;&#39;&quot; &quot;f&quot; &quot;o&quot; &quot;o&quot; &quot;&#39;&quot; &quot;&gt;&quot;
...
&quot;&lt;&quot; &quot;/&quot; &quot;b&quot; &quot;o&quot; &quot;o&quot; &quot;k&quot; &quot;&gt;&quot; 

interprets them as a stream of characters (which may change the
interpretation of some sequences of bytes) and constructs some
representation of the   document. This representation is the set
of all the   information items encountered: the information
set of the document. The  W3C 
 XML Core Working Group 
is in the process of defining what an
  Information Set 
contains. The other schema languages are defined not in terms of the sequence
of characters in the file but in terms of the information set of the
  document. They have to work this way because the
  Recommendation 
says what an   document is and they all want to work on top of
 . So what, you might ask? Well, it turns out that this has at least
one very significant implication: there&#39;s no way for these languages to
provide support for entity declarations. An entity, like  &amp;ora; 
as a shortcut for  O&#39;Reilly &amp; Associates  or
 &amp;eacute;  as a mnemonic for
 , is a feature of the character stream seen by
the   parser, it doesn&#39;t exist in the information set of valid
  documents. More importantly, this means that even if the schema
language had a syntax for declaring entities, it wouldn&#39;t help the  
parser that needs to know the definitions long before the schema language
processor comes into play. There are a couple of other   features that are impacted,
though not necessarily as significantly: notations and default
attribute values.  One use for notations is on external entity
declarations, and as we&#39;ve already seen, the schema language is too
late to be useful for anything entity related. Default attribute values
are also problematic since you would like them to be in the information
set produced by the parser so that the schema language sees them. A Coarse Comparison of Three   Schema Languages FIXME: write a short synopsis of how these languages compare. 

 
 $Date: 2005-11-13 00:36:21 +0300 (Вс, 13 ноя 2005) $ $Revision: 5449 $ Publishing DocBook Documents DocBook DTD publishing documents publishing DocBook documents stylesheets publishing SGML/XML documents HTML translating SGML/XML documents 

Creating and editing  /  documents is usually only half the
battle. After you&#39;ve composed your document, you&#39;ll want to publish
it. Publishing, for our purposes, means either print or web
publishing. For   and   documents, this is usually
accomplished with some kind of  stylesheet .  In
some environments, it is now possible to publish an  
document on the Web simply by putting it online with a stylesheet.
 Jade Modular DocBook Stylesheets Modular DocBook Stylesheets Linux Documentation Project 

There are many ways, using both free and commercial tools, to publish
  documents. In this chapter, we&#39;re going to survey a number of
possibilities, and then look at just one solution in detail:  Jade  and the  Modular DocBook
Stylesheets.  We used jade to produce this
book and to produce the online versions on the
 CD-ROM ; it is also being deployed in other projects
such as  &lt;SGML&gt;&amp;tools; , 
which originated with the Linux Documentation Project.
 
For a brief survey of other tools, see  .
 The MIME Type for DocBook When published on the web, documents must be identified with a MIME type.
The MIME type for SGML DocBook documents published directly on the web
is “ application/sgml ”.
The most appropriate MIME type for XML DocBook documents published directly on
the web is currently
“ application/xml ”, however the DocBook Technical Committee
may choose to register a more specific MIME type in the future. A Survey of Stylesheet Languages stylesheets languages languages stylesheets 

Over the years, a number of attempts have been made to produce a
standard stylesheet language and, failing that, a large number of
proprietary languages have been developed.
 FOSIs FOSI stylesheets Formatting Output Specification Instance FOSI stylesheets U.S. Department of Defense stylesheet standard 

First, the U.S. Department of Defense, in an attempt to
standardize stylesheets across military branches, created the
 Output Specification , which is defined in
 MIL-PRF-28001C ,  Markup Requirements and
Generic Style Specification for Electronic Printed Output and Exchange
of Text . 
See  Formally
Published CALS Standards  for more information.
 
 ADEPT Publisher (Arbortext), FOSIs support Arbortext ADEPT Publisher, FOSIs support 

Commonly called FOSIs (for Formatting Output Specification Instances),
they are supported by a few products including ADEPT Publisher by
 Arbortext  and DL
Composer by  Datalogics .
 DSSSL DSSSL Document Style Semantics and Specification Language DSSSL ISO standards DSSSL International Organization for Standardization ISO Entity Sets; ISO standards 

Next, the International Organization for Standardization
( ISO ) created  DSSSL , the
Document Style Semantics and Specification Language. Subsets of
 DSSSL  are supported by Jade and a few other tools,
but it never achieved widespread support.
 CSS CSS HTML CSS XML CSS 

The  W3C  CSS Working Group created
 CSS  as a style attachment language for  , and,
more recently,  .
 XSL XSL XML XSL Extensible Style Language XSL 
Most recently, the   effort has identified a standard Extensible Style
Language ( XSL ) as a requirement. The
 W3C   XSL  Working Group is
currently pursuing that effort.
 Stylesheet Examples stylesheets examples 



By way of comparison, here&#39;s an example of each of the standard style
languages. In each case, the stylesheet fragment shown contains the
rules that reasonably formatted the following paragraph:
 &lt;para&gt;
This is an example paragraph. It should be presented in a
reasonable body font. &lt;emphasis&gt;Emphasized&lt;/emphasis&gt; words
should be printed in italics. A single level of 
&lt;emphasis&gt;Nested &lt;emphasis&gt;emphasis&lt;/emphasis&gt; should also
be supported.&lt;/emphasis&gt;
&lt;/para&gt;
 FOSI  stylesheet FOSI stylesheets example SGML FOSIs e-i-c element element in context (e-i-c) FOSI s are   documents. The element in the
 FOSI  that controls the presentation of specific
elements is the  e-i-c  (element in context) element.
A sample  FOSI  fragment is shown in  .
 A Fragment of a  FOSI  Stylesheet DSSSL  stylesheet DSSSL stylesheets example Scheme language DSSSL stylesheets DSSSL  stylesheets are written in a Scheme-like
language (see   later in this chapter). It is the
 element  function that controls the presentation of
individual elements. See the example in  .
 A Fragment of a  DSSSL  Stylesheet CSS  stylesheet CSS stylesheets example CSS  stylesheets consist of selectors and formatting
properties, as shown in  .
 A Fragment of a  CSS  Stylesheet XSL  stylesheet XSL stylesheets example XSL  stylesheets are   documents, as shown in
 . The element in the  XSL 
stylesheet that controls the presentation of specific elements is the
 xsl:template  element.
 A Fragment of an  XSL  Stylesheet Using Jade and  DSSSL  to Publish DocBook Documents Jade DSSSL, using (DocBook document) SGML DSSSL stylesheets XML DSSSL stylesheets DSSSL stylesheets print and HTML output (DocBook) HTML DSSSL stylesheets 

Jade is a free tool that applies  DSSSL 
stylesheets to   and   documents. As distributed, Jade can
output  RTF ,  ,  MIF , and
 . The   backend can be used for   to  
transformations (for example, DocBook to  ).
 
A complete set of  DSSSL  stylesheets for creating
print and   output from DocBook is included on the
 CD-ROM .  More information about obtaining and
installing Jade appears in  .
 
 A Brief Introduction to  DSSSL DSSSL  is a stylesheet language for both print and
online rendering.  The acronym stands for  Document Style
Semantics and Specification Language . It is defined by
 ISO / IEC  10179:1996. For more
general information about  DSSSL , see  the  DSSSL 
Page .
 Scheme Scheme language syntax LISP language, syntax syntax LISP language 

The  DSSSL  expression language is Scheme, a variant
of Lisp. Lisp is a functional programming language with a remarkably
regular syntax. Every expression looks like this:
 
( operator   arg1   arg2  ...  arg n  )
 
 syntax Scheme language 
This is called  prefix  syntax because the operator comes
before its arguments. In Scheme, the expression that
subtracts 2 from 3, is  (- 3 2) . And  (+ (-
3 2) (* 2 4))  is 9. While the prefix syntax and the
parentheses may take a bit of getting used to, Scheme is not hard to
learn, in part because there are no exceptions to the syntax.
 DSSSL  Stylesheets DSSSL stylesheets formatting DSSSL stylesheets, elements 

A complete  DSSSL  stylesheet is shown in  .  After only a brief examination of the
stylesheet, you&#39;ll probably begin to have a feel for how it works. For
each element in the document, there is an element rule that describes
how you should format that element. The goal of the rest of this
chapter is to make it possible for you to read, understand, and even
write stylesheets at this level of complexity.
 A Complete  DSSSL  Stylesheet DocBook DTD documents DSSSL stylesheets 

This stylesheet is capable of formatting simple DocBook documents like
the one shown in  .
 A Simple DocBook Document 
The result of formatting a simple document with this stylesheet can be
seen in  .
 The formatted simple document 
We&#39;ll take a closer look at this stylesheet after you&#39;ve learned a
little more  DSSSL .
 DSSSL  Stylesheets Are   Documents SGML DSSSL stylesheets entities DSSSL stylesheets marked sections DSSSL stylesheets 

One of the first things that may strike you about
 DSSSL  stylesheets (aside from all the parentheses),
is the fact that the stylesheet itself is an   document! This
means that you have all the power of   documents at your disposal
in  DSSSL  stylesheets. In particular, you can use
entities and marked sections to build a modular stylesheet.
 architecture DSSSL DTDs DSSSL stylesheets, changing 

In fact,  DSSSL  stylesheets are defined so that they
correspond to a particular  architecture . This
means that you can change the   used by stylesheets within the
bounds of the architecture. A complete discussion of document
architectures is beyond the scope of this book, but we&#39;ll show you one
way to take advantage of them in your  DSSSL 
stylesheets in   later in the
chapter.
 DSSSL  Processing Model processing model (DSSSL) trees (DSSSL) nodes (DSSSL) 

A  DSSSL  processor builds a tree out of the source
document. Each element in the source document becomes a node in the
tree (processing instructions and other constructs become nodes as
well). Processing the source tree begins with the root rule and
continues until there are no more nodes to process.
 Global Variables and Side Effects variables (DSSSL) global side effects (DSSSL) 

There aren&#39;t any global variables or side effects. It can be difficult
to come to grips with this, especially if you&#39;re just starting out.
 functions DSSSL constants (DSSSL) 

It is possible to  define constants
and functions  and to create local variables with  let  expressions ,
but you can&#39;t create any global variables or change anything after
you&#39;ve defined it.
 DSSSL  Expressions expressions (DSSSL) DSSSL  has a rich vocabulary of expressions for
dealing with all of the intricacies of formatting. Many, but by no
means all of them, are supported by Jade. In this introduction, we&#39;ll
cover only a few of the most common.
 Element expressions DSSSL stylesheets element expressions elements element expressions (DSSSL) paragraphs DSSSL stylesheets, formattting 

Element expressions, which define the rules for formatting particular
elements, make up the bulk of most  DSSSL 
stylesheets. A simple element rule can be seen in  . This rule says that a   para 
element should be formatted by making a paragraph (see  ).
 A Simple  DSSSL  Rule 
(element para
  (make paragraph
    space-before: 8pt
    (process-children))) ancestors (elements), DSSSL 

An element expression can be made more specific by specifying an
element and its ancestors instead of just specifying an element. The
rule  (element title ...)  applies to all
 Title  elements, but a rule that begins
 (element (figure title) ...)  applies only to
 Title  elements that are immediate children of
 Figure  elements.
 
If several rules apply, the most specific rule is used.
 
When a rule is used, the node in the source tree that was matched
becomes the  current node  while that element expression
is being processed.
 Make expressions flow objects (DSSSL) content flow objects (DSSSL) 

A make expression specifies the characteristics of a  flow
object.  Flow objects are abstract representations of content
(paragraphs, rules, tables, and so on). The expression:
 
(make paragraph
  font-size: 12pt
  line-spacing: 14pt ...)
 
specifies that the content that goes  here  is to be
placed into a paragraph flow object with a font-size of 12pt and a
line-spacing of 14pt (all of the unspecified characteristics of the
flow object are defaulted in the appropriate way).
 
They&#39;re called flow objects because  DSSSL , in its
full generality, allows you to specify the characteristics of a
sequence of flow objects and a set of areas on the physical page where
you can place content. The content of the flow objects is then
 poured on to  (or flows in to) the areas on the page(s).
 sosofo (DSSSL) make expressions (DSSSL) 

In most cases, it&#39;s sufficient to think of the make expressions as
constructing the flow objects, but they really only specify the
 characteristics  of the flow objects. This detail
is apparent in one of the most common and initially confusing pieces
of  DSSSL  jargon: the
 sosofo . Sosofo stands for a
 specification of a sequence of flow objects.  All this
means is that processing a document may result in a nested set of 
 make  expressions (in other words, the paragraph may contain a table that
contains rows that contain cells that contain paragraphs, and so on).
 
The general form of a  make  expression is:
 
(make  flow-object-name 
   keyword1:   value1 
   keyword2:   value2 
  ...
   keywordn:   valuen 
  ( content-expression ))
 
 keywords flow objects (DSSSL), defining 

Keyword arguments specify the characteristics of the flow object. The
specific characteristics you use depends on the flow object. The
 content-expression  can vary; it is usually
another make expression or one of the  processing expressions .
 flow objects (DSSSL) 

Some common flow objects in the print stylesheet are:
 simple-page-sequence simple-page-sequence (DSSSL) flow object 
Contains a sequence of pages. The keyword arguments of this flow
object let you specify margins, headers and footers, and other
page-related characteristics.  Print stylesheets should always produce
one or more  simple-page-sequence   flow objects.
 
Nesting  simple-page-sequence  does not
work. Characteristics on the inner sequences are ignored.
 paragraph paragraphs DSSSL flow objects nesting paragraphs (DSSSL) 

A paragraph is used for any block of text. This may include not only
paragraphs in the source document, but also titles, the terms in a
definition list, glossary entries, and so on. Paragraphs in
 DSSSL  can be nested.
 sequence sequences DSSSL flow objects 

A sequence is a wrapper. It is most frequently used to change
inherited characteristics (like font style) of a set of flow objects
without introducing other semantics (such as line breaks).
 score score (DSSSL flow object) 

A score flow object creates underlining, strike-throughs, or
overlining.
 table tables DSSSL flow objects 

A table flow object creates a table of rows and cells. HTML DSSSL flow objects 

The   stylesheet uses the   backend, which has a different
selection of flow objects.
 element make expressions (DSSSL) elements creating 

Creates an element. The content of this  make 
expression will appear between the start and end tags. The expression:
 
(make element gi: &quot;H1&quot; 
        (literal &quot;Title&quot;))
 produces  &lt;H1&gt;Title&lt;/H1&gt; . empty-element empty elements creating 
Creates an empty element that may not have content. The expression: 
(make empty-element gi: &quot;BR&quot;
     attributes: &#39;((&quot;CLEAR&quot; &quot;ALL&quot;)))
 produces  &lt;BR CLEAR=&quot;ALL&quot;&gt; . sequence wrappers sequences (DSSSL) 

Produces no output in of itself as a wrapper, but is still
required in  DSSSL  contexts in which you want to
output several flow objects but only one object top-level object may
be returned.
 entity-ref entities entity-ref (DSSSL) references entities (DSSSL) entity-ref (DSSSL flow objects) 

Inserts an entity reference. The expression: (make entity-ref name: &quot;nbsp&quot;) produces  &amp;nbsp; . DSSSL stylesheets flow objects, empty empty flow objects (DSSSL) flow objects (DSSSL) empty 

In both stylesheets, a completely empty flow object is constructed
with  (empty-sosofo) .
 Selecting data data, selecting (DSSSL) selecting data (DSSSL) 

Extracting parts of the source document can be accomplished with these
functions:
 (data  nd ) 
Returns all of the character data from  nd  as a
string.
 (attribute-string &quot; attr &quot;  nd ) 
Returns the value of the  attr  attribute of  nd .
 (inherited-attribute-string &quot; attr &quot;  nd ) 
Returns the value of the  attr  attribute of
 nd .  If that attribute is not specified on
 nd , it searches up the hierarchy for the first
ancestor element that does set the attribute, and returns its value.
 Selecting elements elements selecting selecting elements (DSSSL) content reordering, DSSSL functions DSSSL elements, selecting nodes (DSSSL) 

A common requirement of formatting is the ability to reorder content.
In order to do this, you must be able to select other elements in the
tree for processing.  DSSSL  provides a number of
functions that select other elements.  These functions all return a
list of nodes.
 (current-node) Returns the current node. (children  nd ) Returns the children of  nd .  (descendants  nd ) 
Returns the descendants of  nd  (the children of
 nd  and all their children&#39;s children, and so on). 
 (parent  nd ) Returns the parent of  nd .  (ancestor &quot; name &quot;  nd ) 
Returns the first ancestor of  nd  named
 name . 
 (element-with-id &quot; id &quot;) 
Returns the element in the document with the  ID 
 id , if such an element exists. 
 (select-elements  node-list  &quot; name &quot;) 
Returns all of the elements of the  node-list  that have
the name  name . For example,  (select-elements
(descendants (current-node)) &quot;para&quot;)  returns a list of all
the paragraphs that are descendants of the current node. 
 (empty-node-list) 
Returns a node list that contains no nodes. 
Other functions allow you to manipulate node lists.
 (node-list-empty?  nl ) 
Returns true if (and only if)  nl  is an empty node
list. 
 (node-list-length  nl ) Returns the number of nodes in  nl .  (node-list-first  nl ) 
Returns a node list that consists of the single node that is the first
node in  nl . 
 (node-list-rest  nl ) 
Returns a node list that contains all of the nodes in
 nl  except the first node.
 expressions (DSSSL) nodes and node lists, manipulating elements element expressions (DSSSL) lists nodes, manipulating 

There are many other expressions for manipulating nodes and node
lists.
 Processing expressions processing expressions (DSSSL) 

Processing expressions control which elements in the document will be
processed and in what order. Processing an element is performed by
finding a matching element rule and using that rule.
 (process-children) 
Processes all of the children of the current node. In most cases, if
no process expression is given, processing the children is the default
behavior.
 (process-node-list  nl ) Processes each of the elements in  nl . Define expressions functions declaring your own (DSSSL) constants (DSSSL) declarations functions and constants (DSSSL) 

You can declare your own functions and constants in
 DSSSL . The general form of a function declaration
is:
 
(define ( function   args )
   function-body )
 
A constant declaration is:
 (define  constant 
   constant-function-body )
 
 
The distinction between constants and functions is that the body of a
constant is evaluated when the definition occurs, while functions are
evaluated when they are used.
 Conditionals conditionals (DSSSL) false, testing for (DSSSL) true, testing for (DSSSL) expressions (DSSSL) conditionals 

In  DSSSL , the constant  #t 
represents true and  #f  false. There are several
ways to test conditions and take action in  DSSSL .
 if if expressions (DSSSL) 

The form of an  if  expression is:
 
(if  condition 
   true-expression 
   false-expression )
 
 
If the condition is true, the
 true-expression  is evaluated, otherwise the
 false-expression  is evaluated. You must
always provide an expression to be evaluated when the condition is not
met. If you want to produce nothing, use
 (empty-sosofo) .
 case case expression (DSSSL) case  selects from among several alternatives:
 
(case  expression 
  (( constant1 ) ( expression1 )
  (( constant2 ) ( expression2 )
  (( constant3 ) ( expression3 )
  (else  else-expression ))
 
 
The value of the expression is compared against each of the constants
in turn and the expression associated with the first matching constant
is evaulated.
 cond conditionals (DSSSL) cond  also selects from among several alternatives,
but the selection is performed by evaluating each expression:
 
(cond
  (( condition1 ) ( expression1 )
  (( condition2 ) ( expression2 )
  (( condition3 ) ( expression3 )
  (else  else-expression ))
 
 
The value of each conditional is calculated in turn. The expression
associated with the first condition that is true is evaluated.
 empty sets (DSSSL) 

Any expression that returns  #f  is false; all other
expressions are true. This can be somewhat counterintuitive.  In many
programming languages, it&#39;s common to assume that  empty 
things are false (0 is false, a null pointer is false, an empty set is
false, for example.) In  DSSSL , this isn&#39;t the case;
note, for example, that an empty node list is not
 #f  and is therefore true.  To avoid these
difficulties, always use functions that return true or false in
conditionals. To test for an empty node list, use
 (node-list-empty?) .
 Let expressions let expressions (DSSSL) 

The way to create local variables in  DSSSL  is with
 (let) . The general form of a  let 
expression is:
 
(let (( var1   expression1 )
      ( var2   expression2 )
      ...
      ( varn   expressionn ))
   let-body )
 
 variables (DSSSL) let expressions 
In a  let ; expression, all of the variables are
defined  simultaneously.  The expression that defines
  var2  cannot contain any references to any
other variables defined in the same  let 
expression. A  let*  expression allows variables to
refer to each other, but runs slightly slower.
 define expresssions (DSSSL) 
Variables are available only within the
 let-body .  A common use of
 let  is within a  define 
expression:
 
(define (cals-rule-default nd)
   (let* ((table (ancestor &quot;table&quot; nd))
          (frame (if (attribute-string &quot;frame&quot; table)
                     (attribute-string &quot;frame&quot; table)
                     &quot;all&quot;)))
    (equal? frame &quot;all&quot;)))
 
 
This function creates two local variables  table  and
 frame .  let  returns the value of
the last expression in the body, so this function returns true if the
 frame  attribute on the table is
  all  or if no  frame  attribute is present.
 Loops for loop, DSSSL and loops, implementing (DSSSL) tail recursion (DSSSL) DSSSL  doesn&#39;t have any construct that resembles the
 for loop  that occurs in most imperative languages like C
and Java. Instead,  DSSSL  employs a common trick in
functional languages for implementing a loop: tail recursion.
 
Loops in  DSSSL  use a special form of
 let . This loop counts from 1 to 10:
 
(let  loopvar  ((count 1))
   (if (&gt; count 10)
     #t
    ( loopvar  (+ count 1)))) This variable controls the loop. It is declared without an
initial value, immediately after the  let 
operand. variables (DSSSL) local, defining after loop variable 

Any number of additional local variables can be defined after
the loop variable, just as they can in any other
 let  expression. If you ever want the loop to end, you have to put some sort of a
test in it. This is the value that will be returned. Note that you iterate the loop by using the loop variable as if
it was a function name. The arguments to this  function  are the values that
you want the local variables declared in   to have
in the next iteration. A Closer Look at  DSSSL stylesheets style specifications  is a style sheet that contains a
style specification. Stylesheets may consist of multiple
specifications, as we&#39;ll see in  .
 
The actual  DSSSL  code goes in the style
specification body, within the style specification.  Each construction
rule processes different elements from the source document.
 Processing chapters chapters, processing (DSSSL) simple-page-sequence (DSSSL) chapters, constructing printing stylesheets Chapter s are processed by the  chapter 
construction rule. Each  Chapter  is formatted as a
 simple-page-sequence . Every print stylesheet should format
a document as one or more simple page sequences.  Characteristics on
the simple page sequence can specify headers and footers as well as
margins and other page parameters.
 nesting simple page sequences (DSSSL), not allowed 

One important note about simple page sequences: they cannot nest.
This means that you cannot blindly process divisions
( Part s,  Reference ) and the elements they
contain ( Chapter s,  RefEntry s) as simple page
sequences. This sometimes involves a little creativity.
 Processing titles titles processing, DSSSL 

The  make  expression in the  title  element rule
ensures that  Title s are formatted in large, bold print.
 
This construction rule applies equally to  Chapter  titles,
 Figure  titles, and  Book  titles.  It&#39;s unlikely
that you&#39;d want all of these titles to be presented in the same way,
so a more robust stylesheet would have to arrange the processing of
titles with more context.  This might be achieved in the way that
nested  Emphasis  elements are handled in  .
 Processing paragraphs Para  elements are simply formatted as paragraphs.
 Para element DSSSL, processing 

 Processing emphasis Emphasis element DSSSL, processing nesting emphasis elements, DSSSL processing 

Processing  Emphasis  elements is made a little more
interesting because we want to consider an attribute value and the
possibility that  Emphasis  elements can be nested.
 
In the simple case, in which we&#39;re processing an  Emphasis 
element that is not nested, we begin by testing the value of the
 role  attribute.  If the content of that
attribute is the string  strong , it is formatted
in bold; otherwise, it is formatted in italic.
 
The nested case is handled by the  (emphasis emphasis) 
rule. This rule simply formats the content using an upright
(nonitalic) font.  This rule, like the rule for  Title s, is
not robust.  Emphasis  nested inside
 strong   Emphasis  won&#39;t be distinguished,
for example, and nestings more than two elements deep will be handled
just as nestings that are two deep.
 Processing subscripts and superscripts Subscript element DSSSL, processing Superscript element DSSSL, processing 

Processing  Subscript  and  Superscript  elements
is really handled by the  super-sub-script  function.
There are several interesting things about this function:
 The  plus-or-minus  argument Scheme language function, passing as argument functions Scheme, passing as argument 

You might ordinarily think of passing a keyword or boolean argument to
the  super-sub-script  function to indicate whether
subscripts or superscripts are desired.  But with Scheme, it&#39;s
possible to pass the actual function as an argument!
 
Note that in the element construction rules for
 Superscript  and  Subscript , we pass the actual
functions  +  and  - . In the body of
 super-sub-script , we use the
 plus-or-minus  argument as a function name (it
appears immediately after an open parenthesis).
 The optional argument optional arguments (DSSSL functions) optional  arguments are indicated by
 #!optional  in the function declaration.  Any number of
 optional  arguments may be given, but each must
specify a default value.  This is accomplished by listing each
argument and default value (an expression) as a pair.
 
In  super-sub-script , the optional argument
 sosofo  is initialized to  process-children .
This means that at the point where the function is
 called ,  process-children  is evaluated and the
resulting  sosofo  is passed to the function.
 Use of inherited characteristics inherited characteristics, calculating new values with 

It is possible to use the  current  value of an inherited
characteristic to calculate a new value.  Using this technique,
superscripts and subscripts will be presented at 80 percent of the
current font size.
 Customizing the Stylesheets DSSSL stylesheets customizing customizing DSSSL stylesheets driver files DSSSL stylsheets, customizing 

The best way to customize the stylesheets is to write your own
 driver  file; this is a stylesheet that contains your
local modifications and then includes the appropriate stylesheet from
the standard distribution by reference.  This allows you to make local
changes and extensions without modifying the distributed files, which
makes upgrading to the next release much simpler.
 Writing Your Own Driver 
A basic driver file looks like this:
 &lt;!DOCTYPE style-sheet PUBLIC &quot;-//James Clark//DTD DSSSL Style Sheet//EN&quot; [
&lt;!ENTITY dbstyle PUBLIC &quot;-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN&quot; CDATA DSSSL&gt;
]&gt;

&lt;style-sheet&gt;
&lt;style-specification use=&quot;docbook&quot;&gt;
&lt;style-specification-body&gt;

;; your changes go here...

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;external-specification id=&quot;docbook&quot; document=&quot;dbstyle&quot;&gt;
&lt;/style-sheet&gt;
 
 public identifiers Modular DocBook Stylesheets Modular DocBook Stylesheets public identifiers 

There are two public identifiers associated with the Modular DocBook
Stylesheets:
 -//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN -//Norman Walsh//DOCUMENT DocBook HTML Stylesheet//EN 
 printing stylesheets 
 HTML stylesheets selecting 
 catalog files Open (SGML) 

The former selects the print stylesheet and the latter selects the
  stylesheet. There is an   Open catalog file in the
distribution that maps these public identifiers to the stylesheet
files. You can add your own definitions, or
redefinitions, of stylesheet rules and parameters so that
 
;; your changes go here...
 
occurs in the previous example.
 driver files example 

For a concrete example of a driver file, see
 plain.dsl  in the
 docbook/print  directory in the stylesheet
distribution (or on the  CD-ROM ).  This is a
customization of the print stylesheet, which turns off title page and
 TOC  generation.
 Changing the Localization DocBook DTD stylesheets languages languages DocBook stylesheets 

As distributed, the stylesheets use English for all generated text,
but other localization files are also provided. The languages supported
at the time of this writing are summarized in
 .
(If you can write a localization for another language,
 please  contribute it.)
 Lang attribute customizing DSSSL stylesheets language, changing 

There are two ways to switch languages: by specifying a  lang  attribute, or by changing the
default language in a customization.
 Using the  lang  attribute DocBook DTD Lang attribute languages codes 

One of the DocBook common attributes is  
lang . If you specify a language, the DocBook stylesheets
will use that language (and all its descendants, if no other language
is specified) for generated text within that element.
  summarizes the language codes for the
supported languages. 
Language codes should conform to  IETF 
 RFC  3066.
 
 French language chapter, example 

The following chapter uses text generated in French:
 
&lt;chapter lang=&quot;fr&quot;&gt;&lt;title&gt;B tises&lt;/title&gt;
&lt;para&gt;Pierre qui roule n&#39;amasse pas de mousse.&lt;/para&gt;
&lt;/chapter&gt;
 
 DocBook Stylesheet Language Codes Language Code Language af Afrikaans ca Catalan cs Czech da Danish de German el Greek en English es Spanish et Estonian eu Basque fi Finnish fr French he Hebrew hu Hungarian id Indonesian it Italian ja Japanese ko Korean nl Dutch nn Nyorsk no Norwegian pl Polish pt Portuguese pt-br Portuguese (Brazil) ro Romanian ru Russian sk Slovak sl Slovenian sv Swedish th Thai tr Turkish uk Ukranian xh Xhosa zh-cn Chinese (Continental) zh-tw Chinese (Traditional) Changing the default language languages default, changing driver files language, changing default 

If no  lang  attribute is
specified, the default language is used. You can change the default
language with a  driver .
 
In the driver, define the default language.  
summarizes the language codes for the supported languages. The
following driver makes German the default language:
 
&lt;!DOCTYPE style-sheet PUBLIC &quot;-//James Clark//DTD DSSSL Style Sheet//EN&quot; [
&lt;!ENTITY dbstyle PUBLIC &quot;-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN&quot; CDATA DSSSL&gt;
]&gt;

&lt;style-sheet&gt;
&lt;style-specification use=&quot;docbook&quot;&gt;
&lt;style-specification-body&gt;

(define %default-language% &quot;dege&quot;)

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;external-specification id=&quot;docbook&quot; document=&quot;dbstyle&quot;&gt;
&lt;/style-sheet&gt;
 
 %gentext-language% 

There are two other settings that can be changed only in a driver. Both
of these settings are turned off in the distributed stylesheet:
 %gentext-language% 
If a language code is specified in
 %gentext-language% , then that language will be used
for all generated text, regardless of any  lang  attribute settings in the
document.
 %gentext-use-xref-language% %gentext-use-xref-language% cross references languages, changing (stylesheets) 

If turned on (defined as  #t ), then the stylesheets
will generate the text associated with a cross reference using the
language of the target, not the current language. Consider the
following book:
 
&lt;book&gt;&lt;title&gt;A Test Book&lt;/title&gt;
&lt;preface&gt;
&lt;para&gt;There are three chapters in this book: &lt;xref linkend=&quot;c1&quot;&gt;, 
&lt;xref linkend=&quot;c2&quot;&gt;, and &lt;xref linkend=&quot;c3&quot;&gt;.
&lt;/para&gt;
&lt;/preface&gt;
&lt;chapter lang=&quot;usen&quot;&gt;&lt;title&gt;English&lt;/title&gt; ... &lt;/chapter&gt;
&lt;chapter lang=&quot;fr&quot;&gt;&lt;title&gt;French&lt;/title&gt; ... &lt;/chapter&gt;
&lt;chapter lang=&quot;dege&quot;&gt;&lt;title&gt;Deutsch&lt;/title&gt; ... &lt;/chapter&gt;
&lt;/book&gt;
 
The standard stylesheets render the Preface as something like this:
 There are three chapters in this book: Chapter 1, Chapter 2, and Chapter
3. 
With  %gentext-use-xref-language%  turned on, it
would render like this:
 There are are three chapters in this book: Chapter 1, Chapitre 2, and
Kapitel 3. A Single Stylesheet for Both Print and  stylesheets HTML and print, using single printing stylesheets HTML stylesheets 

A  DSSSL  stylesheet consists of one or more
 style specifications.  Using more than one style
specification allows you to build a single stylesheet file that can
format with either the print or   backends.    shows a stylesheet with two style
specifications.
 DSSSL stylesheets style specifications, multiple 
 both.dsl : A Stylesheet with Two Style Specifications Jade style specifications, indicating selected 

Once you have stylesheets with more than one style specification, you
have to be able to indicate which style specification you want to
use. In Jade, you indicate this by providing the  ID 
of the style specification after the stylesheet filename, separated
with a hash mark:  # .
 
Using the code from  , you can format a
document using the print stylesheet by running:
 
jade -t rtf -d both.dsl#print file.sgm
 
and using the   stylesheet by running:
 
jade -t sgml -d both.dsl#html file.sgm
 Dealing with Multiple Declarations declarations multiple, using 

The DocBook     and the DocBook  DSSSL 
Stylesheets happen to use the same   declaration. This makes it
very easy to run Jade with DocBook.  However, you may sometimes wish
to use Jade with other document types, for example the DocBook  
 , which has a different declaration. There are a couple of ways
to do this.
 Pass the Declaration Explicitly 

If your stylesheets parse fine with the default declaration, but you
want to use an alternate declaration with a particular document, just
pass the declaration on the command line:
 
jade  options  the-declaration the-document
 
Note that there&#39;s no option required before the declaration; it simply
occurs before the first filename.  Jade concatenates all of the files
that you give it together, and parses them as if they were one
document.
 Use the Catalogs 
The other way to fix this is with a little catalog trickery.
 catalog files multiple declarations, using 

First, note that Jade always looks in the file called
 catalog  in the same directory as the document
that it is loading, and uses settings in that file in preference to
settings in other catalogs.
 
With this fact, we can employ the following trick:
 Put a  catalog  file in the directory that
contains your stylesheets, which contain an
 SGMLDECL  directive.  Jade understands the
directive, which points to the   declaration that you should use
when parsing the stylesheets. For the DocBook stylesheets, the DocBook
declaration works fine. In the directory that contains the document you want to process,
create a  catalog  file that contains an
 SGMLDECL  directive that points to the  
declaration that should be used when parsing the document. 
There&#39;s no easy way to have both the stylesheet and the document in
the same directory if they must be processed with different
declarations.  But this is usually not too inconvenient.
 The  DSSSL  Architecture architecture DSSSL DSSSL architecture attributes DSSSL architecture elements DSSSL architecture and 

The concept of an architecture was promoted by HyTime. In some ways,
it takes the standard  /  notions of the role of elements and
attributes and inverts them. Instead of relying on the name of an
element to assign its primary semantics, it uses the values of a small
set of fixed attributes.
 
While this may be counterintuitive initially, it has an interesting
benefit. An architecture-aware processor can work transparently with
many different  s. A small example will help illustrate this
point.
 The following example demonstrates the concept behind
architectures, but for the sake of simplicity, it does not properly
implement an architecture as defined in HyTime. 
Imagine that you wrote an application that can read an  / 
document containing a letter (conforming to some letter  ), and
automatically print an envelope for the letter. It&#39;s easy to envision
how this works.  The application reads the content of the letter,
extracts the address and return address elements from the source, and
uses them to generate an envelope:
 &lt;?xml version=&#39;1.0&#39;&gt;
&lt;!DOCTYPE letter &quot;/share/sgml/letter/letter.dtd&quot; [
&lt;!ENTITY myaddress &quot;/share/sgml/entities/myaddress.xml&quot;&gt;
]&gt;
&lt;letter&gt;
&lt;returnaddress&gt;&amp;myaddress;&lt;/returnaddress&gt;
&lt;address&gt;
&lt;name&gt;Leonard Muellner&lt;/name&gt;
&lt;company&gt;O&#39;Reilly &amp;amp; Associates&lt;/company&gt;
&lt;street&gt;90 Sherman Street&lt;/street&gt;
&lt;city&gt;Cambridge&lt;/city&gt;&lt;state&gt;MA&lt;/state&gt;&lt;zip&gt;02140&lt;/zip&gt;
&lt;/address&gt;
&lt;body&gt;
&lt;salutation&gt;Hi Lenny&lt;/salutation&gt;
...
&lt;/body&gt; 
The processor extracts the  Returnaddress  and
 Address  elements and their children
and prints the envelope accordingly.
 
Now suppose that a colleague from payroll comes by and asks you to
adapt the application to print envelopes for mailing checks, using the
information in the payroll database, which has a different  . And
a week later, someone from sales comes by and asks if you can modify
the application to use the contact information  . After a while,
you would have 11 versions of this program to maintain.
 fixed attributes 

Suppose that instead of using the actual element names to locate the addresses
in the documents, you asked each person to add a few attributes to their  .
By forcing the attributes to have fixed values, they&#39;d automatically be present
in each document, but authors would never have to worry about them.
 
For example, the address part of the letter   might look like
this:
 
Effectively, each address in a letter would look like this:
 
In practice, the author would not include the  ADDRESS  attributes; they are automatically
provided by the   because they are
 #FIXED . 
The use of uppercase names here is intentional. These are not
attributes that an author is ever expected to type. In  , which is
case-sensitive, using uppercase for things like this reduces the
likelihood of collision with  real  attribute names in the
 .
 
 
Now the address portion of the payroll   might look like this:
 
The employee records will look like this:
 
Your application no longer cares about the actual element names.  It
simply looks for the elements with the correct attributes and uses
them. This is the power of an architecture: it provides a level of
abstraction that processing applications can use to their
advantage. In practice, architectural forms are a bit more complex to
set up because they have facilities for dealing with attribute name
conflicts, among other things.
 
Why have we told you all this? Because  DSSSL  is an
architecture. This means you can modify the stylesheet   and still
run your stylesheets through Jade.
 
Consider the case presented earlier in  .
In order to use this stylesheet, you must specify three things: the
backend you want to use, the stylesheet you want to use, and the
style specification you want to use.  If you mismatch any of the
parameters, you&#39;ll get the wrong results.  In practice, the problem is
compounded further:
 Some stylesheets support several backends
( RTF ,  , and  ).
 backends, stylesheet support 
 stylesheets backends, supporting 

 Some stylesheets support only some backends
( RTF  and  , but not   or
 MIF ). Some stylesheets support multiple outputs using the same
backend (several kinds of   output, for example, using the
  backend:  ,  Help, JavaHelp, and so on). If you have complex stylesheets, some backends may require
additional options to define parameter entities or stylesheet
options. 
None of this complexity is really necessary, after all, the options
don&#39;t change you just have to use the correct combinations. The
mental model is really something like this:  I want a certain
kind of output,   say, so I have to use this combination of
parameters. 
 
You can summarize this information in a table to help keep track of
it:
 Desired Output Backend Style specification Options Supported? rtf rtf print -V rtf-backend yes tex tex print -V tex-backend -i tex yes html sgml htmlweb -i html yes javahelp sgml help -i help yes htmlhelp no 
Putting this information in a table will help you keep track of it,
but it&#39;s not the best solution. The ideal solution is to keep this
information on your system, and let the software figure it all
out. You&#39;d like to be able to run a command, tell it what output you
want from what stylesheet, what file you want to process, and then let
it figure everything else out.  For example:
 
format html mybook.dsl mydoc.sgm
 stylesheets configuration data, storing within configuration data, storing in stylesheet 

One way to do this is to put the configuration data in a separate
file, and have the  format  command load it out of this other
file.  The disadvantage of this solution is that it introduces another
file that you have to maintain and it&#39;s independent from the stylesheet so
it isn&#39;t easy to keep it up-to-date.
 
In the  DSSSL  case, a better alternative is to
modify the stylesheet   so you can store the configuration
data  in the stylesheet . Using this alternate  , your
 mybook.dsl  stylesheets might look like this:
 
In this example, the stylesheet has been annotated with a title, a
list of the public  ID s to which it is applicable,
and a table that provides information about the output formats that it
supports.
 
Using this information, the  format  command can get all the
information it needs to construct the appropriate call to Jade.  To
make  HTML  from  myfile.sgm ,
 format  would run the following:
 
jade -t sgml -d mybook.dsl#htmlweb -i html myfile.sgm
 
The additional information, titles and public  ID s,
can be used as part of a  GUI  interface to simplify
the selection of stylesheets for an author.
 
The complete annotated stylesheet  , and an example of the
 format  command script, are provided on  the  CD-ROM .
 
 
 Stayton Bob 2000 Bob Stayton A Brief Introduction to XSL Using XSL tools to publish DocBook
   documents There is a growing list of tools to process DocBook
   documents using XSL stylesheets. Each tool implements parts
   or all of the XSL standard, which actually has several
   components:
    Extensible Stylesheet Language (XSL) A language for expressing stylesheets written
       in  . It includes the formatting object language, but
       refers to separate documents for the transformation
       language and the path language. XSL Transformation (XSLT) The part of XSL for transforming   documents
       into other   documents, HTML, or text. It can be used to
       rearrange the content and generate new content. XML Path Language (XPath) A language for addressing parts of an  
       document. It is used to find the parts of your document to
       apply different styles to. All XSL processors use this
       component. To publish HTML from your   documents, you just
   need an XSLT engine. To get to print, you need an XSLT
   engine to produce formatting objects (FO), which then must
   be processed with a formatting object processor to produce
   PostScript or PDF output. James Clark&#39;s XT was the first useful XSLT engine,
   and it is still in wide use. It is written in Java, so it
   runs on many platforms, and it is free (
    http://www.jclark.com ).
   XT comes with James Clark&#39;s nonvalidating parser XP, but
   you can substitute a different Java parser. Here is a
   simple example of using XT from the Unix command line to
   produce HTML: You&#39;ll need to alter your
    CLASSPATH  environment variable to
   include the path to where you put the
    .jar  files from the XT
   distribution. CLASSPATH=xt.jar:xp.jar:sax.jar
export CLASSPATH
java  com.jclark.xsl.sax.Driver  filename.xml   docbook/html/docbook.xsl  &gt;  output.html If you replace the HTML stylesheet with a
   formatting object stylesheet, XT will produce a formatting
   object file. Then you can convert that to PDF using FOP, a
   formatting object processor available for free from the
   Apache   Project (
    http://xml.apache.org ).
   Here is an example of that two stage processing: CLASSPATH=xt.jar:xp.jar:sax.jar:fop.jar
export CLASSPATH
java  com.jclark.xsl.sax.Driver  filename.xml   docbook/fo/docbook.xsl  &gt;  output.fo 
java  org.apache.fop.apps.CommandLine  output.fo   output.pdf As of this writing, some other XSLT processors to
   choose from include: 4XSLT, written in Python, from FourThought LLC (
      http://www.fourthought.com ) Sablotron, written in C++, from Ginger Alliance (

      http://www.gingerall.com ) Saxon, written in Java, from Michael Kay (
      http://users.iclway.co.uk/mhkay/saxon ) Xalan, written in Java, from the Apache  
     Project (
      http://xml.apache.org ) XML::XSLT,written in Perl, from Geert Josten and
     Egon Willighagen (
      http://www.cpan.org ) For print output, these additional tools are available for processing formatting objects: XEP (written in Java) from
   RenderX (
   http://www.renderx.com ). PassiveTeX from Sebastian Rahtz ( http://users.ox.ac.uk/~rahtz/passivetex/ ). A brief introduction to XSL XSL is both a transformation language and a
 formatting language. The XSLT transformation part lets you
 scan through a document&#39;s structure and rearrange its
 content any way you like. You can write out the content
 using a different set of   tags, and generate text as
 needed. For example, you can scan through a document to
 locate all headings and then insert a generated table of
 contents at the beginning of the document, at the same time
 writing out the content marked up as HTML. XSL is also a
 rich formatting language, letting you apply typesetting
 controls to all components of your output. With a good
 formatting backend, it is capable of producing high quality
 printed pages. An XSL stylesheet is written using   syntax, and is
 itself a well-formed   document. That makes the basic
 syntax familiar, and enables an   processor to check for
 basic syntax errors. The stylesheet instructions use
 special element names, which typically begin with
  xsl:  to distinguish them from any  
 tags you want to appear in the output. The XSL namespace is
 identified at the top of the stylesheet file. As with other
  , any XSL elements that are not empty will require a
 closing tag. And some XSL elements have specific attributes
 that control their behavior. It helps to keep a good XSL
 reference book handy. Here is an example of a simple XSL stylesheet applied
 to a simple   file to generate HTML output. Simple   file Simple XSL stylesheet HTML output XSL processing model XSL is a template language, not a procedural
language. That means a stylesheet specifies a sample of the
output, not a sequence of programming steps to generate it.
A stylesheet consists of a mixture of output samples with
instructions of what to put in each sample. Each bit of
output sample and instructions is called
a   template . In general, you write a template for each element
type in your document. That lets you concentrate on
handling just one element at a time, and keeps a stylesheet
modular. The power of XSL comes from processing the
templates recursively. That is, each template handles the
processing of its own element, and then calls other
templates to process its children, and so on. Since an  
document is always a single root element at the top level
that contains all of the nested descendent elements, the
XSL templates also start at the top and work their way down
through the hierarchy of elements. Take the
DocBook  &lt;para&gt;  paragraph element as
an example. To convert this to HTML, you want to wrap the
paragraph content with the HTML
tags  p  and  /p .
But a DocBook  &lt;para&gt;   can contain
any number of in-line DocBook elements marking up the text.
Fortunately, you can let other templates take care of those
elements, so your XSL template
for  &lt;para&gt;  can be quite
simple: The  &lt;xsl:template&gt;  element
starts a new template, and
its  match  attribute indicates where to
apply the template, in this case to
any  &lt;para&gt;  elements. The template
says to output a literal  p  string
and then execute
the  &lt;xsl:apply-templates/&gt;  instruction.
This tells the XSL processor to look among all the
templates in the stylesheet for any that should be applied
to the content of the paragraph. If each template in the
stylesheet includes
an  &lt;xsl:apply-templates/&gt;  instruction,
then all descendents will eventually be processed. When it
is through recursively applying templates to the paragraph
content, it outputs the  /p  closing
tag. Context is important Since you aren&#39;t writing a linear procedure to
process your document, the context of where and how to
apply each modular template is important.
The  match  attribute
of  &lt;xsl:template&gt;  provides that
context for most templates. There is an entire expression
language, XPath, for identifying what parts of your
document should be handled by each template. The simplest
context is just an element name, as in the example above.
But you can also specify elements as children of other
elements, elements with certain attribute values, the first
or last elements in a sequence, and so on. Here is how the
DocBook  &lt;formalpara&gt;  element is
handled: There are three templates defined, one for
the  &lt;formalpara&gt;  element itself,
 and one for each of its children elements. The  match  attribute
value  formalpara/title     in the second
template is an XPath expression indicating
a  &lt;title&gt;  element that is an
immediate child of
a  &lt;formalpara&gt;  element. This
distinguishes such titles from
other  &lt;title&gt;  elements used in
DocBook. XPath expressions are the key to controlling how
your templates are applied. In general, the XSL processor has internal rules that
apply templates that are more specific before templates
that are less specific. That lets you control the details,
but also provides a fallback mechanism to a less specific
template when you don&#39;t supply the full context for every
combination of elements. This feature is illustrated by the
third template, for  formalpara/para . By
including this template, the stylesheet processes a  &lt;para&gt;  within  &lt;formalpara&gt;  in
a special way, in this case by not outputting the HTML  &lt;p&gt;  tags already output by its parent. If this template had not been included, then the processor would have fallen back to the template
specified by  match=&quot;para&quot;  described
above, which would have output a second set of  &lt;p&gt;  tags. You can also control template context with
XSL  modes , which are used extensively
in the DocBook stylesheets. Modes let you process the same
input more than once in different ways.
A  mode  attribute in
an  &lt;xsl:template&gt;  definition adds a
specific mode name to that template. When the same mode
name is used
in  &lt;xsl:apply-templates/&gt; , it acts
as a filter to narrow the selection of templates to only
those selected by
the  match  expression  and  that
have that mode name. This lets you define two different
templates for the same element match that are applied under
different contexts. For example, there are two templates
defined for
DocBook  &lt;listitem&gt;   elements: The first template is for the normal list item
context where you want to output the
HTML  &lt;li&gt;  tags. The second template
is called with  &lt;xsl:apply-templates
select=&quot;$target&quot; mode=&quot;xref&quot;/&gt;  in the context
of processing  &lt;xref&gt;  elements. In
this case the  select  attribute locates
the ID of the specific list item and
the  mode  attribute selects the second
template, whose effect is to output its item number when it
is in an ordered list. Because there are many such special
needs when
processing  &lt;xref&gt;  elements, it is
convenient to define a mode name  xref  to
handle them all. Keep in mind that mode settings
do  not  automatically get passed down to
other templates
through  &lt;xsl:apply-templates/&gt; . Programming features Although XSL is template-driven, it also has some
features of traditional programming languages. Here are
some examples from the DocBook stylesheets.  However, you can&#39;t always use these constructs as you
do in other programming languages. Variables in particular
have very different behavior. Using variables and parameters XSL provides two elements that let you assign a value
to a
name:  &lt;xsl:variable&gt;  and  &lt;xsl:param&gt; .
These share the same name space and syntax for assigning
names and values. Both can be referred to using
the  $name  syntax. The main difference
between these two elements is that a param&#39;s value acts as
a default value that can be overridden when a template is
called using
a  &lt;xsl:with-param&gt;  element as in the
last example above. Here are two examples from DocBook: In both elements, the name of the parameter or
variable is specified with
the  name  attribute. So the name of
the  param  here
is  cols  and the name of
the  variable  is  segnum .
The value of either can be supplied in two ways. The value
of the first example is the text node &quot;1&quot; and is supplied
as the content of the element. The value of the second
example is supplied as the result of the expression in
its  select  attribute, and the element
itself has no content. The feature of XSL variables that is odd to new users
is that once you assign a value to a variable, you cannot
assign a new value within the same scope. Doing so will
generate an error. So variables are not used as dynamic
storage bins they way they are in other languages. They
hold a fixed value within their scope of application, and
then disappear when the scope is exited. This feature is a
result of the design of XSL, which is template-driven and
not procedural. This means there is no definite order of
processing, so you can&#39;t rely on the values of changing
variables. To use variables in XSL, you need to understand
how their scope is defined. Variables defined outside of all templates are
considered global variables, and they are readable within
all templates. The value of a global variable is fixed, and
its global value can&#39;t be altered from within any template.
However, a template can create a local variable of the same
name and give it a different value. That local value
remains in effect only within the scope of the local
variable. Variables defined within a template remain in effect
only within their permitted scope, which is defined as all
following siblings and their descendants. To understand
such a scope, you have to remember that XSL instructions
are true   elements that are embedded in an   family
hierarchy of XSL elements, often referred to as parents,
children, siblings, ancestors and descendants. Taking the
family analogy a step further, think of a variable
assignment as a piece of advice that you are allowed to
give to certain family members. You can give your advice
only to your younger siblings (those that follow you) and
their descendents. Your older siblings won&#39;t listen,
neither will your parents or any of your ancestors. To
stretch the analogy a bit, it is an error to try to give
different advice under the same name to the same group of
listeners (in other words, to redefine the variable). Keep
in mind that this family is not the elements of your
document, but just the XSL instructions in your stylesheet.
To help you keep track of such scopes in hand-written
stylesheets, it helps to indent nested XSL elements. Here
is an edited snippet from the DocBook stylesheet
file  pi.xsl  that illustrates different
scopes for two variables: The scope of the variable  pi  begins
on line 8 where it is defined in this template, and ends on
line 20 when its last sibling ends. Technically, the scope extends to the end tag of the parent of the  &lt;xsl:variable&gt;  element. That is effectively the last sibling.      The scope of the
variable  rest  begins on line 13 and ends
on line 15. Fortunately, line 15 outputs an expression
using the value before it goes out of scope. What happens when
an  &lt;xsl:apply-templates/&gt;  element
is used within the scope of a local variable? Do the
templates that are applied to the document children get the
variable? The answer is no. The templates that are applied
are not actually within the scope of the variable. They
exist elsewhere in the stylesheet and are not following
siblings or their descendants.  To pass a value to another template, you pass a
parameter using
the  &lt;xsl:with-param&gt;  element. This
parameter passing is usually done with calls to a specific
named template
using  &lt;xsl:call-template&gt; , although
it works
with  &lt;xsl:apply-templates&gt;  too.
That&#39;s because the called template must be expecting the
parameter by defining it using
a  &lt;xsl:param&gt;  element with the same
parameter name. Any passed parameters whose names are not
defined in the called template are ignored. Here is an example of parameter passing
from  docbook.xsl : Here a template
named  head.content  is being called and
passed a parameter named  node  whose
content is the value of the  $doc  variable
in the current context. The top of that template looks like
this: The template is expecting the parameter because it
has a  &lt;xsl:param&gt;  defined with the
same name. The value in this definition is the default
value. This would be the parameter value used in the
template if the template was called without passing that
parameter. Generating HTML output. You generate HTML from your DocBook   files by
applying the HTML version of the stylesheets. This is done
by using the HTML driver
file  docbook/html/docbook.xsl  as your
stylesheet. That is the master stylesheet file that
uses  &lt;xsl:include&gt;  to pull in the
component files it needs to assemble a complete stylesheet
for producing HTML.  The way the DocBook stylesheet generates HTML is to
apply templates that output a mix of text content and HTML
elements. Starting at the top level in the main
file  docbook.xsl : This template matches the root element of your input
document, and starts the process of recursively applying
templates. It first defines a variable
named  doc  and then outputs two literal
HTML elements  &lt;html&gt;  and  &lt;head&gt; .
Then it calls a named
template  head.content  to process the
content of the HTML  &lt;head&gt; , closes
the  &lt;head&gt;  and starts
the  &lt;body&gt; . There it
uses  &lt;xsl:apply-templates/&gt;  to
recursively process the entire input document. Then it just
closes out the HTML file. Simple HTML elements can generated as literal
elements as shown here. But if the HTML being output
depends on the context, you need something more powerful to
select the element name and possibly add attributes and
their values. Here is a fragment
from  sections.xsl  that shows how a
heading tag is generated using
the  &lt;xsl:element&gt;  and  &lt;xsl:attribute&gt;  elements: This whole example is generating a single HTML
heading element. Line 1 begins the HTML element definition
by identifying the name of the element. In this case, the
name is an expression that includes the
variable  $level  passed as a parameter to
this template. Thus a single template can
generate  &lt;h1&gt; ,  &lt;h2&gt; ,
etc. depending on the context in which it is called. Line 2
defines a  class=&quot;title&quot;  attribute that is
added to this element. Lines 3 to 5 add
a  style=&quot;clear all&quot;  attribute, but only
if the heading level is less than 3. Line 6 opens
an  &lt;a&gt;  anchor element. Although this
looks like a literal output string, it is actually modified
by lines 7 to 9 that insert
the  name  attribute into
the  &lt;a&gt;  element. This illustrates
that XSL is managing output elements as active element
nodes, not just text strings. Line 10 outputs the text of
the heading title, also passed as a parameter to the
template, enclosed in HTML boldface tags. Line 11 closes
the anchor tag with the
literal  /a  syntax, while line 12
closes the heading tag by closing the element definition.
Since the actual element name is a variable, it couldn&#39;t
use the literal syntax. As you follow the sequence of nested templates
processing elements, you might be wondering how the
ordinary text of your input document gets to the output. In
the file  docbook.xsl  you will find
this template that handles any text not processed by any
other template: This template&#39;s body consists of the &quot;value&quot; of the text node,
which is just its text. In general, all XSL processors have
some built-in templates to handle any content for which
your stylesheet doesn&#39;t supply a matching template. This
template serves the same function but appears explicitly in
the stylesheet. Generating formatting objects. You generate formatting objects from your DocBook  
files by applying the fo version of the stylesheets. This
is done by using the fo driver
file  docbook/fo/docbook.xsl  as your
stylesheet. That is the master stylesheet file that
uses  &lt;xsl:include&gt;  to pull in the
component files it needs to assemble a complete stylesheet
for producing formatting objects. Generating a formatting
objects file is only half the process of producing typeset
output. You also need a formatting object processor such as
the Apache   Project&#39;s FOP as described in an earlier
section. The DocBook fo stylesheet works in a similar manner
to the HTML stylesheet. Instead of outputting HTML tags, it
outputs text marked up
with  &lt;fo: something &gt;  tags.
For example, to indicate that some text should be kept
in-line and typeset with a monospace font, it might look
like this: The templates
in  docbook/fo/inline.xsl       that produce
this output for a
DocBook    &lt;filename&gt;      element look
like this: There are dozens of fo tags and attributes specified
in the XSL standard. It is beyond the scope of this
document to cover how all of them are used in the DocBook
stylesheets. Fortunately, this is only an intermediate
format that you probably won&#39;t have to deal with very much
directly unless you are writing your own
stylesheets. Customizing DocBook XSL stylesheets The DocBook XSL stylesheets are written in a modular
fashion. Each of the HTML and FO stylesheets starts with a
driver file that assembles a collection of component files
into a complete stylesheet. This modular design puts similar things together into smaller files that are easier to write and maintain than one big stylesheet. The modular stylesheet files
are distributed among four directories: common/ contains code common to both stylesheets, including localization data
 fo/ a stylesheet that produces XSL FO result trees
 html/ a stylesheet that produces HTML/XHTML result trees
 lib/ contains schema-independent functions
 The driver files for each of HTML and FO stylesheets
are  html/docbook.xsl  and  fo/docbook.xsl ,
respectively. A driver file consists mostly of a bunch
of  &lt;xsl:include&gt;  instructions to
pull in the component templates, and then defines some
top-level templates. For example: The first four modules are shared with the FO
stylesheet and are referenced using relative pathnames to
the common directories. Then the long list of component
stylesheets starts. Pathnames in include statements are
always taken to be relative to the including file. Each
included file must be a valid XSL stylesheet, which means
its root element must
be  &lt;xsl:stylesheet&gt; . Stylesheet inclusion vs. importing XSL actually provides two inclusion
mechanisms:  &lt;xsl:include&gt;  and  &lt;xsl:import&gt; .
Of the two,  &lt;xsl:include&gt;  is
the simpler. It treats the included content as if it were
actually typed into the file at that point, and doesn&#39;t
give it any more or less precedence relative to the
surrounding text. It is best used when assembling
dissimilar templates that don&#39;t overlap what they match.
The DocBook driver files use this instruction to assemble a
set of modules into a stylesheet. In contrast,  &lt;xsl:import&gt;  lets
you manage the precedence of templates and variables. It is
the preferred mode of customizing another stylesheet because
it lets you override definitions in the distributed
stylesheet with your own, without altering the distribution
files at all. You simply import the whole stylesheet and
add whatever changes you want. The precedence rules for import are detailed and
rigorously defined in the XSL standard. The basic rule is
that any templates and variables in the importing
stylesheet have precedence over equivalent templates and
variables in the imported stylesheet. Think of the imported stylesheet elements as a fallback collection, to be used only if a match is not found in the current stylesheet. You can customize the templates you want to change in your stylesheet file, and let the imported stylesheet handle the rest. Customizing a DocBook XSL stylesheet is the opposite
of customizing a DocBook DTD. When you customize a DocBook
DTD, the rules of   and   dictate that
the  first  of any duplicate declarations
wins. Any subsequent declarations of the same element or
entity are ignored. The architecture of the DTD provides
slots for inserting your own custom declarations early
enough in the DTD for them to override the standard
declarations. In contrast, customizing an XSL stylesheet is
simpler because your definitions have precedence over imported ones. You can carry modularization to deeper levels because
module files can also include or import other modules.
You&#39;ll need to be careful to maintain the precedence that
you want as the modules get rolled up into a complete
stylesheet.  Customizing
with  &lt;xsl:import&gt; There is currently one example of customizing
with  &lt;xsl:import&gt;  in the HTML
version of the DocBook stylesheets.
The  xtchunk.xsl  stylesheet modifies the
HTML processing to output many smaller HTML files rather
than a single large file per input document. It uses XSL
extensions defined only in the XSL
processor  XT . In the driver
file  xtchunk.xsl , the first instruction
is  &lt;xsl:import
href=&quot;docbook.xsl&quot;/&gt; . That instruction imports
the original driver file, which in turn uses
many  &lt;xsl:include&gt;  instructions to
include all the modules. That single import instruction
gives the new stylesheet the complete set of DocBook
templates to start with. After the
import,  xtchunk.xsl  redefines some of
the templates and adds some new ones. Here is one example
of a redefined template: The new template handles the more complex processing
of HREFs when the output is split into many HTML files.
Where the old template could simply
output  # object.id ,
the new one outputs  filename # object.id . Setting stylesheet variables You may not have to define any new templates,
however. The DocBook stylesheets are parameterized using
XSL variables rather than hard-coded values for many of the
formatting features. Since
the  &lt;xsl:import&gt;  mechanism also
lets you redefine global variables, this gives you an easy
way to customize many features of the DocBook
stylesheets. Over time, more features will be parameterized to permit customization. If you find hardcoded values in the stylesheets that would be useful to customize, please let the maintainer know. Near the end of the list of includes in the main
DocBook driver file is the
instruction  &lt;xsl:include
href=&quot;param.xsl&quot;/&gt; .
The  param.xsl  file is the most
important module for customizing a DocBook XSL stylesheet.
This module contains no templates, only definitions of
stylesheet variables. Since these variables are defined
outside of any template, they are global variables and
apply to the entire stylesheet. By redefining these
variables in an importing stylesheet, you can change the
behavior of the stylesheet. To create a customized DocBook stylesheet, you simply
create a new stylesheet file such
as  mystyle.xsl  that imports the standard
stylesheet and adds your own new variable definitions. Here
is an example of a complete custom stylesheet that changes
the depth of sections listed in the table of contents from
two to three: Following the opening stylesheet element are the
import instruction and one variable definition. The
variable  toc.section.depth  was defined
in  param.xsl  with value &quot;2&quot;, and here
it is defined as &quot;3&quot;. Since the importing stylesheet takes
precedence, this new value is used. Thus documents
processed with  mystyle.xsl  instead
of  docbook.xsl  will have three levels
of sections in the tables of contents, and all other
processing will be the same. Use the list of variables
in  param.xsl  as your guide for creating
a custom stylesheet. If the changes you want are controlled
by a variable there, then customizing is easy.  Writing your own templates If the changes you want are more extensive than what
is supported by variables, you can write new templates. You
can put your new templates directly in your importing
stylesheet, or you can modularize your importing stylesheet
as well. You can write your own stylesheet module
containing a collection of templates for processing lists,
for example, and put them in a file
named  mylists.xsl . Then your importing
stylesheet can pull in your list templates with
a  &lt;xsl:include
href=&quot;mylists.xsl&quot;/&gt;  instruction. Since your
included template definitions appear after the main import
instruction, your templates will take precedence. You&#39;ll need to make sure your new templates are
compatible with the remaining modules, which means: Any named templates should use the same name so
calling templates in other modules can find them. Your template set should process the same elements
matched by templates in the original module, to ensure
complete coverage. Include the same set
of  &lt;xsl:param&gt;  elements in each
template to interface properly with any calling templates,
although you can set different values for your
parameters. Any templates that are used like subroutines to
return a value should return the same data type. Writing your own driver Another approach to customizing the stylesheets is to
write your own driver file. Instead of
using  &lt;xsl:import
href=&quot;docbook.xsl&quot;/&gt; , you copy that file to a
new name and rewrite any of
the  &lt;xsl:include/&gt;  instructions to
assemble a custom collection of stylesheet modules. One
reason to do this is to speed up processing by reducing the
size of the stylesheet. If you are using a customized
DocBook DTD that omits many elements you never use, you
might be able to omit those modules of the
stylesheet. Localization The DocBook stylesheets include features for
localizing generated text, that is, printing any generated
text in a language other than the default English. In
general, the stylesheets will switch to the language
identified by a  lang  attribute when
processing elements in your documents. If your documents
use the  lang  attribute, then you don&#39;t
need to customize the stylesheets at all for
localization. As far as the stylesheets go,
a  lang  attribute is inherited by the
descendents of a document element. The stylesheet searches
for a  lang  attribute using this XPath
expression: This locates the attribute on the current element or
its most recent ancestor. Thus
a  lang  attribute is in effect for an
element and all of its descendents, unless it is reset in
one of those descendents. If you define it in only your
document root element, then it applies to the whole
document: When text is being generated, the stylesheet checks
the most recent  lang  attribute and looks
up the generated text strings for that language in a
localization   file. These are located in
the  common  directory of the
stylesheets, one file per language. Here is the top of the
file  fr.xml : The stylesheet templates use the gentext key names,
and then the stylesheet looks up the associated text value
when the document is processed with that lang setting. The
file  l10n.xml  (note
the  .xml  suffix) lists the filenames of
all the supported languages. You can also create a custom stylesheet that sets the
language. That might be useful if your documents don&#39;t make
appropriate use of the  lang  attribute.
The module  l10n.xsl  defines two global
variables that can be overridden with an importing
stylesheet as described above. Here are their default
definitions: The first one sets the language for all elements,
regardless of an element&#39;s  lang  attribute
value. The second just sets a default language for any
elements that haven&#39;t got a  lang  setting
of their own (or their ancestors). 

 
 $Date: 2009-01-05 12:25:13 +0300 (Пн, 05 янв 2009) $ $Revision: 8201 $ Customizing DocBook customizing DocBook DTD DocBook DTD customizing 

For the applications you have in mind, DocBook  out of the
box  may not be exactly what you need. Perhaps you need
additional inline elements or perhaps you want to remove elements that
you never want your authors to use. By design, DocBook makes this sort
of customization easy.
 attributes DocBook DTD, customizing elements DocBook DTD, customizing 

This chapter explains how to make your own  customization
layer . You might do this in order to:
 Add new elements Remove elements Change the structure of existing elements Add new attributes Remove attributes Broaden the range of values allowed in an attribute Narrow the range of values in an attribute to a specific list or a fixed value 
 extensions, DocBook DTD environment DocBook extensions, affecting 

You can use customization layers to extend DocBook or subset
it. Creating a   that is a strict subset of DocBook means that all
of your instances are still completely valid DocBook instances, which
may be important to your tools and stylesheets, and to other people
with whom you share documents.  An  extension  adds new
structures, or changes the   in a way that is not compatible with
DocBook. Extensions can be very useful, but might have a great impact
on your environment.
 
Customization layers can be as small as restricting an attribute value
or as large as adding an entirely different hierarchy on top of the
inline elements.
 Should You Do This? stylesheets DTD extension, effects 

Changing a   can have a wide-ranging impact on the tools and
stylesheets that you use. It can have an impact on your authors and on
your legacy documents.  This is especially true if you make an
extension. If you rely on your support staff to install and maintain
your authoring and publishing tools, check with them before you invest
a lot of time modifying the  . There may be additional issues that
are outside your immediate control. Proceed with caution.
 
That said, DocBook is designed to be easy to modify. This chapter
assumes that you are comfortable with  /    syntax, but
the examples presented should be a good springboard to learning the
syntax if it&#39;s not already familiar to you.
 If You Change DocBook, It&#39;s Not DocBook Anymore! public identifiers DocBook DTD altering The DocBook   is usually referenced by its public identifier:
   -//OASIS//DTD DocBook V3.1//EN 
Previous versions of DocBook, V3.0 and the V2 variants, used the owner
identifier Davenport, rather than OASIS.
 
If you make any changes to the structure of the  , it is
imperative that you alter the public identifier that you use for the
  and the modules you changed.  The license agreement under which
DocBook is distributed gives you complete freedom to change, modify,
reuse, and generally hack the   in any way you want, except that
you must not call your alterations  DocBook. 
 owner-identifiers changing (DocBook customization) description, changing (DocBook customization) 

You should change both the owner identifier and the description. The
original DocBook formal public identifiers use the following syntax:
 
-//OASIS// text-class  DocBook  description  V version //EN
 
 
Your own formal public identifiers should use the following syntax in
order to record their DocBook derivation:
 
-// your-owner-ID // text-class  DocBook V version -Based  Subset|Extension|Variant   your-descrip-and-version // lang 
 
 For example:
 
-//O&#39;Reilly//DTD DocBook V3.0-Based Subset V1.1//EN
 
 subsets (DocBook DTD) 
If your   is a proper subset, you can advertise this status by
using the  Subset  keyword in the description. If
your   contains any markup model extensions, you can advertise
this status by using the  Extension  keyword. If
you&#39;d rather not characterize your variant specifically as a subset or
an extension, you can leave out this field entirely, or, if you
prefer, use the  Variant  keyword.
 dbgenent.mod file public identifiers dbgenent.mod file, changing 

There is only one file that you may change without changing the public
identifier:  dbgenent.mod . And you can add only
entity and notation declarations to that file. (You can add anything
you want, naturally, but if you add anything other than entity and
notation declarations, you must change the public identifier!)
 Customization Layers customizing DocBook DTD customization layers layers, customization (DocBook DTD) parameter entities customization layers declarations SGML and XML DTDs 

  and    s are really just collections of
declarations. These declarations are stored in one or more files. A
complete   is formed by combining these files together
logically. Parameter entities are used for this purpose. Consider the
following fragment:
 
&lt;!ENTITY % dbpool SYSTEM &quot;dbpool.mod&quot;&gt;  
&lt;!ENTITY % dbhier SYSTEM &quot;dbhier.mod&quot;&gt;  
%dbpool;                                
%dbhier;                                
 This line declares the
parameter entity  dbpool  and associates it with the
file   dbpool.mod . This line declares the
parameter entity  dbhier  and associates it with the
file   dbhier.mod . This line references  
dbpool , which loads the file  dbpool.mod 
and inserts its content here. Similarly, this line loads
  dbhier.mod . parsing DTDs, entity declarations (repeated) 

It is an important feature of   parsing that entity
declarations can be repeated. If an entity is declared more than once,
then the   first  declaration is used. Given this
fragment:
 
&lt;!ENTITY foo &quot;Lenny&quot;&gt;
&lt;!ENTITY foo &quot;Norm&quot;&gt;
 
The replacement text for  foo  is
 Lenny. 
 modules DTDs, customizing parameter entities DTD modules, referencing 

These two notions, that you can break a   into modules referenced
with parameter entities and that the first entity declaration is the
one that counts, are used to build  customization layers. 
With customization layers you can write a   that references some
or all of DocBook, but adds your own modifications. Modifying the
  this way means that you never have to edit the DocBook modules
directly, which is a tremendous boon to maintaining your modules. When
the next release of DocBook comes out, you usually only have to make
changes to your customization layer and your modification will be back
in sync with the new version.
 
Customization layers work particularly well in DocBook because the
base   makes extensive use of parameter entities that can be
redefined.
 Understanding DocBook Structure 
DocBook is a large and, at first glance, fairly complex  . Much of
the apparent complexity is caused by the prolific use of parameter
entities.  This was an intentional choice on the part of the
maintainers, who traded  raw readability  for customizability.
This section provides a general overview of the structure of the
 . After you understand it, DocBook will probably seem much less
complicated.
 DocBook Modules modules DocBook DocBook DTD modules 

DocBook is composed of seven primary modules. These modules decompose
the   into large, related chunks. Most modifications are
restricted to a single chunk.
  shows the module structure of
DocBook as a flowchart.
 Structure of the DocBook  
The modules are:
 docbook.dtd driver files 

The main driver file. This module declares and references the
other top-level modules.
 dbhier.mod dbhier.mod file hierarchical structure DocBook DTD 

The hierarchy. This module declares the elements that provide
the hierarchical structure of DocBook (sets, books, chapters,
articles, and so on).
 Changes to this module alter the top-level structure of the
 . If you want to write a DocBook-derived   with a different
structure (something other than a book), but with the same paragraph
and inline-level elements, you make most of your changes in this
module.
 dbpool.mod dbpool.mod file elements dbpool.mod file, declaring inline elements changing (dbpool.mod file) 

The information pool. This module declares the elements that
describe content (inline elements, bibliographic data, block quotes,
sidebars, and so on) but are not part of the large-scale hierarchy of
a document. You can incorporate these elements into an entirely
different element hierarchy.
 The most common reason for changing this module is to add or
remove inline elements.
 dbnotn.mod dbnotn.mod file notation declarations (DocBook) 

The notation declarations. This module declares the notations
used by DocBook.
 This module can be changed to add or remove notations.
 dbcent.mod dbcent.mod file characters entities declaration entities characters declaration declarations entities entity sets 

The character entities. This module declares and references the
 ISO  entity sets used by DocBook.
 Changes to this module can add or remove entity sets.
 dbgenent.mod dbgenent.mod file entities general customizing DocBook DTD general entities, customizing customizing DocBook DTD general entities general entities customizing 

The general entities. This is a place where you can customize
the general entities available in DocBook instances.
 This is the place to add, for example, boiler plate text, logos
for institutional identity, or additional notations understood by your
local processing system.
 cals-tbl.dtd cals-tbl.dtd file CALS; Table Model. CALS table models 

The   Table Model.   is an initiative by the United
States Department of Defense to standardize the document types used
across branches of the military. The   table model, published in
 MIL-HDBK-28001 , was for a long time the most widely
supported   table model (one might now argue that the  
table model is more widely supported by some definitions of
 widely supported ). In any event, it is the table model
used by DocBook.
 OASIS table model DocBook DTD table model 

DocBook predates the publication of the  OASIS  Technical Resolution  TR 
9503:1995 , which defines an industry standard exchange table
model and thus incorporates the  full    Table
Model.
 parameter entities table model (CALS), modifying 

Most changes to the   table model can be accomplished by
modifying parameter entities in  dbpool.mod ;
changing this   fragment is strongly discouraged. If you want to
use a different table model, remove this one and add your own.
 *.gml *.gml (ISO standard character entity sets) ISO standards entity sets characters 
The  ISO  standard character entity sets.
These entity sets are not actually part of the official DocBook
distribution, but are referenced by default.
 
There are some additional modules, initially undefined, that can be
inserted at several places for  redeclaration.  This is
described in more detail in  .
 DocBook Parameterization parameter entities customization layers 

Customization layers are possible because DocBook has been extensively
parameterized so that it is possible to make any changes that might be
desired without ever editing the actual distributed modules. The
parameter entities come in several flavors:
 *.class *.class parameter entities classes elements 

Classes group elements of a similar type: for example all the
lists are in the  list.class .
 If you want to add a new kind of something (a new kind of list
or a new kind of verbatim environment, for example), you generally
want to add the name of the new element to the appropriate class.
 *.mix .mix parameter entities classes mixtures 

Mixtures are collections of classes that appear in content
models. For example, the content model of the
 Example  element includes  example.mix . Not every element&#39;s content
model is a single mixture, but elements in the same class tend to have
the same mixture in their content model.
 If you want to change the content model of some class of
elements (lists or admonitions, perhaps), you generally want to change
the definition of the appropriate mixture.
 *.module parameter entities *.module *.module parameter entities marked sections parameter entities, controlling 

The  *.module  parameter
entities control  marked sections  around
individual elements and their attribute lists.  For example, the
element and attribute declarations for  Abbrev  occur
within a marked section delimited by  abbrev.module .
 
If you want to remove or redefine an element or its attribute
list, you generally want to change its module marked section to
 IGNORE  and possibly add a new definition for it in
your customization layer.
 *.element *.element parameter entities parameter entities *.element 
The  *.element  parameter
entities were introduced in DocBook  V3.1 ; they
control marked sections around individual element declarations.
 *.attlist parameter entities *.attlist *.attlist parameter entities attributes parameter entities, controlling 

The  *.attlist  parameter
entities were introduced in DocBook  V3.1 ; they
control marked sections around individual attribute list declarations.
 *.inclusion *.exclusion elements declarations parameter entities, controlling parameter entities *.inclusion parameter entities *.exclusion *.inclusion parameter entities *.exclusion parameter entities 

These parameter entities control the inclusion and exclusion
markup in element declarations.
 Changing these declarations allows you to make global changes to
the inclusions and exclusions in the  .
 local.* local parameter entities 

The  local.*  parameter
entities are a local extension mechanism.  You can add markup to most
entity declarations simply by declaring the appropriate local
parameter entity.
 The General Structure of Customization Layers customizing DocBook DTD structure (customization layers) 
Although customization layers vary in complexity, most of them 
have the same general structure as other customization layers of
similar complexity.
 
In the most common case, you probably want to include the entire  , but you
want to make some small changes.  These customization layers tend
to look like this:
 Overrides of Entity Declarations Here 

 &lt;!ENTITY % orig-docbook &quot;-//OASIS//DTD DocBook V3.1//EN&quot;&gt;
 %orig-docbook;

  New/Modified Element and Attribute Declarations Here 
 
Declare new values for parameter entities
( local.* ,
 *.element , 
 *.attlist )
that you wish to modify.
 
Include the entire DocBook   by parameter entity reference.
 parameter entities DocBook DTD, including by reference 

 
Add new element and attribute declarations for any elements that you
added to the  .
 elements declarations adding for new 
 attributes declarations adding for new 
 modules DocBook customization 

In slightly more complex customization layers, the changes that you
want to make are influenced by the interactions between modules. In
these cases, rather than including the whole   at once, you
include each of the modules separately, perhaps with entity or element
declarations between them:
 Overrides of Most Entity Declarations Here 

&lt;!ENTITY % orig-pool &quot;-//OASIS//ELEMENTS DocBook Information Pool V3.1//EN&quot;&gt;
%orig-pool;

 Overrides of Document Hierarchy Entities Here 

&lt;!ENTITY % orig-hier &quot;-//OASIS//ELEMENTS DocBook Document Hierarchy V3.1//EN&quot;&gt;
%orig-hier;

 New/Modified Element and Attribute Declarations Here 

&lt;!ENTITY % orig-notn &quot;-//OASIS//ENTITIES DocBook Notations V3.1//EN&quot;&gt;
%orig-notn;

&lt;!ENTITY % orig-cent &quot;-//OASIS//ENTITIES DocBook Character Entities V3.1//EN&quot;&gt;
%orig-cent;

&lt;!ENTITY % orig-gen  &quot;-//OASIS//ENTITIES DocBook Additional General Entities V3.1//EN&quot;&gt;
%orig-gen;
 one-off customizations 

Finally, it&#39;s worth noting that in the rare case in which you
need certain kinds of very simple,  one-off 
customizations, you can do them in the document subset:
 
&lt;!DOCTYPE book PUBLIC &quot;-//OASIS//DTD DocBook V3.1//EN&quot; [
 Overrides of Entity Declarations Here 
 New/Modified Element and Attribute Declarations Here 
]&gt;
&lt;book&gt;...&lt;/book&gt;
 Writing, Testing, and Using a Customization Layer DocBook DTD customizing customization layers, writing, testing, and using customizing DocBook DTD writing, testing and using customization layers 
The procedure for creating, testing, and using a customization layer
is always about the same. In this section, we&#39;ll go through the
process in some detail. The rest of the sections in this chapter
describe a range of useful customization layers.
 Deciding What to Change 
If you&#39;re considering writing a customization layer, there must be
something that you want to change. Perhaps you want to add an element
or attribute, remove one, or change some other aspect of the  .
 inline elements adding 

Adding an element, particularly an inline element, is one possibility.
If you&#39;re writing documentation about an object-oriented system, you
may have noticed that DocBook provides  ClassName  but not
 MethodName . Suppose you want to add
 MethodName ?
 Deciding How to Change a Customization Layer customizing DocBook DTD changing customization layers 
Figuring out what to change may be the hardest part of the process.
The organization of the parameter entities is quite logical, and,
bearing in mind the organization described in  , finding something similar usually
provides a good model for new changes.
 parameter entities reference (online) 

Two online resources may be useful. First, the 
 parameter entity reference section  of the
online book provides more detail than the print version. Second, there
is an alternate version of the book online that shows all of the element
content models in terms of the parameter entities that define them, 
rather than the  flattened  versions shown here.
 elements content models (online reference) 
One resource that may be useful is the alternate version of this
book that shows all of the element content models in
terms of the parameter entities which define them, rather than
the  flattened  versions shown here. The alternate version
is on the  CD-ROM  and online at the book web site:
 http://docbook.org/ .
 MethodName  is similar to  ClassName , so
 ClassName  is probably a good model.   ClassName 
is an inline element, not a hierarchy element, so it&#39;s in
 dbpool.mod . Searching for  classname  in
 dbpool.mod  reveals:
 
&lt;!ENTITY % local.tech.char.class &quot;&quot;&gt;
&lt;!ENTITY % tech.char.class
        &quot;Action|Application| ClassName |Command|ComputerOutput
        |Database|Email|EnVar|ErrorCode|ErrorName|ErrorType|Filename
        |Function|GUIButton|GUIIcon|GUILabel|GUIMenu|GUIMenuItem
        |GUISubmenu|Hardware|Interface|InterfaceDefinition|KeyCap
        |KeyCode|KeyCombo|KeySym|Literal|Constant|Markup|MediaLabel
        |MenuChoice|MouseButton|MsgText|Option|Optional|Parameter
        |Prompt|Property|Replaceable|ReturnValue|SGMLTag|StructField
        |StructName|Symbol|SystemItem|Token|Type|UserInput|VarName
        %local.tech.char.class;&quot;&gt;
 
Searching further reveals the element and attribute declarations for
 ClassName .
 local.tech.char.class parameter entity tech.char.class parameter entity 
It would seem (and, in fact, it is the case) that adding
 MethodName  can be accomplished by adding it to the local
extension mechanism for  tech.char.class , namely  local.tech.char.class , and adding element and
attribute declarations for it. A customization layer that does this
can be seen in  .
 MethodName, adding with customization layer 

 Adding MethodName with a Customization Layer Declare the appropriate
parameter entity (these are described in  ).
The declaration in your customization layer is encountered first, so
it overrides the definition in the DocBook   (all the local
classes are defined as empty in the  ). Use a parameter entity to
load the entire DocBook  . Add an element declaration
for the new element. The content model for this element is taken
directly from the content model of  ClassName . Add an attribute list
declaration for the new element. These are the same attributes as
 ClassName .
 Using Your Customization Layer customizing DocBook DTD writing, testing, and using customization layers DocBook DTD customizing using customization layer 

In order to use the new customization layer, you must save it in a
file, for example  mydocbk.dtd , and then you must use the
new   in your document.
 
The simplest way to use the new   is to point to it with a system
identifier:
 Java Math class 
 absolute value (numbers), computing 
 
&lt;!DOCTYPE chapter SYSTEM &quot;/path/to/mydocbk.dtd&quot;&gt;
&lt;chapter&gt;&lt;title&gt;My Chapter&lt;/title&gt;
&lt;para&gt;
The Java &lt;classname&gt;Math&lt;/classname&gt; class provides a 
&lt;methodname&gt;abs&lt;/methodname&gt; method to compute absolute value of a number.
&lt;/para&gt;
&lt;/chapter&gt;

 public identifiers DocBook DTD customization layer 
If you plan to use your customization layer in many documents, or
exchange it with interchange partners, consider giving your   its
own public identifier, as described in  
 catalog files public identifier, adding 

In order to use the new public identifier, you must add it to your
catalog:
 
PUBLIC &quot;-//Your Organization//DTD DocBook V3.1-Based Extension V1.0//EN&quot;
       &quot;/share/sgml/mydocbk.dtd&quot;
 
and use that public identifier in your documents:
 
&lt;!DOCTYPE chapter 
  PUBLIC &quot;-//Your Organization//DTD DocBook V3.1-Based Extension V1.0//EN&quot;&gt;
&lt;chapter&gt;&lt;title&gt;My Chapter&lt;/title&gt;
&lt;para&gt;
The Java &lt;classname&gt;Math&lt;/classname&gt; class provides a 
&lt;methodname&gt;abs&lt;/methodname&gt; method to compute absolute value of a number.
&lt;/para&gt;
&lt;/chapter&gt;

 XML system identifiers URI requirements URI XML system identifiers 
If you&#39;re using  , remember that you must provide a system
identifier that satisfies the requirements of a Uniform Resource
Identifier ( URI ).
 Testing Your Work customizing DocBook DTD writing, testing, and using customization layers testing customization layers (DocBook DTD) validation customization layers 

 s, by their nature, contain many complex, interrelated elements.
Whenever you make a change to the  , it&#39;s always wise to use a
validating parser to double-check your work. A parser like
 nsgmls  from James Clark&#39;s
 SP  can identify elements
(attributes, parameter entities) that are declared but unused, as well
as ones that are used but undeclared.
 

A comprehensive test can be accomplished with
 nsgmls  using the  -wall 
option. Create a simple test document and run:
 
nsgmls  -sv  -wall test.sgm
 suppressing output (parser) versions nsgmls parser, printing number 

The  -s  option
tells  nsgmls  to suppress its normal output (it will
still show errors, if there are any). The  -v  option
tells  nsgmls  to print its version number; this
ensures that you always get  some  output, even if
there are no errors. errors listing, comprehensive warnings, listing nsgmls parser warning types 

The  -wall 
option tells  nsgmls  to provide a comprehensive list
of all errors and warnings.  You can use less verbose, and more
specific options instead; for example,  -wundefined  to
flag undefined elements or  -wunused-param  to warn you
about unused parameter entities. The  nsgmls 
documentation provides a complete list of warning types. DocBook  V3.1  Warnings DocBook DTD warnings 
If you run the preceding command over DocBook  V3.1 ,
you&#39;ll discover one warning generated by the  :
 
nsgmls:I: SP version &quot;1.3&quot;
nsgmls:cals-tbl.dtd:314:37:W: content model is mixed but does not allow #PCDATA everywhere
 Entry element 

This is not truly an error in the  , and can safely be ignored.
The warning is caused by  pernicious mixed content  in
the content model of DocBook&#39;s  Entry  element.  See
the  Entry  reference page for a complete discussion.
 Removing Elements elements removing 

DocBook has a large number of elements. In some authoring
environments, it may be useful or necessary to remove some of these
elements.
 Removing MsgSet MsgSet element removing MsgSet  is a favorite target. It has a complex
internal structure designed for describing interrelated error
messages, especially on systems that may exhibit messages from several
different components. Many technical documents can do without it, and
removing it leaves one less complexity to explain to your authors.
  shows a customization layer that removes the
 MsgSet  element from DocBook:
 Removing MsgSet Remove
 MsgSet  from the  compound.class . This is the only place
in the   where  MsgSet  is referenced. Exclude the definition of
  MsgSet  and all of its subelements from the
 . Removing Computer Inlines inline elements computer inlines, removing parameter entities tech.char.class, redefining tech.char.class parameter entity redefining 

DocBook contains a large number of computer inlines. The DocBook
inlines define a domain-specific vocabulary.  If you&#39;re working in
another domain, many of them may be unnecessary. You can remove a
bunch of them by redefining the  tech.char.class  parameter entity and
then excluding the declarations for the elements removed. The initial
definition of  tech.char.class  is:
 
&lt;!ENTITY % tech.char.class
    &quot;Action|Application|ClassName|Command|ComputerOutput
    |Database|Email|EnVar|ErrorCode|ErrorName|ErrorType|Filename
    |Function|GUIButton|GUIIcon|GUILabel|GUIMenu|GUIMenuItem
    |GUISubmenu|Hardware|Interface|InterfaceDefinition|KeyCap
    |KeyCode|KeyCombo|KeySym|Literal|Markup|MediaLabel|MenuChoice
    |MouseButton|MsgText|Option|Optional|Parameter|Prompt|Property
    |Replaceable|ReturnValue|SGMLTag|StructField|StructName
    |Symbol|SystemItem|Token|Type|UserInput
    %local.tech.char.class;&quot;&gt;
 
When examining this list, it seems that you can delete all of the
inlines except, perhaps,  Application ,
 Command ,  Email ,
 Filename ,  Literal ,
 Replaceable ,   Symbol , and
 SystemItem . The following customization layer
removes them.
 Removing Computer Inlines 
Initially we removed several more elements from  tech.char.class  ( function.module ,  keycap.module ), but using the testing procedure
described in  , we discovered that
these elements are used in other content models.  Because they are
used in other content modules, they cannot simply be removed from the
  by deleting them from  
tech.char.class .  Even though they can&#39;t be deleted
outright, we&#39;ve taken them out of most inline contexts.
 synopses synopsis elements, removing FuncSynopsis element removing CmdSynopsis element removing 
It&#39;s likely that a customization layer that removed this many
technical inlines would also remove some larger technical structures
( MsgSet ,  FuncSynopsis ), which
allows you to remove additional elements from the  .
 Removing Synopsis Elements 
Another possibility is removing the complex Synopsis elements. The
customization layer in   removes
 CmdSynopsis  and  FuncSynopsis .
 Removing CmdSynopsis and FuncSynopsis parameter entities empty 

Completely removing all Synopsis elements would require a more
extensive customization. You can&#39;t make any of the  *.class  parameter entities completely empty
without changing all of the parameter entities that use them. See
 .
 Removing Sectioning Elements sections elements, removing 

Perhaps you want to restrict your authors to only three levels of
sectioning.  To do that, you must remove the  Sect4 
and  Sect5   elements, as shown in  .
 Removing  Sect4  and  Sect5  Elements
 
In order to completely remove an element that isn&#39;t in the information
pool, it is usually necessary to redefine the elements that include
it. In this case, because we&#39;re removing the  Sect4 
element, we must redefine the  Sect3  element that
uses it.
 Removing Admonitions from Table Entries modules redeclarations redeclarations modules 

All of the customization layers that we&#39;ve examined so far have been
fairly straightforward. This section describes a much more complex
customization layer. Back in   we
mentioned that several additional modules existed for
 redeclaration.  The customization layer developed in this
section cannot be written without them.
 admonitions removing from table entries table entries, removing admonitions 

The goal is to remove admonitions ( Warning ,
 Caution ,  Note ) from table
entries.
  is a straightforward, and incorrect, attempt.
 Removing Admonitions (First Attempt: Incorrect) 
Because the parameter entity  tabentry.mix  defines the mixture of elements
allowed in table entries, you should remove admonitions.
 parameter entities tabentry.mix (removing admonitions) 
 tabentry.mix element, editing 

 
If you attempt to parse this  , you&#39;ll find that the declaration
of  tabentry.mix  contains errors. While
you can redefine parameter entities, you cannot make reference to
entities that have not been defined yet, so the use of  list.class ,  linespecific.class , and so on, aren&#39;t allowed.
 
Your second attempt might look like  .
 Removing Admonitions (Second Attempt: Incorrect) 
Declaring  tabentry.mix  after the  
has been loaded removes the errors.
 
This example contains no errors, but it also doesn&#39;t have any effect.
Remember, only the first entity declaration counts, so the declaration
of  tabentry.mix  in
 dbpool.mod  is the one used, not your
redeclaration.
 placeholders, redeclarations redeclarations placeholders 

The only way to fix this problem is to make use of one of the redeclaration
placeholders in DocBook.
 
Redeclaration placeholders are spots in which you can insert
definitions into the middle of the  . There are four redeclaration
placeholders in DocBook:
 %rdbmods parameter entity 

 rdbmods Inserted in  docbook.dtd , between
 dbpool.mod  and
 dbhier.mod . This placeholder is controlled by the
 intermod.redecl.module  marked
section. rdbpool %rdbpool.mod parameter entity 

Inserted in the middle of  dbpool.mod ,
between the  *.class  and  *.mix  entity declarations. This placeholder is
controlled by the  dbpool.redecl.module 
marked section. rdbhier %rdbhier parameter entity 

Inserted in the middle of  dbhier.mod ,
between the  *.class  and  *.mix  entity declarations. This placeholder is
controlled by the  dbhier.redecl.module  marked
section. rdbhier2 Also inserted into  dbhier.mod , after the
 *.mix  entity declarations. This
placeholder is controlled by the  dbhier.redecl2.module  marked
section. Use the redeclaration placeholder that it occurs nearest to, but
before the entity that you want to redeclare. In our case, this is
 rdbpool , as seen in  .
 Removing Admonitions (Third Attempt: Correct, if confusing) 
 escape sequences (parameter entities)  uses numeric character entity
references to escape the  %  signs in the entity
declarations and nests an entity declaration in another parameter
entity. All of this is perfectly legal, but a bit confusing.  A
clearer solution, and the only practical solution if you&#39;re doing
anything more than a single redeclaration, is to place the new
declarations in another file and include them in your customization
layer by reference, like this:
 Removing Admonitions (Fourth Attempt: Correct) In your customization layer: In  rdbpool.mod : Removing an Entire Class classes removing entire class elements removing parameter entities empty classes, redefining for 

Perhaps the modification that you want to make is to completely remove
an entire class of elements. (If you have no need for synopsis
elements of any sort, why not remove them?) In order to remove an
entire class of elements, you must not only redefine the class as
empty, but you must also redefine all of the parameter entities that
use that class. The customization layer below completely removes the
  synop.class  from DocBook. It
requires a customization layer, shown in  , that includes both a redeclaration module in
 dbpool.mod  and a redeclaration module in
 dbhier.mod .
 %synop.class, removing 
 Removing  synop.class In the customization layer: In  remv.synop.class.rdbpool.mod : In  remv.synop.class.rdbhier.mod : Removing Attributes Just as there may be more elements than you need, there may be more
attributes. Removing an Attribute attributes removing RenderAs attribute, removing 

Suppose you want to remove the  RenderAs  attribute from the
 Sect1  element.  RenderAs  allows the author to
 cheat  in the presentation of hierarchy by specifying
that the stylesheet should render a  Sect1  as
something else: a  Sect3 , perhaps.   details the removal of  RenderAs .
 Removing RenderAs from Sect1 Turn off the
 Sect1  module so that the element and attribute
declarations in the   will be ignored.
 Include the DocBook  . By keeping the local attribute
declaration, we leave open the possibility of a simple customization
layer on top of our customization layer. Similarly, we keep the
parameterized definition of the  Role 
attribute. We&#39;re changing the attribute
list, not the element, so we&#39;ve simply copied the
 Sect1  element declaration from the DocBook
 . Finally, we declare the attribute
list, leaving out the  RenderAs . Subsetting the Common Attributes attributes common subsetting subsetting common attributes 

DocBook defines eleven common attributes; these attributes appear on
 every  element. Depending on how you&#39;re
processing your documents, removing some of them can both simplify the
authoring task and improve processing speed.
 Some obvious candidates are: Effectivity attributes ( Arch
 ,  OS ,...) effectivity attributes, removing 

If you&#39;re not using all of the effectivity attributes in your
documents, you can get rid of up to seven attributes in one fell
swoop. Lang Lang attribute removing 

If you&#39;re not producing multilingual documents, you can remove
 Lang . Remap Remap attribute removing 
The  Remap  attribute is
designed to hold the name of a semantically equivalent construct from
a previous markup scheme (for example, a Microsoft Word style template
name, if you&#39;re converting from Word).  If you&#39;re authoring from
scratch, or not preserving previous constructs with  Remap , you can get rid of it. XrefLabel XrefLabel attribute removing 
If your processing system isn&#39;t using  XrefLabel , it&#39;s a candidate as
well. 
The customization layer in   reduces the
common attributes to just  ID  and
 Lang .
 Removing Common Attributes common.attrib parameter entity idreq.common.attrib parameter entity 

By definition, whatever attributes you define in the  common.attrib  and  idreq.common.attrib  parameter entities
are the common attributes. In  dbpool.mod  , these
parameter entities are defined in terms of other parameter entities,
but there&#39;s no way to preserve that structure in your customization
layer.
 Adding Elements: Adding a Sect6 elements adding 

Adding a structural (as opposed to information pool) element generally
requires adding its name to a class and then providing the appropriate
definitions.   extends DocBook by adding a
 Sect6  element.
 Adding a Sect6 Element 
Here we&#39;ve redefined  Sect5  to include
 Sect6  and provided a declaration for
 Sect6 . Note that we didn&#39;t bother to provide
 RenderAs  attributes in our
redefinitions. To properly support  Sect6 , you might
want to redefine all of the sectioning elements so that  
Sect6  is a legal attribute value for  RenderAs .
 Other Modifications: Classifying a Role Role attribute changing on Procedure (example) 

The  Role  attribute, found on almost
all of the elements in DocBook, is a  CDATA  attribute that
can be used to subclass an element. In some applications, it may be useful
to modify the definition of  Role  so that
authors must choose one of a specific set of possible values. In  ,  Role  on the  Procedure  element
is constrained to the values  Required  or  
Optional . Changing Role on Procedure 
 About this Book This is an  alpha  edition of this book.
This version may contain glaring inconsistencies, missing sections,
and other misfeatures indicative of a  work in progress .
 About the Authors Norman Walsh is an  XML Standards Engineer 
with  Sun Microsystems, Inc. .
 Norm is an active participant in a number of standards efforts
worldwide, including the XML Core, XSL and XML Schema Working Groups
of the World Wide Web Consortium, the OASIS XSLT Conformance and
RELAX�NG Committees, the OASIS Entity Resolution Committee for
which he is the editor, and the OASIS DocBook Technical Committee,
which he chairs.
 Leonard Muellner has been implementing and supporting the
production of O&#39;Reilly books marked up in DocBook since 1994.
 Colophon Our look is the result of reader comments, our own
experimentation, and feedback from distribution channels.
Distinctive covers complement our distinctive approach to
technical topics, breathing personality and life into
potentially dry subjects.
 The bird on the cover of  DocBook: The Definitive
Guide  is a wood duck.  Often considered one of the most
beautiful ducks in North America, the male wood duck has a metallic
purple and green head with white streaks extending from its bill
around the eyes and down to its blue and green, gold-flecked
wings. It has a white neck, chestnut-colored chest, a white or red
bill, and yellow-orange legs and feet. Females have more brown, gray,
and subdued hues.
 Edie Freedman designed the cover of this book, using a
19th-century engraving from the Dover Pictorial Archive. The
cover layout was produced by Kathleen Wilson using QuarkXPress
3.32 and Adobe&#39;s ITC Garamond font. The inside layout was
designed by Alicia Cech, based on a series design by Nancy
Priest. The text was formatted from SGML into FrameMaker 5.5
with Jade, using a DSSSL conversion stylesheet written by
Chris Maden. The interior fonts are ITC Garamond Light,
Garamond Book, and ConstantWillison.
 Whenever possible, our books use RepKover(TM), a durable and
flexible lay-flat binding. If the page count exceeds RepKover&#39;s
limit, perfect binding is used.
 The illustrations that appear in this book were produced by
Robert Romano using Macromedia Freehand 8 and Adobe Photoshop
5. David Futato was the production editor; Madeleine Newell guided
the book through the early stages of production.
Mark Nigara was the copyeditor for DocBook: The Definitive Guide.
Claire LeBlanc was the production manager. Ellie Cutler was the
proofreader; quality assurance was provided by Jeff Holcomb and
Claire LeBlanc. This colophon was written by Nicole Arigo.
 
 $Date: 2001-08-02 14:27:50 +0400 (Чт, 02 авг 2001) $ $Revision: 546 $ Glossary attribute attributes elements attributes 

Attributes augment the element on which they appear; they also
provide additional information about the element.
 start tags attribute ID, containing 

Attributes appear as name-value pairs in the element&#39;s start-tag.
For example, to assign the value  hostname  to the
 Role  attribute of  SystemItem ,
you would use the mark up:
 systemitem role=&quot;hostname&quot; .
 callout callouts 
A pointer, verbal or graphical or both, to a 
 component  of an illustration 
or a text object. cooked cooked data appearance cooked data Cooked  data, as distinct from  raw,  is a collection
of elements and character data that&#39;s ready for presentation. The processor
is not expected to rearrange, select, or suppress any of the elements, but
simply present them as specified.
 Raw document type declaration ( ) document type declaration declarations document type declaration 

A set of declarations that defines the names of the elements 
and their attributes, and that specifies rules for their combination
or sequence.
 DSSSL DSSSL stylesheets languages DSSSL 

Document Style Semantics and Specification Language
( ISO / IEC  10179:1996). An international standard stylesheet language
for  /  documents.
 element elements hierarchical structure elements, defining empty elements start tags empty element 

Elements define the hierarchical structure of a document.
Most elements have start and end tags and contain some part of the
document content. Empty elements have only a start tag and have no content. 
 entity entities data entities 

A name assigned (by means of a declaration) to some chunk of 
data so it can be referred to by that name; the data can be 
of various kinds (a special character or a chapter or a set of
declarations in a  , for instance), and the way in which it is referred 
to depends on the type of data and where it is being referenced: 
  has parameter, general, external, internal, and data entities. exclusion exclusions DTDs exclusions elements exclusions 

An exclusion is used in a   to indicate that, within the element on 
which the exclusion occurs, the excluded elements are not valid anywhere
within the content of the element.
 Footnote element exclusions nesting footnotes 

For example, in DocBook,  Footnote  excludes  Footnote .
This means that footnotes cannot nest, even though  Footnote 
contains  Para , and  Footnote  occurs in the proper
content model of  Para .
 
See  . external entity external general entities general entities external references external documents documents external, references to 

An external entity is a general entity that refers to another
document. External entities are often used to incorporate 
parsable text documents, like legal notices or chapters, into larger
units, like chapters or books. external subset external subset document type declaration external subset public identifiers external subset system identifiers external subset declarations document type declaration 


Element, attribute, and other declarations that compose
(part of) a document type definition that are stored in an
external entity, and referenced from a document&#39;s document type
declaration using a public or system identifier. float float text float 

Text objects like sidebars, figures, tables, and graphics are said
to float when their actual place in the document is not fixed. For presentation
on a printed page, for instance, a graphic may float to the top of the next page if it
is too tall to fit on the page in which it actually falls, in the sequence of words and the sequence of
other like objects in a document. formal public identifier FPI public identifiers formal 
A public identifier that conforms to the specification of formal
public identifers in  ISO  8879. FOSI FOSI stylesheets 

Formatting Output Specification Instance, an   document that 
specifies the appearance or presentation of another   document in 
accordance 
with the Output Specification   defined by  MIL-STD-28001C . general entity general entities entities general special characters, encoding as entities internal general entities 

An entity referenced by a name that starts with an 
ampersand (&amp;) and ends with a semicolon. Most of the
time general entities are used in   documents, not in the  . 
There are two types, external and internal entities, and they 
refer either to special characters or to text objects 
like commonly repeated phrases or names or chapters. GI generic identifiers (GI) GI (generic identifiers) identifiers, generic elements generic identifiers names elements (generic identifiers) 

Generic identifier, proper term for the actual name of an element;
 Para  is the generic identifier of the  para  element. inclusion inclusions DTDs inclusions elements inclusions nesting elements 

An inclusion is used in a   to indicate that, within the element on 
which the inclusion occurs, the included elements are valid anywhere
within the content of the element.
 
For example, in DocBook,  Chapter  includes  IndexTerm .
This means that  IndexTerm s can occur anywhere inside chapters,
even inside elements that do not have  IndexTerm s in their
proper content models.
 
See  .
 internal entity internal general entities general entities internal entities general 

A general entity that references a piece of text (including
its markup and even other internal entities), usually as a
keyboard shortcut. internal subset internal subset document type declaration internal subset declarations document type declaration 

Element, attribute, and other declarations that compose
(part of) a document type definition that are stored in a document,
within the document type declaration.
 meta-information meta-information documents meta-information 

Meta-information is information about a document, such as the 
specification of its author or its date of composition, as opposed 
to the content of a document itself. parameter entity parameter entities DocBook DTD customizing parameter entities customization (DocBook DTD) parameter entities, using marked sections parameter entities, controlling 

An entity usually referenced in the   by a name that 
starts with a percent sign (%) and ends with a semicolon. 
In DocBook, parameter entities are mainly used to facilitate 
customization of the  , but they can also be used to control
marked sections of a document. processing instruction processing instructions 

An essentially arbitrary string preceded by a question mark and
delimited by angle brackets that is intended to convey
information to an application that processes an   instance.
For example, the processing instruction  &lt;?linebreak&gt; 
might cause the formatter to introduce a line break at the position where
the processing instruction occurs.
 XML processing instructions PI processing instructions 

In   documents, processing instructions should have the form:
 
&lt;? pitarget  param1=&quot;value1&quot; param2=&quot;value2&quot;?&gt;
 
 
The  pitarget  should be a name that the processing application
will recognize. Additional information in the  PI  should be added using
 attribute syntax. 
 public identifier public identifiers external general entities public identifiers SGML public identifiers XML public identifiers DTDs public identifiers 

An abstract identifier for an   or   document,  , or 
external entity. raw raw data appearance raw data raw data cooked data cooked data raw data Raw  data is just a collection of elements, with no additional
punctation or information about presentation. To continue the cooking
metaphor, raw data is just a set of ingredients. It&#39;s up to the processor
to select appropriate elements, arrange them for display, and add
required presentational information.
 Cooked SGML ISO standards SGML 

Standard Generalized Markup Language, an international standard ( ISO  8879) that specifies 
the rules for the creation of platform-independent markup languages for electronic texts.
 stylesheet stylesheets appearance stylesheets 

A file that specifies the presentation or appearance of a document;
there are several standards for such stylesheets, including
 CSS ,  FOSI s,  DSSSL , and, most recently,  XSL . Vendors often have proprietary
stylesheet formats as well.
 system identifier system identifiers SGML SGML system identifiers 

In  , a local, system-dependent identifier for a document,
 , or external entity. Usually a filename on the local system. system identifiers XML URI XML system identifiers XML system identifiers 

In  , a system identifer is required to be a  URI .
 tag tags elements tags angle brackets SGML tags SGML tags 

An   element name enclosed in angle brackets
(&lt;&gt;), used to mark up the semantics or structure of a
document.  Para  is a tag in DocBook
used to mark the beginning of a paragraph. URI URI Internet names and addresses addresses, Internet syntax names Internet, syntax 

Uniform Resource Identifier, the  W3C &#39;s codification of the name and 
address syntax of present and future objects on the Internet. In its most basic 
form, a  URI  consists of a scheme name (such as file, http, ftp, news, mailto, 
gopher) followed by a colon, followed by a path whose nature is determined 
by the scheme that precedes it (see  RFC  1630). 
 URN URL URI  is the umbrella term for  URN s,  URL s, and all other Uniform Resource
Identifiers.
 URL Uniform Resource Locator, a name and address for an existing object
accessible over the Internet.  http://www.docbook.org 
is an example of a  URL  (see  RFC  1738). URN Uniform Resource Name, the result of an evolving attempt to
define a name and address syntax for  persistent 
objects accessible over the Internet;  urn:foo:a123,456 
is a legal  URN  consisting of three colon-separated fields: 
 urn  
followed by a namespace identifier, followed by a namespace specifier
(see  RFC  1737 and  RFC  2141 for details). W3C W3C (World Wide Web Consortium) World Wide Web Consortium (W3C) 

The World Wide Web Consortium ( http://www.w3.org/ ). wrapper wrappers meta-information wrappers elements wrappers 

Some elements, such as  Chapter , have important semantic
significance.  Other elements serve no obvious purpose except to contain
a number of other elements. For example,  BookInfo  has no
important semantics; it merely serves as a container for the meta-information
about a book.  Elements that are just containers are sometimes called
 wrappers.  
 XML SGML XML and Extensible Markup Language XML 

The  Extensible Markup Language , a subset of   
designed specifically for use over the Web. XSL XSL XML XSL stylesheets 
  Style Language, an evolving language for stylesheets 
to be attached to   documents. The stylesheet is itself an  
document. 


 


   

 

 DocBook The Definitive Guide 2.0.17 
  Documentation
   
   
   
   
   
   
   
   http://docbook.org/tdg/en/ http://docbook.org/tdg/en/tdg-en-html-{VERSION}.zip http://docbook.org/tdg/en/html/appi.html http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/docbook/defguide/ http://lists.oasis-open.org/archives/docbook/ Updated license terms. DocBook The Definitive Guide Norman Walsh Leonard Muellner Bob Stayton Frank Willison David Futato O&#39;Reilly Media, Inc. Beijing Cambridge Farnham Köln Paris Sebastopol Taipei Tokyo October 1999: First Edition. 156592-580-7 $Date: 2007-02-06 00:30:05 +0300 (Вт, 06 фев 2007) $ DocBook: The Definitive Guide  Copyright
© 2004-2006 Norman Walsh. Portions Copyright © 1999-2003
O&#39;Reilly Media, Inc. Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation.
A copy of the license is included in  . Nutshell Handbook, the Nutshell Handbook logo, and the O&#39;Reilly
logo are registered trademarks of O&#39;Reilly Media, Inc. The
association between the image of a duck and the topic of DocBook is a
trademark of O&#39;Reilly Media, Inc. Java and all Java-based
trademarks and logos are trademarks or registered trademarks of Sun
Microsystems, Inc., in the United States and other countries. O&#39;Reilly
Media, Inc. is independent of Sun Microsystems.
 Many of the designations used by manufacturers and sellers to
distinguish their products are claimed as trademarks. Where those
designations appear in this book, and O&#39;Reilly Media, Inc.
was aware of a trademark claim, the designations have been printed in
caps or initial caps. While every precaution has been taken in the
preparation of this book, the publisher assumes no responsibility for
errors or omissions, or for damages resulting from the use of the
information contained herein.
 1999 2000 2001 2002 2003 O&#39;Reilly Media, Inc. All rights reserved. 2004 2005 2006 Norman Walsh. 
 
 
 :  
 



</plainxml>
