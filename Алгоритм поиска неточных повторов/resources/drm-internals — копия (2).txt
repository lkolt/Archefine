



Spring Framework Reference Documentation


4.3.7.RELEASE




Rod Johnson , Juergen Hoeller , Keith Donald , Colin Sampaleanu , Rob Harrop , Thomas Risberg , Alef Arendsen , Darren Davison , Dmitriy Kopylenko , Mark Pollack , Thierry Templier , Erwin Vervaet , Portia Tung , Ben Hale , Adrian Colyer , John Lewis , Costin Leau , Mark Fisher , Sam Brannen , Ramnivas Laddad , Arjen Poutsma , Chris Beams , Tareq Abedrabbo , Andy Clement , Dave Syer , Oliver Gierke , Rossen Stoyanchev , Phillip Webb , Rob Winch , Brian Clozel , Stephane Nicoll , Sebastien Deleuze



























Copyright (c) 2004-2016

Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.










































Table of Contents

I. Overview of Spring Framework	1
1. Getting Started with Spring	2
2. Introduction to the Spring Framework	3
2.1. Dependency Injection and Inversion of Control	3
2.2. Modules	3
Core Container	4
AOP and Instrumentation	5
Messaging	5
Data Access/Integration	5
Web	5
Test	6
2.3. Usage scenarios	6
Dependency Management and Naming Conventions	9
Spring Dependencies and Depending on Spring	11
Maven Dependency Management	11
Maven "Bill Of Materials" Dependency	12
Gradle Dependency Management	12
Ivy Dependency Management	13
Distribution Zip Files	13
Logging	13
Not Using Commons Logging	14
Using SLF4J	14
Using Log4j	15
II. What's New in Spring Framework 4.x	18
1. New Features and Enhancements in Spring Framework 4.0	19
1.1. Improved Getting Started Experience	19
1.2. Removed Deprecated Packages and Methods	19
1.3. Java 8 (as well as 6 and 7)	19
1.4. Java EE 6 and 7	20
1.5. Groovy Bean Definition DSL	20
1.6. Core Container Improvements	20
1.7. General Web Improvements	21
1.8. WebSocket, SockJS, and STOMP Messaging	21
1.9. Testing Improvements	22
2. New Features and Enhancements in Spring Framework 4.1	23
2.1. JMS Improvements	23
2.2. Caching Improvements	23
2.3. Web Improvements	24
2.4. WebSocket Messaging Improvements	25
2.5. Testing Improvements	25
3. New Features and Enhancements in Spring Framework 4.2	27
3.1. Core Container Improvements	27
3.2. Data Access Improvements	28
3.3. JMS Improvements	29
3.4. Web Improvements	29
3.5. WebSocket Messaging Improvements	30
3.6. Testing Improvements	30
4. New Features and Enhancements in Spring Framework 4.3	33
4.1. Core Container Improvements	33
4.2. Data Access Improvements	33
4.3. Caching Improvements	33
4.4. JMS Improvements	34
4.5. Web Improvements	34
4.6. WebSocket Messaging Improvements	34
4.7. Testing Improvements	34
4.8. Support for new library and server generations	35
III. Core Technologies	37
5. The IoC container	38
5.1. Introduction to the Spring IoC container and beans	38
5.2. Container overview	38
Configuration metadata	39
Instantiating a container	40
Composing XML-based configuration metadata	41
The Groovy Bean Definition DSL	42
Using the container	43
5.3. Bean overview	43
Naming beans	44
Aliasing a bean outside the bean definition	45
Instantiating beans	46
Instantiation with a constructor	47
Instantiation with a static factory method	47
Instantiation using an instance factory method	47
5.4. Dependencies	49
Dependency Injection	49
Constructor-based dependency injection	49
Setter-based dependency injection	51
Dependency resolution process	52
Examples of dependency injection	53
Dependencies and configuration in detail	55
Straight values (primitives, Strings, and so on)	55
References to other beans (collaborators)	57
Inner beans	58
Collections	58
Null and empty string values	60
XML shortcut with the p-namespace	61
XML shortcut with the c-namespace	62
Compound property names	63
Using depends-on	63
Lazy-initialized beans	63
Autowiring collaborators	64
Limitations and disadvantages of autowiring	65
Excluding a bean from autowiring	66
Method injection	66
Lookup method injection	67
Arbitrary method replacement	69
5.5. Bean scopes	70
The singleton scope	71
The prototype scope	72
Singleton beans with prototype-bean dependencies	73
Request, session, global session, application, and WebSocket scopes	73
Initial web configuration	74
Request scope	74
Session scope	75
Global session scope	75
Application scope	75
Scoped beans as dependencies	76
Custom scopes	78
Creating a custom scope	78
Using a custom scope	79
5.6. Customizing the nature of a bean	80
Lifecycle callbacks	80
Initialization callbacks	81
Destruction callbacks	81
Default initialization and destroy methods	82
Combining lifecycle mechanisms	83
Startup and shutdown callbacks	84
Shutting down the Spring IoC container gracefully in non-web applications
................................................................................................................. 86
ApplicationContextAware and BeanNameAware	86
Other Aware interfaces	87
5.7. Bean definition inheritance	88
5.8. Container Extension Points	90
Customizing beans using a BeanPostProcessor	90
Example: Hello World, BeanPostProcessor-style	91
Example: The RequiredAnnotationBeanPostProcessor	93
Customizing configuration metadata with a BeanFactoryPostProcessor	93
Example: the Class name substitution PropertyPlaceholderConfigurer	94
Example: the PropertyOverrideConfigurer	95
Customizing instantiation logic with a FactoryBean	96
5.9. Annotation-based container configuration	96
@Required	98
@Autowired	98
Fine-tuning annotation-based autowiring with @Primary	101
Fine-tuning annotation-based autowiring with qualifiers	102
Using generics as autowiring qualifiers	107
CustomAutowireConfigurer	108
@Resource	108
@PostConstruct and @PreDestroy	110
5.10. Classpath scanning and managed components	110
@Component and further stereotype annotations	110
Meta-annotations	111
Automatically detecting classes and registering bean definitions	112
Using filters to customize scanning	113
Defining bean metadata within components	114
Naming autodetected components	117
Providing a scope for autodetected components	117
Providing qualifier metadata with annotations	118
5.11. Using JSR 330 Standard Annotations	119
Dependency Injection with @Inject and @Named	119
@Named and @ManagedBean: standard equivalents to the @Component annotation	120
Limitations of JSR-330 standard annotations	121
5.12. Java-based container configuration	122
Basic concepts: @Bean and @Configuration	122
Instantiating the Spring container using AnnotationConfigApplicationContext	123
Simple construction	123
Building the container programmatically using register(Class<?>...)	124
Enabling component scanning with scan(String...)	124
Support for web applications with AnnotationConfigWebApplicationContext
...............................................................................................................  125
Using the @Bean annotation	126
Declaring a bean	126
Bean dependencies	127
Receiving lifecycle callbacks	127
Specifying bean scope	129
Customizing bean naming	130
Bean aliasing	130
Bean description	130
Using the @Configuration annotation	130
Injecting inter-bean dependencies	130
Lookup method injection	131
Further information about how Java-based configuration works internally	132
Composing Java-based configurations	133
Using the @Import annotation	133
Conditionally include @Configuration classes or @Bean methods	137
Combining Java and XML configuration	138
5.13. Environment abstraction	140
Bean definition profiles	140
@Profile	141
XML bean definition profiles	143
Activating a profile	143
Default profile	144
PropertySource abstraction	144
@PropertySource	145
Placeholder resolution in statements	146
5.14. Registering a LoadTimeWeaver	146
5.15. Additional Capabilities of the ApplicationContext	147
Internationalization using MessageSource	147
Standard and Custom Events	150
Annotation-based Event Listeners	153
Asynchronous Listeners	155
Ordering Listeners	155
Generic Events	155
Convenient access to low-level resources	156
Convenient ApplicationContext instantiation for web applications	156
Deploying a Spring ApplicationContext as a Java EE RAR file	157
5.16. The BeanFactory	157
BeanFactory or ApplicationContext?	158
Glue code and the evil singleton	159
6. Resources	160
6.1. Introduction	160
6.2. The Resource interface	160
6.3. Built-in Resource implementations	161
UrlResource	161
ClassPathResource	161
FileSystemResource	162
ServletContextResource	162
InputStreamResource	162
ByteArrayResource	162
6.4. The ResourceLoader	162
6.5. The ResourceLoaderAware interface	163
6.6. Resources as dependencies	164
6.7. Application contexts and Resource paths	164
Constructing application contexts	164
Constructing ClassPathXmlApplicationContext instances - shortcuts	165
Wildcards in application context constructor resource paths	165
Ant-style Patterns	166
The Classpath*: portability classpath*: prefix	166
Other notes relating to wildcards	167
FileSystemResource caveats	167
7. Validation, Data Binding, and Type Conversion	169
7.1. Introduction	169
7.2. Validation using Spring's Validator interface	169
7.3. Resolving codes to error messages	171
7.4. Bean manipulation and the BeanWrapper	172
Setting and getting basic and nested properties	172
Built-in PropertyEditor implementations	174
Registering additional custom PropertyEditors	177
7.5. Spring Type Conversion	179
Converter SPI	179
ConverterFactory	180
GenericConverter	180
ConditionalGenericConverter	181
ConversionService API	181
Configuring a ConversionService	182
Using a ConversionService programmatically	183
7.6. Spring Field Formatting	183
Formatter SPI	184
Annotation-driven Formatting	185
Format Annotation API	186
FormatterRegistry SPI	186
FormatterRegistrar SPI	187
Configuring Formatting in Spring MVC	187
7.7. Configuring a global date & time format	187
7.8. Spring Validation	189
Overview of the JSR-303 Bean Validation API	189
Configuring a Bean Validation Provider	189
Injecting a Validator	190
Configuring Custom Constraints	190
Spring-driven Method Validation	191
Additional Configuration Options	191
Configuring a DataBinder	191
Spring MVC 3 Validation	192
8. Spring Expression Language (SpEL)	193
8.1. Introduction	193
8.2. Feature Overview	193
8.3. Expression Evaluation using Spring's Expression Interface	194
The EvaluationContext interface	196
Type Conversion	196
Parser configuration	197
SpEL compilation	197
Compiler configuration	198
Compiler limitations	199
8.4. Expression support for defining bean definitions	199
XML based configuration	199
Annotation-based configuration	200
8.5. Language Reference	201
Literal expressions	201
Properties, Arrays, Lists, Maps, Indexers	201
Inline lists	202
Inline Maps	202
Array construction	203
Methods	203
Operators	203
Relational operators	203
Logical operators	204
Mathematical operators	204
Assignment	205
Types	205
Constructors	205
Variables	206
The #this and #root variables	206
Functions	206
Bean references	207
Ternary Operator (If-Then-Else)	207
The Elvis Operator	207
Safe Navigation operator	208
Collection Selection	208
Collection Projection	209
Expression templating	209
8.6. Classes used in the examples	210
9. Aspect Oriented Programming with Spring	214
9.1. Introduction	214
AOP concepts	214
Spring AOP capabilities and goals	216
AOP Proxies	217
9.2. @AspectJ support	217
Enabling @AspectJ Support	217
Enabling @AspectJ Support with Java configuration	217
Enabling @AspectJ Support with XML configuration	218
Declaring an aspect	218
Declaring a pointcut	219
Supported Pointcut Designators	219
Combining pointcut expressions	221
Sharing common pointcut definitions	221
Examples	223
Writing good pointcuts	225
Declaring advice	226
Before advice	226
After returning advice	226
After throwing advice	227
After (finally) advice	228
Around advice	228
Advice parameters	229
Advice ordering	232
Introductions	233
Aspect instantiation models	233
Example	234
9.3. Schema-based AOP support	236
Declaring an aspect	236
Declaring a pointcut	237
Declaring advice	238
Before advice	238
After returning advice	239
After throwing advice	239
After (finally) advice	240
Around advice	240
Advice parameters	241
Advice ordering	242
Introductions	243
Aspect instantiation models	243
Advisors	243
Example	244
9.4. Choosing which AOP declaration style to use	246
Spring AOP or full AspectJ?	246
@AspectJ or XML for Spring AOP?	247
9.5. Mixing aspect types	247
9.6. Proxying mechanisms	248
Understanding AOP proxies	248
9.7. Programmatic creation of @AspectJ Proxies	251
9.8. Using AspectJ with Spring applications	251
Using AspectJ to dependency inject domain objects with Spring	251
Unit testing @Configurable objects	254
Working with multiple application contexts	254
Other Spring aspects for AspectJ	254
Configuring AspectJ aspects using Spring IoC	255
Load-time weaving with AspectJ in the Spring Framework	256
A first example	256
Aspects	259
'META-INF/aop.xml'	259
Required libraries (JARS)	260
Spring configuration	260
Environment-specific configuration	262
9.9. Further Resources	264
10. Spring AOP APIs	265
10.1. Introduction	265
10.2. Pointcut API in Spring	265
Concepts	265
Operations on pointcuts	266
AspectJ expression pointcuts	266
Convenience pointcut implementations	266
Static pointcuts	266
Dynamic pointcuts	267
Pointcut superclasses	268
Custom pointcuts	268
10.3. Advice API in Spring	268
Advice lifecycles	268
Advice types in Spring	268
Interception around advice	268
Before advice	269
Throws advice	270
After Returning advice	271
Introduction advice	272
10.4. Advisor API in Spring	274
10.5. Using the ProxyFactoryBean to create AOP proxies	274
Basics	274
JavaBean properties	275
JDK- and CGLIB-based proxies	276
Proxying interfaces	276
Proxying classes	278
Using 'global' advisors	279
10.6. Concise proxy definitions	279
10.7. Creating AOP proxies programmatically with the ProxyFactory	280
10.8. Manipulating advised objects	281
10.9. Using the "auto-proxy" facility	282
Autoproxy bean definitions	282
BeanNameAutoProxyCreator	282
DefaultAdvisorAutoProxyCreator	283
AbstractAdvisorAutoProxyCreator	284
Using metadata-driven auto-proxying	284
10.10. Using TargetSources	286
Hot swappable target sources	286
Pooling target sources	286
Prototype target sources	288
ThreadLocal target sources	288
10.11. Defining new Advice types	288
10.12. Further resources	289
IV. Testing	290
11. Introduction to Spring Testing	291
14. Unit Testing	292
14.1. Mock Objects	292
Environment	292
JNDI	292
Servlet API	292
Portlet API	292
14.2. Unit Testing support Classes	293
General testing utilities	293
Spring MVC	293
15. Integration Testing	294
15.1. Overview	294
15.2. Goals of Integration Testing	294
Context management and caching	294
Dependency Injection of test fixtures	295
Transaction management	295
Support classes for integration testing	296
15.3. JDBC Testing Support	296
15.4. Annotations	296
Spring Testing Annotations	296
@BootstrapWith	297
@ContextConfiguration	297
@WebAppConfiguration	297
@ContextHierarchy	298
@ActiveProfiles	298
@TestPropertySource	299
@DirtiesContext	299
@TestExecutionListeners	301
@Commit	301
@Rollback	301
@BeforeTransaction	302
@AfterTransaction	302
@Sql	302
@SqlConfig	302
@SqlGroup	303
Standard Annotation Support	303
Spring JUnit 4 Testing Annotations	304
@IfProfileValue	304
@ProfileValueSourceConfiguration	304
@Timed	304
@Repeat	305
Meta-Annotation Support for Testing	305
15.5. Spring TestContext Framework	306
Key abstractions	307
TestContext	307
TestContextManager	307
TestExecutionListener	307
Context Loaders	307
Bootstrapping the TestContext framework	308
TestExecutionListener configuration	309
Registering custom TestExecutionListeners	309
Automatic discovery of default TestExecutionListeners	309
Ordering TestExecutionListeners	309
Merging TestExecutionListeners	310
Context management	311
Context configuration with XML resources	312
Context configuration with Groovy scripts	312
Context configuration with annotated classes	313
Mixing XML, Groovy scripts, and annotated classes	314
Context configuration with context initializers	315
Context configuration inheritance	316
Context configuration with environment profiles	317
Context configuration with test property sources	322
Loading a WebApplicationContext	324
Context caching	327
Context hierarchies	328
Dependency injection of test fixtures	330
Testing request and session scoped beans	332
Transaction management	334
Test-managed transactions	334
Enabling and disabling transactions	335
Transaction rollback and commit behavior	336
Programmatic transaction management	336
Executing code outside of a transaction	336
Configuring a transaction manager	337
Demonstration of all transaction-related annotations	337
Executing SQL scripts	338
Executing SQL scripts programmatically	339
Executing SQL scripts declaratively with @Sql	339
TestContext Framework support classes	343
Spring JUnit 4 Runner	343
Spring JUnit 4 Rules	343
JUnit 4 support classes	344
TestNG support classes	344
15.6. Spring MVC Test Framework	345
Server-Side Tests	346
Static Imports	347
Setup Options	347
Performing Requests	348
Defining Expectations	349
Filter Registrations	350
Differences between Out-of-Container and End-to-End Integration Tests	350
Further Server-Side Test Examples	351
HtmlUnit Integration	351
Why HtmlUnit Integration?	352
MockMvc and HtmlUnit	354
MockMvc and WebDriver	356
MockMvc and Geb	361
Client-Side REST Tests	362
Static Imports	363
Further Examples of Client-side REST Tests	363
15.7. PetClinic Example	364
16. Further Resources	366
V. Data Access	367
17. Transaction Management	368
17.1. Introduction to Spring Framework transaction management	368
17.2. Advantages of the Spring Framework's transaction support model	368
Global transactions	368
Local transactions	369
Spring Framework's consistent programming model	369
17.3. Understanding the Spring Framework transaction abstraction	370
17.4. Synchronizing resources with transactions	373
High-level synchronization approach	373
Low-level synchronization approach	374
TransactionAwareDataSourceProxy	374
17.5. Declarative transaction management	374
Understanding the Spring Framework's declarative transaction implementation... 376 Example of declarative transaction implementation	376
Rolling back a declarative transaction	380
Configuring different transactional semantics for different beans	381
<tx:advice/> settings	383
Using @Transactional	384
@Transactional settings	389
Multiple Transaction Managers with @Transactional	390
Custom shortcut annotations	391
Transaction propagation	391
Required	391
RequiresNew	392
Nested	392
Advising transactional operations	392
Using @Transactional with AspectJ	395
17.6. Programmatic transaction management	396
Using the TransactionTemplate	396
Specifying transaction settings	398
Using the PlatformTransactionManager	398
17.7. Choosing between programmatic and declarative transaction management	399
17.8. Transaction bound event	399
17.9. Application server-specific integration	399
IBM WebSphere	400
Oracle WebLogic Server	400
17.10. Solutions to common problems	400
Use of the wrong transaction manager for a specific DataSource	400
17.11. Further Resources	400
18. DAO support	402
18.1. Introduction	402
18.2. Consistent exception hierarchy	402
18.3. Annotations used for configuring DAO or Repository classes	403
19. Data access with JDBC	405
19.1. Introduction to Spring Framework JDBC	405
Choosing an approach for JDBC database access	405
Package hierarchy	406
19.2. Using the JDBC core classes to control basic JDBC processing and error
handling	407
JdbcTemplate	407
Examples of JdbcTemplate class usage	407
JdbcTemplate best practices	409
NamedParameterJdbcTemplate	411
SQLExceptionTranslator	413
Executing statements	414
Running queries	415
Updating the database	416
Retrieving auto-generated keys	416
19.3. Controlling database connections	416
DataSource	416
DataSourceUtils	418
SmartDataSource	418
AbstractDataSource	418
SingleConnectionDataSource	418
DriverManagerDataSource	418
TransactionAwareDataSourceProxy	419
DataSourceTransactionManager	419
NativeJdbcExtractor	419
19.4. JDBC batch operations	420
Basic batch operations with the JdbcTemplate	420
Batch operations with a List of objects	421
Batch operations with multiple batches	422
19.5. Simplifying JDBC operations with the SimpleJdbc classes	422
Inserting data using SimpleJdbcInsert	423
Retrieving auto-generated keys using SimpleJdbcInsert	423
Specifying columns for a SimpleJdbcInsert	424
Using SqlParameterSource to provide parameter values	425
Calling a stored procedure with SimpleJdbcCall	425
Explicitly declaring parameters to use for a SimpleJdbcCall	427
How to define SqlParameters	428
Calling a stored function using SimpleJdbcCall	428
Returning ResultSet/REF Cursor from a SimpleJdbcCall	429
19.6. Modeling JDBC operations as Java objects	430
SqlQuery	430
MappingSqlQuery	431
SqlUpdate	432
StoredProcedure	432
19.7. Common problems with parameter and data value handling	435
Providing SQL type information for parameters	435
Handling BLOB and CLOB objects	436
Passing in lists of values for IN clause	437
Handling complex types for stored procedure calls	437
19.8. Embedded database support	439
Why use an embedded database?	439
Creating an embedded database using Spring XML	439
Creating an embedded database programmatically	439
Selecting the embedded database type	440
Using HSQL	440
Using H2	440
Using Derby	440
Testing data access logic with an embedded database	440
Generating unique names for embedded databases	441
Extending the embedded database support	441
19.9. Initializing a DataSource	442
Initializing a database using Spring XML	442
Initialization of other components that depend on the database	443
20. Object Relational Mapping (ORM) Data Access	445
20.1. Introduction to ORM with Spring	445
20.2. General ORM integration considerations	446
Resource and transaction management	446
Exception translation	447
20.3. Hibernate	447
SessionFactory setup in a Spring container	447
Implementing DAOs based on plain Hibernate API	448
Declarative transaction demarcation	449
Programmatic transaction demarcation	450
Transaction management strategies	451
Comparing container-managed and locally defined resources	452
Spurious application server warnings with Hibernate	453
20.4. JDO	454
PersistenceManagerFactory setup	454
Implementing DAOs based on the plain JDO API	455
Transaction management	457
JdoDialect	458
20.5. JPA	458
Three options for JPA setup in a Spring environment	458
LocalEntityManagerFactoryBean	458
Obtaining an EntityManagerFactory from JNDI	459
LocalContainerEntityManagerFactoryBean	459
Dealing with multiple persistence units	461
Implementing DAOs based on JPA: EntityManagerFactory and EntityManager	462
Spring-driven JPA transactions	464
JpaDialect and JpaVendorAdapter	464
Setting up JPA with JTA transaction management	464
21. Marshalling XML using O/X Mappers	466
21.1. Introduction	466
Ease of configuration	466
Consistent Interfaces	466
Consistent Exception Hierarchy	466
21.2. Marshaller and Unmarshaller	466
Marshaller	466
Unmarshaller	467
XmlMappingException	468
21.3. Using Marshaller and Unmarshaller	468
21.4. XML Schema-based Configuration	470
21.5. JAXB	470
Jaxb2Marshaller	470
XML Schema-based Configuration	471
21.6. Castor	471
CastorMarshaller	471
Mapping	472
XML Schema-based Configuration	472
21.7. XMLBeans	473
XmlBeansMarshaller	473
XML Schema-based Configuration	473
21.8. JiBX	473
JibxMarshaller	474
XML Schema-based Configuration	474
21.9. XStream	474
XStreamMarshaller	474
VI. The Web	476
22. Web MVC framework	477
22.1. Introduction to Spring Web MVC framework	477
Features of Spring Web MVC	477
Pluggability of other MVC implementations	479
22.2. The DispatcherServlet	479
Special Bean Types In the WebApplicationContext	483
Default DispatcherServlet Configuration	484
DispatcherServlet Processing Sequence	484
22.3. Implementing Controllers	486
Defining a controller with @Controller	486
Mapping Requests With @RequestMapping	487
Composed @RequestMapping Variants	488
@Controller and AOP Proxying	489
New Support Classes for @RequestMapping methods in Spring MVC 3.1..  489 URI Template Patterns	490
URI Template Patterns with Regular Expressions	491
Path Patterns	491
Path Pattern Comparison	492
Path Patterns with Placeholders	492
Suffix Pattern Matching	492
Suffix Pattern Matching and RFD	492
Matrix Variables	493
Consumable Media Types	495
Producible Media Types	495
Request Parameters and Header Values	496
HTTP HEAD and HTTP OPTIONS	496
Defining @RequestMapping handler methods	497
Supported method argument types	497
Supported method return types	499
Binding request parameters to method parameters with @RequestParam... 500 Mapping the request body with the @RequestBody annotation	501
Mapping the response body with the @ResponseBody annotation	502
Creating REST Controllers with the @RestController annotation	503
Using HttpEntity	503
Using @ModelAttribute on a method	503
Using @ModelAttribute on a method argument	504
Using @SessionAttributes to store model attributes in the HTTP session between requests	506
Using @SessionAttribute to access pre-existing global session attributes	507
Using @RequestAttribute to access request attributes	507
Working with "application/x-www-form-urlencoded" data	507
Mapping cookie values with the @CookieValue annotation	508
Mapping request header attributes with the @RequestHeader annotation... 508 Method Parameters And Type Conversion	509
Customizing WebDataBinder initialization	509
Advising controllers with @ControllerAdvice and @RestControllerAdvice	510
Jackson Serialization View Support	511
Jackson JSONP Support	512
Asynchronous Request Processing	513
Exception Handling for Async Requests	514
Intercepting Async Requests	515
HTTP Streaming	515
HTTP Streaming With Server-Sent Events	515
HTTP Streaming Directly To The OutputStream	516
Configuring Asynchronous Request Processing	516
Testing Controllers	517
22.4. Handler mappings	517
Intercepting requests with a HandlerInterceptor	518
22.5. Resolving views	520
Resolving views with the ViewResolver interface	520
Chaining ViewResolvers	522
Redirecting to Views	522
RedirectView	523
The redirect: prefix	524
The forward: prefix	524
ContentNegotiatingViewResolver	524
22.6. Using flash attributes	526
22.7. Building URIs	527
Building URIs to Controllers and methods	528
Building URIs to Controllers and methods from views	529
22.8. Using locales	530
Obtaining Time Zone Information	530
AcceptHeaderLocaleResolver	530
CookieLocaleResolver	530
SessionLocaleResolver	531
LocaleChangeInterceptor	531
22.9. Using themes	531
Overview of themes	531
Defining themes	532
Theme resolvers	532
22.10. Spring's multipart (file upload) support	533
Introduction	533
Using a MultipartResolver with Commons FileUpload	533
Using a MultipartResolver with Servlet 3.0	533
Handling a file upload in a form	534
Handling a file upload request from programmatic clients	535
22.11. Handling exceptions	536
HandlerExceptionResolver	536
@ExceptionHandler	536
Handling Standard Spring MVC Exceptions	537
Annotating Business Exceptions With @ResponseStatus	538
Customizing the Default Servlet Container Error Page	538
22.12. Web Security	539
22.13. Convention over configuration support	539
The Controller ControllerClassNameHandlerMapping	539
The Model ModelMap (ModelAndView)	540
The View - RequestToViewNameTranslator	541
22.14. HTTP caching support	542
Cache-Control HTTP header	543
HTTP caching support for static resources	543
Support for the Cache-Control, ETag and Last-Modified response headers in Controllers	544
Shallow ETag support	545
22.15. Code-based Servlet container initialization	546
22.16. Configuring Spring MVC	547
Enabling the MVC Java Config or the MVC XML Namespace	548
Customizing the Provided Configuration	549
Conversion and Formatting	550
Validation	551
Interceptors	552
Content Negotiation	553
View Controllers	554
View Resolvers	554
Serving of Resources	555
Falling Back On the "Default" Servlet To Serve Resources	558
Path Matching	559
Message Converters	560
Advanced Customizations with MVC Java Config	561
Advanced Customizations with the MVC Namespace	562
23. View technologies	563
23.1. Introduction	563
23.2. Thymeleaf	563
23.3. Groovy Markup Templates	563
Configuration	563
Example	564
23.4. Velocity & FreeMarker	564
Dependencies	564
Context configuration	564
Creating templates	565
Advanced configuration	565
velocity.properties	565
FreeMarker	566
Bind support and form handling	566
The bind macros	566
Simple binding	567
Form input generation macros	567
HTML escaping and XHTML compliance	571
23.5. JSP & JSTL	571
View resolvers	572
'Plain-old' JSPs versus JSTL	572
Additional tags facilitating development	572
Using Spring's form tag library	572
Configuration	573
The form tag	573
The input tag	574
The checkbox tag	574
The checkboxes tag	576
The radiobutton tag	577
The radiobuttons tag	577
The password tag	577
The select tag	577
The option tag	578
The options tag	578
The textarea tag	579
The hidden tag	579
The errors tag	579
HTTP Method Conversion	581
HTML5 Tags	582
23.6. Script templates	582
Dependencies	583
How to integrate script based templating	583
23.7. XML Marshalling View	585
23.8. Tiles	585
Dependencies	585
How to integrate Tiles	585
UrlBasedViewResolver	586
ResourceBundleViewResolver	586
SimpleSpringPreparerFactory and SpringBeanPreparerFactory	587
23.9. XSLT	587
My First Words	588
Bean definitions	588
Standard MVC controller code	588
Document transformation	589
23.10. Document views (PDF/Excel)	589
Introduction	589
Configuration and setup	590
Document view definitions	590
Controller code	590
Subclassing for Excel views	590
Subclassing for PDF views	592
23.11. JasperReports	592
Dependencies	592
Configuration	592
Configuring the ViewResolver	593
Configuring the Views	593
About Report Files	593
Using JasperReportsMultiFormatView	593
Populating the ModelAndView	594
Working with Sub-Reports	595
Configuring Sub-Report Files	595
Configuring Sub-Report Data Sources	596
Configuring Exporter Parameters	596
23.12. Feed Views	597
23.13. JSON Mapping View	597
23.14. XML Mapping View	598
24. Integrating with other web frameworks	599
24.1. Introduction	599
24.2. Common configuration	600
24.3. JavaServer Faces 1.2	601
SpringBeanFacesELResolver (JSF 1.2+)	601
FacesContextUtils	601
24.4. Apache Struts 2.x	601
24.5. Tapestry 5.x	602
24.6. Further Resources	602
25. Portlet MVC Framework	603
25.1. Introduction	603
Controllers - The C in MVC	604
Views - The V in MVC	604
Web-scoped beans	604
25.2. The DispatcherPortlet	604
25.3. The ViewRendererServlet	606
25.4. Controllers	607
AbstractController and PortletContentGenerator	608
Other simple controllers	609
Command Controllers	609
PortletWrappingController	610
25.5. Handler mappings	610
PortletModeHandlerMapping	611
ParameterHandlerMapping	611
PortletModeParameterHandlerMapping	612
Adding HandlerInterceptors	612
HandlerInterceptorAdapter	613
ParameterMappingInterceptor	613
25.6. Views and resolving them	613
25.7. Multipart (file upload) support	613
Using the PortletMultipartResolver	614
Handling a file upload in a form	614
25.8. Handling exceptions	618
25.9. Annotation-based controller configuration	618
Setting up the dispatcher for annotation support	618
Defining a controller with @Controller	619
Mapping requests with @RequestMapping	619
Supported handler method arguments	621
Binding request parameters to method parameters with @RequestParam	623
Providing a link to data from the model with @ModelAttribute	623
Specifying attributes to store in a Session with @SessionAttributes	624
Customizing WebDataBinder initialization	624
Customizing data binding with @InitBinder	624
Configuring a custom WebBindingInitializer	625
25.10. Portlet application deployment	625
26. WebSocket Support	626
26.1. Introduction	626
WebSocket Fallback Options	626
A Messaging Architecture	627
Sub-Protocol Support in WebSocket	627
Should I Use WebSocket?	627
26.2. WebSocket API	628
Create and Configure a WebSocketHandler	628
Customizing the WebSocket Handshake	629
WebSocketHandler Decoration	630
Deployment Considerations	630
Configuring the WebSocket Engine	631
Configuring allowed origins	633
26.3. SockJS Fallback Options	634
Overview of SockJS	634
Enable SockJS	635
HTTP Streaming in IE 8, 9: Ajax/XHR vs IFrame	636
Heartbeat Messages	637
Servlet 3 Async Requests	637
CORS Headers for SockJS	638
SockJS Client	638
26.4. STOMP Over WebSocket Messaging Architecture	640
Overview of STOMP	640
Enable STOMP over WebSocket	641
Flow of Messages	643
Annotation Message Handling	645
Sending Messages	647
Simple Broker	647
Full-Featured Broker	647
Connections To Full-Featured Broker	649
Using Dot as Separator in @MessageMapping Destinations	649
Authentication	650
Token-based Authentication	651
User Destinations	652
Listening To ApplicationContext Events and Intercepting Messages	654
STOMP Client	655
WebSocket Scope	656
Configuration and Performance	657
Runtime Monitoring	660
Testing Annotated Controller Methods	661
27. CORS Support	662
27.1. Introduction	662
27.2. Controller method CORS configuration	662
27.3. Global CORS configuration	663
JavaConfig	663
XML namespace	664
27.4. Advanced Customization	664
27.5. Filter based CORS support	664
VII. Integration	666
28. Remoting and web services using Spring	667
28.1. Introduction	667
28.2. Exposing services using RMI	668
Exporting the service using the RmiServiceExporter	668
Linking in the service at the client	669
28.3. Using Hessian or Burlap to remotely call services via HTTP	669
Wiring up the DispatcherServlet for Hessian and co.	669
Exposing your beans by using the HessianServiceExporter	670
Linking in the service on the client	670
Using Burlap	671
Applying HTTP basic authentication to a service exposed through Hessian or
Burlap	671
28.4. Exposing services using HTTP invokers	671
Exposing the service object	671
Linking in the service at the client	672
28.5. Web services	673
Exposing servlet-based web services using JAX-WS	673
Exporting standalone web services using JAX-WS	674
Exporting web services using the JAX-WS RI's Spring support	675
Accessing web services using JAX-WS	675
28.6. JMS	676
Server-side configuration	677
Client-side configuration	677
28.7. AMQP	678
28.8. Auto-detection is not implemented for remote interfaces	678
28.9. Considerations when choosing a technology	678
28.10. Accessing RESTful services on the Client	679
RestTemplate	679
Working with the URI	682
Dealing with request and response headers	683
Jackson JSON Views support	683
HTTP Message Conversion	683
StringHttpMessageConverter	684
FormHttpMessageConverter	684
ByteArrayHttpMessageConverter	684
MarshallingHttpMessageConverter	684
MappingJackson2HttpMessageConverter	684
MappingJackson2XmlHttpMessageConverter	685
SourceHttpMessageConverter	685
BufferedImageHttpMessageConverter	685
Async RestTemplate	685
29. Enterprise JavaBeans (EJB) integration	687
29.1. Introduction	687
29.2. Accessing EJBs	687
Concepts	687
Accessing local SLSBs	687
Accessing remote SLSBs	689
Accessing EJB 2.x SLSBs versus EJB 3 SLSBs	689
29.3. Using Spring's EJB implementation support classes	690
EJB 3 injection interceptor	690
30. JMS (Java Message Service)	691
30.1. Introduction	691
30.2. Using Spring JMS	691
JmsTemplate	691
Connections	692
Caching Messaging Resources	692
SingleConnectionFactory	693
CachingConnectionFactory	693
Destination Management	693
Message Listener Containers	694
SimpleMessageListenerContainer	694
DefaultMessageListenerContainer	695
Transaction management	695
30.3. Sending a Message	696
Using Message Converters	697
SessionCallback and ProducerCallback	698
30.4. Receiving a message	698
Synchronous Reception	698
Asynchronous Reception - Message-Driven POJOs	698
the SessionAwareMessageListener interface	699
the MessageListenerAdapter	699
Processing messages within transactions	701
30.5. Support for JCA Message Endpoints	702
30.6. Annotation-driven listener endpoints	703
Enable listener endpoint annotations	704
Programmatic endpoints registration	704
Annotated endpoint method signature	705
Response management	706
30.7. JMS namespace support	707
31. JMX	712
31.1. Introduction	712
31.2. Exporting your beans to JMX	712
Creating an MBeanServer	714
Reusing an existing MBeanServer	714
Lazy-initialized MBeans	715
Automatic registration of MBeans	715
Controlling the registration behavior	715
31.3. Controlling the management interface of your beans	716
the MBeanInfoAssembler Interface	717
Using Source-Level Metadata (Java annotations)	717
Source-Level Metadata Types	719
the AutodetectCapableMBeanInfoAssembler interface	720
Defining management interfaces using Java interfaces	721
Using MethodNameBasedMBeanInfoAssembler	722
31.4. Controlling the ObjectNames for your beans	723
Reading ObjectNames from Properties	723
Using the MetadataNamingStrategy	724
Configuring annotation based MBean export	724
31.5. JSR-160 Connectors	725
Server-side Connectors	725
Client-side Connectors	726
JMX over Burlap/Hessian/SOAP	726
31.6. Accessing MBeans via Proxies	726
31.7. Notifications	727
Registering Listeners for Notifications	727
Publishing Notifications	730
31.8. Further Resources	731
32. JCA CCI	733
32.1. Introduction	733
32.2. Configuring CCI	733
Connector configuration	733
ConnectionFactory configuration in Spring	734
Configuring CCI connections	734
Using a single CCI connection	735
32.3. Using Spring's CCI access support	736
Record conversion	736
the CciTemplate	736
DAO support	738
Automatic output record generation	739
Summary	739
Using a CCI Connection and Interaction directly	740
Example for CciTemplate usage	740
32.4. Modeling CCI access as operation objects	742
MappingRecordOperation	742
MappingCommAreaOperation	743
Automatic output record generation	744
Summary	744
Example for MappingRecordOperation usage	744
Example for MappingCommAreaOperation usage	746
32.5. Transactions	748
33. Email	749
33.1. Introduction	749
33.2. Usage	749
Basic MailSender and SimpleMailMessage usage	750
Using the JavaMailSender and the MimeMessagePreparator	750
33.3. Using the JavaMail MimeMessageHelper	751
Sending attachments and inline resources	752
Attachments	752
Inline resources	752
Creating email content using a templating library	753
A Velocity-based example	753
34. Task Execution and Scheduling	756
34.1. Introduction	756
34.2. The Spring TaskExecutor abstraction	756
TaskExecutor types	756
Using a TaskExecutor	757
34.3. The Spring TaskScheduler abstraction	758
the Trigger interface	759
Trigger implementations	759
TaskScheduler implementations	760
34.4. Annotation Support for Scheduling and Asynchronous Execution	760
Enable scheduling annotations	760
The @Scheduled annotation	761
The @Async annotation	762
Executor qualification with @Async	763
Exception management with @Async	763
34.5. The task namespace	764
The 'scheduler' element	764
The 'executor' element	764
The 'scheduled-tasks' element	765
34.6. Using the Quartz Scheduler	766
Using the JobDetailFactoryBean	766
Using the MethodInvokingJobDetailFactoryBean	767
Wiring up jobs using triggers and the SchedulerFactoryBean	767
35. Dynamic language support	769
35.1. Introduction	769
35.2. A first example	769
35.3. Defining beans that are backed by dynamic languages	771
Common concepts	771
The <lang:language/> element	772
Refreshable beans	772
Inline dynamic language source files	774
Understanding Constructor Injection in the context of dynamic-language- backed beans	775
JRuby beans	776
Groovy beans	777
Customizing Groovy objects via a callback	778
BeanShell beans	780
35.4. Scenarios	781
Scripted Spring MVC Controllers	781
Scripted Validators	782
35.5. Bits and bobs	782
AOP - advising scripted beans	782
Scoping	783
35.6. Further Resources	783
36. Cache Abstraction	784
36.1. Introduction	784
36.2. Understanding the cache abstraction	784
36.3. Declarative annotation-based caching	785
@Cacheable annotation	785
Default Key Generation	786
Custom Key Generation Declaration	786
Default Cache Resolution	787
Custom cache resolution	787
Synchronized caching	788
Conditional caching	788
Available caching SpEL evaluation context	789
@CachePut annotation	790
@CacheEvict annotation	790
@Caching annotation	791
@CacheConfig annotation	791
Enable caching annotations	792
Using custom annotations	794
36.4. JCache (JSR-107) annotations	795
Features summary	795
Enabling JSR-107 support	796
36.5. Declarative XML-based caching	797
36.6. Configuring the cache storage	797
JDK ConcurrentMap-based Cache	798
Ehcache-based Cache	798
Caffeine Cache	798
Guava Cache	799
GemFire-based Cache	799
JSR-107 Cache	799
Dealing with caches without a backing store	800
36.7. Plugging-in different back-end caches	800
36.8. How can I set the TTL/TTI/Eviction policy/XXX feature?	800
VIII. Appendices	801
37. Migrating to Spring Framework 4.x	802
38. Spring Annotation Programming Model	803
39. Classic Spring Usage	804
39.1. Classic ORM usage	804
Hibernate	804
The HibernateTemplate	804
Implementing Spring-based DAOs without callbacks	805
39.2. JMS Usage	806
JmsTemplate	807
Asynchronous Message Reception	807
Connections	807
Transaction Management	807
40. Classic Spring AOP Usage	808
40.1. Pointcut API in Spring	808
Concepts	808
Operations on pointcuts	809
AspectJ expression pointcuts	809
Convenience pointcut implementations	809
Static pointcuts	809
Dynamic pointcuts	810
Pointcut superclasses	811
Custom pointcuts	811
40.2. Advice API in Spring	811
Advice lifecycles	811
Advice types in Spring	812
Interception around advice	812
Before advice	812
Throws advice	813
After Returning advice	814
Introduction advice	815
40.3. Advisor API in Spring	817
40.4. Using the ProxyFactoryBean to create AOP proxies	818
Basics	818
JavaBean properties	818
JDK- and CGLIB-based proxies	819
Proxying interfaces	820
Proxying classes	822
Using 'global' advisors	823
40.5. Concise proxy definitions	823
40.6. Creating AOP proxies programmatically with the ProxyFactory	824
40.7. Manipulating advised objects	824
40.8. Using the "autoproxy" facility	826
Autoproxy bean definitions	826
BeanNameAutoProxyCreator	826
DefaultAdvisorAutoProxyCreator	827
AbstractAdvisorAutoProxyCreator	828
Using metadata-driven auto-proxying	828
40.9. Using TargetSources	830
Hot swappable target sources	830
Pooling target sources	831
Prototype target sources	832
ThreadLocal target sources	832
40.10. Defining new Advice types	833
40.11. Further resources	833
41. XML Schema-based configuration	834
41.1. Introduction	834
41.2. XML Schema-based configuration	834
Referencing the schemas	834
the util schema	835
<util:constant/>	836
<util:property-path/>	837
<util:properties/>	839
<util:list/>	839
<util:map/>	840
<util:set/>	840
the jee schema	841
<jee:jndi-lookup/> (simple)	841
<jee:jndi-lookup/> (with single JNDI environment setting)	842
<jee:jndi-lookup/> (with multiple JNDI environment settings)	842
<jee:jndi-lookup/> (complex)	842
<jee:local-slsb/> (simple)	843
<jee:local-slsb/> (complex)	843
<jee:remote-slsb/>	843
the lang schema	844
the jms schema	844
the tx (transaction) schema	845
the aop schema	845
the context schema	846
<property-placeholder/>	846
<annotation-config/>	846
<component-scan/>	846
<load-time-weaver/>	847
<spring-configured/>	847
<mbean-export/>	847
the tool schema	847
the jdbc schema	847
the cache schema	847
the beans schema	848
42. Extensible XML authoring	849
42.1. Introduction	849
42.2. Authoring the schema	849
42.3. Coding a NamespaceHandler	850
42.4. BeanDefinitionParser	851
42.5. Registering the handler and the schema	852
'META-INF/spring.handlers'	852
'META-INF/spring.schemas'	853
42.6. Using a custom extension in your Spring XML configuration	853
42.7. Meatier examples	853
Nesting custom tags within custom tags	853
Custom attributes on 'normal' elements	857
42.8. Further Resources	859
43. spring JSP Tag Library	860
43.1. Introduction	860
43.2. The argument tag	860
43.3. The bind tag	860
43.4. The escapeBody tag	861
43.5. The eval tag	861
43.6. The hasBindErrors tag	862
43.7. The htmlEscape tag	862
43.8. The message tag	862
43.9. The nestedPath tag	863
43.10. The param tag	864
43.11. The theme tag	864
43.12. The transform tag	865
43.13. The url tag	865
44. spring-form JSP Tag Library	867
44.1. Introduction	867
44.2. The button tag	867
44.3. The checkbox tag	868
44.4. The checkboxes tag	869
44.5. The errors tag	870
44.6. The form tag	871
44.7. The hidden tag	872
44.8. The input tag	873
44.9. The label tag	874
44.10. The option tag	875
44.11. The options tag	876
44.12. The password tag	877
44.13. The radiobutton tag	878
44.14. The radiobuttons tag	880
44.15. The select tag	881
44.16. The textarea tag	882





Part I. Overview of Spring Framework
The Spring Framework is a lightweight solution and a potential one-stop-shop for building your enterprise-ready applications. However, Spring is modular, allowing you to use only those parts that you need, without having to bring in the rest. You can use the IoC container, with any web framework on top, but you can also use only the Hibernate integration code or the JDBC abstraction layer. The Spring Framework supports declarative transaction management, remote access to your logic through RMI or web services, and various options for persisting your data. It offers a full-featured MVC framework, and enables you to integrate AOP transparently into your software.

Spring is designed to be non-intrusive, meaning that your domain logic code generally has no dependencies on the framework itself. In your integration layer (such as the data access layer), some dependencies on the data access technology and the Spring libraries will exist. However, it should be easy to isolate these dependencies from the rest of your code base.

This document is a reference guide to Spring Framework features. If you have any requests, comments, or questions on this document, please post them on the user mailing list. Questions on the Framework itself should be asked on StackOverflow (see https://spring.io/questions).














































1. Getting Started with Spring
This reference guide provides detailed information about the Spring Framework. It provides comprehensive documentation for all features, as well as some background about the underlying concepts (such as "Dependency Injection") that Spring has embraced.

If you are just getting started with Spring, you may want to begin using the Spring Framework by creating a Spring Boot based application. Spring Boot provides a quick (and opinionated) way to create a production-ready Spring based application. It is based on the Spring Framework, favors convention over configuration, and is designed to get you up and running as quickly as possible.

You can use start.spring.io to generate a basic project or follow one of the "Getting Started" guides like the Getting Started Building a RESTful Web Service one. As well as being easier to digest, these guides are very task focused, and most of them are based on Spring Boot. They also cover other projects from the Spring portfolio that you might want to consider when solving a particular problem.



2. Introduction to the Spring Framework
The Spring Framework is a Java platform that provides comprehensive infrastructure support for developing Java applications. Spring handles the infrastructure so you can focus on your application.

Spring enables you to build applications from "plain old Java objects" (POJOs) and to apply enterprise services non-invasively to POJOs. This capability applies to the Java SE programming model and to full and partial Java EE.

Examples of how you, as an application developer, can benefit from the Spring platform:

• Make a Java method execute in a database transaction without having to deal with transaction APIs.

• Make a local Java method a remote procedure without having to deal with remote APIs.

• Make a local Java method a management operation without having to deal with JMX APIs.

• Make a local Java method a message handler without having to deal with JMS APIs.

2.1 Dependency Injection and Inversion of Control

A Java application - a loose term that runs the gamut from constrained, embedded applications to n-tier, server-side enterprise applications - typically consists of objects that collaborate to form the application proper. Thus the objects in an application have dependencies on each other.

Although the Java platform provides a wealth of application development functionality, it lacks the means to organize the basic building blocks into a coherent whole, leaving that task to architects and developers. Although you can use design patterns such as Factory, Abstract Factory, Builder, Decorator, and Service Locator to compose the various classes and object instances that make up an application, these patterns are simply that: best practices given a name, with a description of what the pattern does, where to apply it, the problems it addresses, and so forth. Patterns are formalized best practices that you must implement yourself in your application.

The Spring Framework Inversion of Control (IoC) component addresses this concern by providing a formalized means of composing disparate components into a fully working application ready for use. The Spring Framework codifies formalized design patterns as first-class objects that you can integrate into your own application(s). Numerous organizations and institutions use the Spring Framework in this manner to engineer robust, maintainable applications.



2.2 Modules

The Spring Framework consists of features organized into about 20 modules. These modules are grouped into Core Container, Data Access/Integration, Web, AOP (Aspect Oriented Programming), Instrumentation, Messaging, and Test, as shown in the following diagram.





Figure 2.1. Overview of the Spring Framework

The following sections list the available modules for each feature along with their artifact names and the topics they cover. Artifact names correlate to artifact IDs used in Dependency Management tools.
Core Container

The Core Container consists of the spring-core, spring-beans, spring-context, spring- context-support, and spring-expression (Spring Expression Language) modules.
The spring-core and spring-beans modules provide the fundamental parts of the framework, including the IoC and Dependency Injection features. The BeanFactory is a sophisticated implementation of the factory pattern. It removes the need for programmatic singletons and allows you to decouple the configuration and specification of dependencies from your actual program logic.

The Context (spring-context) module builds on the solid base provided by the Core and Beans modules: it is a means to access objects in a framework-style manner that is similar to a JNDI registry. The Context module inherits its features from the Beans module and adds support for internationalization (using, for example, resource bundles), event propagation, resource loading, and the transparent creation of contexts by, for example, a Servlet container. The Context module also supports Java EE features such as EJB, JMX, and basic remoting. The ApplicationContext interface is the focal point of the Context module. spring-context-support provides support for integrating common third-party libraries into a Spring application context for caching (EhCache, Guava, JCache), mailing (JavaMail), scheduling (CommonJ, Quartz) and template engines (FreeMarker, JasperReports, Velocity).

The spring-expression module provides a powerful Expression Language for querying and manipulating an object graph at runtime. It is an extension of the unified expression language (unified EL) as specified in the JSP 2.1 specification. The language supports setting and getting property values, property assignment, method invocation, accessing the content of arrays, collections and indexers,



logical and arithmetic operators, named variables, and retrieval of objects by name from Spring's IoC container. It also supports list projection and selection as well as common list aggregations.

AOP and Instrumentation

The spring-aop module provides an AOP Alliance-compliant aspect-oriented programming implementation allowing you to define, for example, method interceptors and pointcuts to cleanly decouple code that implements functionality that should be separated. Using source-level metadata functionality, you can also incorporate behavioral information into your code, in a manner similar to that of .NET attributes.

The separate spring-aspects module provides integration with AspectJ.

The spring-instrument module provides class instrumentation support and classloader implementations to be used in certain application servers. The spring-instrument-tomcat module contains Spring's instrumentation agent for Tomcat.

Messaging

Spring Framework 4 includes a spring-messaging module with key abstractions from the Spring Integration project such as Message, MessageChannel, MessageHandler, and others to serve as a foundation for messaging-based applications. The module also includes a set of annotations for mapping messages to methods, similar to the Spring MVC annotation based programming model.

Data Access/Integration

The Data Access/Integration layer consists of the JDBC, ORM, OXM, JMS, and Transaction modules.

The spring-jdbc module provides a JDBC-abstraction layer that removes the need to do tedious JDBC coding and parsing of database-vendor specific error codes.

The spring-tx module supports programmatic and declarative transaction management for classes that implement special interfaces and for all your POJOs (Plain Old Java Objects).

The spring-orm module provides integration layers for popular object-relational mapping APIs, including JPA, JDO, and Hibernate. Using the spring-orm module you can use all of these O/R- mapping frameworks in combination with all of the other features Spring offers, such as the simple declarative transaction management feature mentioned previously.

The spring-oxm module provides an abstraction layer that supports Object/XML mapping implementations such as JAXB, Castor, XMLBeans, JiBX and XStream.

The spring-jms module (Java Messaging Service) contains features for producing and consuming messages. Since Spring Framework 4.1, it provides integration with the spring-messaging module.

Web

The Web layer consists of the spring-web, spring-webmvc, spring-websocket, and spring- webmvc-portlet modules.

The spring-web module provides basic web-oriented integration features such as multipart file upload functionality and the initialization of the IoC container using Servlet listeners and a web-oriented application context. It also contains an HTTP client and the web-related parts of Spring's remoting support.



The spring-webmvc module (also known as the Web-Servlet module) contains Spring's model- view-controller (MVC) and REST Web Services implementation for web applications. Spring's MVC framework provides a clean separation between domain model code and web forms and integrates with all of the other features of the Spring Framework.

The spring-webmvc-portlet module (also known as the Web-Portlet module) provides the MVC implementation to be used in a Portlet environment and mirrors the functionality of the spring-webmvc module.

Test

The spring-test module supports the unit testing and integration testing of Spring components with JUnit or TestNG. It provides consistent loading of Spring ApplicationContexts and caching of those contexts. It also provides mock objects that you can use to test your code in isolation.

2.3 Usage scenarios

The building blocks described previously make Spring a logical choice in many scenarios, from embedded applications that run on resource-constrained devices to full-fledged enterprise applications that use Spring's transaction management functionality and web framework integration.


Figure 2.2. Typical full-fledged Spring web application

Spring's declarative transaction management features make the web application fully transactional, just as it would be if you used EJB container-managed transactions. All your custom business logic can be implemented with simple POJOs and managed by Spring's IoC container. Additional services include support for sending email and validation that is independent of the web layer, which lets you choose where to execute validation rules. Spring's ORM support is integrated with JPA, Hibernate and JDO; for example, when using Hibernate, you can continue to use your existing mapping files and standard Hibernate SessionFactory configuration. Form controllers seamlessly integrate the web-



layer with the domain model, removing the need for ActionForms or other classes that transform HTTP parameters to values for your domain model.



Figure 2.3. Spring middle-tier using a third-party web framework

Sometimes circumstances do not allow you to completely switch to a different framework. The Spring Framework does not force you to use everything within it; it is not an all-or-nothing solution. Existing front-ends built with Struts, Tapestry, JSF or other UI frameworks can be integrated with a Spring- based middle-tier, which allows you to use Spring transaction features. You simply need to wire up your business logic using an ApplicationContext and use a WebApplicationContext to integrate your web layer.






Figure 2.4. Remoting usage scenario

When you need to access existing code through web services, you can use Spring's Hessian-, Burlap-, Rmi- or JaxRpcProxyFactory classes. Enabling remote access to existing applications is not difficult.


Figure 2.5. EJBs - Wrapping existing POJOs

The Spring Framework also provides an access and abstraction layer for Enterprise JavaBeans, enabling you to reuse your existing POJOs and wrap them in stateless session beans for use in scalable, fail-safe web applications that might need declarative security.



Dependency Management and Naming Conventions

Dependency management and dependency injection are different things. To get those nice features of Spring into your application (like dependency injection) you need to assemble all the libraries needed (jar files) and get them onto your classpath at runtime, and possibly at compile time. These dependencies are not virtual components that are injected, but physical resources in a file system (typically). The process of dependency management involves locating those resources, storing them and adding them to classpaths. Dependencies can be direct (e.g. my application depends on Spring at runtime), or indirect (e.g. my application depends on commons-dbcp which depends on commons-pool). The indirect dependencies are also known as "transitive" and it is those dependencies that are hardest to identify and manage.
If you are going to use Spring you need to get a copy of the jar libraries that comprise the pieces of Spring that you need. To make this easier Spring is packaged as a set of modules that separate the dependencies as much as possible, so for example if you don't want to write a web application you don't need the spring-web modules. To refer to Spring library modules in this guide we use a shorthand naming convention spring-* or spring-*.jar, where * represents the short name for the module (e.g. spring-core, spring-webmvc, spring-jms, etc.). The actual jar file name that you use is normally the module name concatenated with the version number (e.g. spring-core-4.3.7.RELEASE.jar).
Each release of the Spring Framework will publish artifacts to the following places:

• Maven Central, which is the default repository that Maven queries, and does not require any special configuration to use. Many of the common libraries that Spring depends on also are available from Maven Central and a large section of the Spring community uses Maven for dependency management, so this is convenient for them. The names of the jars here are in the form spring-*-
<version>.jar and the Maven groupId is org.springframework.

• In a public Maven repository hosted specifically for Spring. In addition to the final GA releases, this repository also hosts development snapshots and milestones. The jar file names are in the same form as Maven Central, so this is a useful place to get development versions of Spring to use with other libraries deployed in Maven Central. This repository also contains a bundle distribution zip file that contains all Spring jars bundled together for easy download.
So the first thing you need to decide is how to manage your dependencies: we generally recommend the use of an automated system like Maven, Gradle or Ivy, but you can also do it manually by downloading all the jars yourself.
You will find bellow the list of Spring artifacts. For a more complete description of each modules, see Section 2.2, "Modules".
Table 2.1. Spring Framework Artifacts

GroupIdArtifactIdDescriptionorg.springframeworkspring-aopProxy-based AOP supportorg.springframeworkspring-aspectsAspectJ based aspectsorg.springframeworkspring-beansBeans support, including Groovyorg.springframeworkspring-contextApplication context runtime, including scheduling and remoting abstractions


GroupIdArtifactIdDescriptionorg.springframeworkspring-context-supportSupport classes for integrating common third-party libraries into a Spring application contextorg.springframeworkspring-coreCore utilities, used by many other Spring modulesorg.springframeworkspring-expressionSpring Expression Language (SpEL)org.springframeworkspring-instrumentInstrumentation agent for JVM bootstrappingorg.springframeworkspring-instrument-tomcatInstrumentation agent for Tomcatorg.springframeworkspring-jdbcJDBC support package, including DataSource setup and JDBC access supportorg.springframeworkspring-jmsJMS support package, including helper classes to send and receive JMS messagesorg.springframeworkspring-messagingSupport for messaging architectures and protocolsorg.springframeworkspring-ormObject/Relational Mapping, including JPA and Hibernate supportorg.springframeworkspring-oxmObject/XML Mappingorg.springframeworkspring-testSupport for unit testing and integration testing Spring componentsorg.springframeworkspring-txTransaction infrastructure, including DAO support and JCA integrationorg.springframeworkspring-webWeb support packages, including client and web remotingorg.springframeworkspring-webmvcREST Web Services and model-view-controller implementation for web applicationsorg.springframeworkspring-webmvc-portletMVC implementation to be used in a Portlet environment


GroupIdArtifactIdDescriptionorg.springframeworkspring-websocketWebSocket and SockJS implementations, including STOMP support
Spring Dependencies and Depending on Spring

Although Spring provides integration and support for a huge range of enterprise and other external tools, it intentionally keeps its mandatory dependencies to an absolute minimum: you shouldn't have to locate and download (even automatically) a large number of jar libraries in order to use Spring for simple use cases. For basic dependency injection there is only one mandatory external dependency, and that is for logging (see below for a more detailed description of logging options).

Next we outline the basic steps needed to configure an application that depends on Spring, first with Maven and then with Gradle and finally using Ivy. In all cases, if anything is unclear, refer to the documentation of your dependency management system, or look at some sample code - Spring itself uses Gradle to manage dependencies when it is building, and our samples mostly use Gradle or Maven.

Maven Dependency Management

If you are using Maven for dependency management you don't even need to supply the logging dependency explicitly. For example, to create an application context and use dependency injection to configure an application, your Maven dependencies will look like this:



That's it. Note the scope can be declared as runtime if you don't need to compile against Spring APIs, which is typically the case for basic dependency injection use cases.

The example above works with the Maven Central repository. To use the Spring Maven repository (e.g. for milestones or developer snapshots), you need to specify the repository location in your Maven configuration. For full releases:



For milestones:





And for snapshots:



Maven "Bill Of Materials" Dependency

It is possible to accidentally mix different versions of Spring JARs when using Maven. For example, you may find that a third-party library, or another Spring project, pulls in a transitive dependency to an older release. If you forget to explicitly declare a direct dependency yourself, all sorts of unexpected issues can arise.

To overcome such problems Maven supports the concept of a "bill of materials" (BOM) dependency. You can import the spring-framework-bom in your dependencyManagement section to ensure that all spring dependencies (both direct and transitive) are at the same version.



An added benefit of using the BOM is that you no longer need to specify the <version> attribute when depending on Spring Framework artifacts:



Gradle Dependency Management

To use the Spring repository with the Gradle build system, include the appropriate URL in the
repositories section:



You can change the repositories URL from /release to /milestone or /snapshot as appropriate. Once a repository has been configured, you can declare dependencies in the usual Gradle way:





Ivy Dependency Management

If you prefer to use Ivy to manage dependencies then there are similar configuration options.

To configure Ivy to point to the Spring repository add the following resolver to your ivysettings.xml:



You can change the root URL from /release/ to /milestone/ or /snapshot/ as appropriate. Once configured, you can add dependencies in the usual way. For example (in ivy.xml):



Distribution Zip Files

Although using a build system that supports dependency management is the recommended way to obtain the Spring Framework, it is still possible to download a distribution zip file.

Distribution zips are published to the Spring Maven Repository (this is just for our convenience, you don't need Maven or any other build system in order to download them).

To download a distribution zip open a web browser to http://repo.spring.io/release/org/springframework/ spring and select the appropriate subfolder for the version that you want. Distribution files end - dist.zip, for example spring-framework-{spring-version}-RELEASE-dist.zip. Distributions are also published for milestones and snapshots.

Logging

Logging is a very important dependency for Spring because a) it is the only mandatory external dependency, b) everyone likes to see some output from the tools they are using, and c) Spring integrates with lots of other tools all of which have also made a choice of logging dependency. One of the goals of an application developer is often to have unified logging configured in a central place for the whole application, including all external components. This is more difficult than it might have been since there are so many choices of logging framework.

The mandatory logging dependency in Spring is the Jakarta Commons Logging API (JCL). We compile against JCL and we also make JCL Log objects visible for classes that extend the Spring Framework. It's important to users that all versions of Spring use the same logging library: migration is easy because backwards compatibility is preserved even with applications that extend Spring. The way we do this is to make one of the modules in Spring depend explicitly on commons-logging (the canonical implementation of JCL), and then make all the other modules depend on that at compile time. If you are using Maven for example, and wondering where you picked up the dependency on commons-logging, then it is from Spring and specifically from the central module called spring-core.
The nice thing about commons-logging is that you don't need anything else to make your application work. It has a runtime discovery algorithm that looks for other logging frameworks in well known places



on the classpath and uses one that it thinks is appropriate (or you can tell it which one if you need to). If nothing else is available you get pretty nice looking logs just from the JDK (java.util.logging or JUL for short). You should find that your Spring application works and logs happily to the console out of the box in most situations, and that's important.
Not Using Commons Logging

Unfortunately, the runtime discovery algorithm in commons-logging, while convenient for the end- user, is problematic. If we could turn back the clock and start Spring now as a new project it would use a different logging dependency. The first choice would probably be the Simple Logging Facade for Java ( SLF4J), which is also used by a lot of other tools that people use with Spring inside their applications.

There are basically two ways to switch off commons-logging:

1. Exclude the dependency from the spring-core module (as it is the only module that explicitly depends on commons-logging)
2. Depend on a special commons-logging dependency that replaces the library with an empty jar (more details can be found in the SLF4J FAQ)

To exclude commons-logging, add the following to your dependencyManagement section:



Now this application is probably broken because there is no implementation of the JCL API on the classpath, so to fix it a new one has to be provided. In the next section we show you how to provide an alternative implementation of JCL using SLF4J as an example.
Using SLF4J

SLF4J is a cleaner dependency and more efficient at runtime than commons-logging because it uses compile-time bindings instead of runtime discovery of the other logging frameworks it integrates. This also means that you have to be more explicit about what you want to happen at runtime, and declare it or configure it accordingly. SLF4J provides bindings to many common logging frameworks, so you can usually choose one that you already use, and bind to that for configuration and management.

SLF4J provides bindings to many common logging frameworks, including JCL, and it also does the reverse: bridges between other logging frameworks and itself. So to use SLF4J with Spring you need to replace the commons-logging dependency with the SLF4J-JCL bridge. Once you have done that then logging calls from within Spring will be translated into logging calls to the SLF4J API, so if other libraries in your application use that API, then you have a single place to configure and manage logging.

A common choice might be to bridge Spring to SLF4J, and then provide explicit binding from SLF4J to Log4j. You need to supply 4 dependencies (and exclude the existing commons-logging): the bridge, the SLF4J API, the binding to Log4j, and the Log4j implementation itself. In Maven you would do that like this





That might seem like a lot of dependencies just to get some logging. Well it is, but it is optional, and it should behave better than the vanilla commons-logging with respect to classloader issues, notably if you are in a strict container like an OSGi platform. Allegedly there is also a performance benefit because the bindings are at compile-time not runtime.

A more common choice amongst SLF4J users, which uses fewer steps and generates fewer dependencies, is to bind directly to Logback. This removes the extra binding step because Logback implements SLF4J directly, so you only need to depend on two libraries not four ( jcl-over-slf4j and logback). If you do that you might also need to exclude the slf4j-api dependency from other external dependencies (not Spring), because you only want one version of that API on the classpath.

Using Log4j

Note

Log4j 1.x is EOL and Log4j 2.3 is the last Java 6 compatible release

Many people use Log4j as a logging framework for configuration and management purposes. It's efficient and well-established, and in fact it's what we use at runtime when we build and test Spring. Spring also provides some utilities for configuring and initializing Log4j, so it has an optional compile-time dependency on Log4j in some modules.

To make Log4j 1 work with the default JCL dependency ( commons-logging) all you need to do is put Log4j on the classpath, and provide it with a configuration file ( log4j.properties or log4j.xml in the root of the classpath). So for Maven users this is your dependency declaration:





And here's a sample log4j.properties for logging to the console:



To use Log4j 2 with JCL, all you need to do is put Log4j on the classpath and provide it with a configuration file (log4j2.xml, log4j2.properties, or other supported configuration formats). For Maven users, the minimal dependencies needed are:



If you also wish to use SLF4J, the following dependencies are also needed:



Here is an example log4j2.xml for logging to the console:





Runtime Containers with Native JCL

Many people  run their Spring  applications  in  a  container  that  itself  provides  an  implementation of JCL. IBM Websphere Application Server (WAS) is the archetype. This often causes problems, and unfortunately there is no silver bullet solution; simply excluding commons-logging from your application is not enough in most situations.

To be clear about this: the problems reported are usually not with JCL per se, or even with commons- logging: rather they are to do with binding commons-logging to another framework (often Log4j). This can fail because commons-logging changed the way they do the runtime discovery in between the older versions (1.0) found in some containers and the modern versions that most people use now (1.1). Spring does not use any unusual parts of the JCL API, so nothing breaks there, but as soon as Spring or your application tries to do any logging you can find that the bindings to Log4j are not working.

In such cases with WAS the easiest thing to do is to invert the class loader hierarchy (IBM calls it "parent last") so that the application controls the JCL dependency, not the container. That option isn't always open, but there are plenty of other suggestions in the public domain for alternative approaches, and your mileage may vary depending on the exact version and feature set of the container.





Part II. What's New in Spring Framework 4.x






























































3. New Features and Enhancements in Spring Framework 4.0
The Spring Framework was first released in 2004; since then there have been significant major revisions: Spring 2.0 provided XML namespaces and AspectJ support; Spring 2.5 embraced annotation-driven configuration; Spring 3.0 introduced a strong Java 5+ foundation across the framework codebase, and features such as the Java-based @Configuration model.

Version 4.0 is the latest major release of the Spring Framework and the first to fully support Java 8 features. You can still use Spring with older versions of Java, however, the minimum requirement has now been raised to Java SE 6. We have also taken the opportunity of a major release to remove many deprecated classes and methods.

A migration guide for upgrading to Spring 4.0 is available on the Spring Framework GitHub Wiki.

3.1 Improved Getting Started Experience

The new spring.io website provides a whole series of "Getting Started" guides to help you learn Spring. You can read more about the guides in the Chapter 1, Getting Started with Spring section in this document. The new website also provides a comprehensive overview of the many additional projects that are released under the Spring umbrella.

If you are a Maven user you may also be interested in the helpful bill of materials POM file that is now published with each Spring Framework release.

3.2 Removed Deprecated Packages and Methods

All deprecated packages, and many deprecated classes and methods have been removed with version
4.0. If you are upgrading from a previous release of Spring, you should ensure that you have fixed any deprecated calls that you were making to outdated APIs.

For a complete set of changes, check out the API Differences Report.

Note that optional third-party dependencies have been raised to a 2010/2011 minimum (i.e. Spring 4 generally only supports versions released in late 2010 or later now): notably, Hibernate 3.6+, EhCache 2.1+, Quartz 1.8+, Groovy 1.8+, and Joda-Time 2.0+. As an exception to the rule, Spring 4 requires the recent Hibernate Validator 4.3+, and support for Jackson has been focused on 2.0+ now (with Jackson 1.8/1.9 support retained for the time being where Spring 3.2 had it; now just in deprecated form).

3.3 Java 8 (as well as 6 and 7)

Spring Framework 4.0 provides support for several Java 8 features. You can make use of lambda expressions and method references with Spring's callback interfaces. There is first-class support for java.time (JSR-310), and several existing annotations have been retrofitted as @Repeatable. You can also use Java 8's parameter name discovery (based on the -parameters compiler flag) as an alternative to compiling your code with debug information enabled.

Spring remains compatible with older versions of Java and the JDK: concretely, Java SE 6 (specifically, a minimum level equivalent to JDK 6 update 18, as released in January 2010) and above are still fully



supported. However, for newly started development projects based on Spring 4, we recommend the use of Java 7 or 8.

3.4 Java EE 6 and 7
Java EE version 6 or above is now considered the baseline for Spring Framework 4, with the JPA 2.0 and Servlet 3.0 specifications being of particular relevance. In order to remain compatible with Google App Engine and older application servers, it is possible to deploy a Spring 4 application into a Servlet
2.5 environment. However, Servlet 3.0+ is strongly recommended and a prerequisite in Spring's test and mock packages for test setups in development environments.

Note

If you are a WebSphere 7 user, be sure to install the JPA 2.0 feature pack. On WebLogic 10.3.4 or higher, install the JPA 2.0 patch that comes with it. This turns both of those server generations into Spring 4 compatible deployment environments.

On a more forward-looking note, Spring Framework 4.0 supports the Java EE 7 level of applicable specifications now: in particular, JMS 2.0, JTA 1.2, JPA 2.1, Bean Validation 1.1, and JSR-236 Concurrency Utilities. As usual, this support focuses on individual use of those specifications, e.g. on Tomcat or in standalone environments. However, it works equally well when a Spring application is deployed to a Java EE 7 server.

Note that Hibernate 4.3 is a JPA 2.1 provider and therefore only supported as of Spring Framework 4.0. The same applies to Hibernate Validator 5.0 as a Bean Validation 1.1 provider. Neither of the two are officially supported with Spring Framework 3.2.

3.5 Groovy Bean Definition DSL
Beginning with Spring Framework 4.0, it is possible to define external bean configuration using a Groovy DSL. This is similar in concept to using XML bean definitions but allows for a more concise syntax. Using Groovy also allows you to easily embed bean definitions directly in your bootstrap code. For example:



For more information consult the GroovyBeanDefinitionReader javadocs.

3.6 Core Container Improvements
There have been several general improvements to the core container:



• Spring now treats generic types as a form of qualifier when injecting Beans. For example, if you are using a Spring Data Repository you can now easily inject a specific implementation: @Autowired Repository<Customer> customerRepository.

• If you use Spring's meta-annotation support, you can now develop custom annotations that expose specific attributes from the source annotation.

• Beans can now be ordered when they are autowired into lists and arrays. Both the @Order annotation and Ordered interface are supported.

• The @Lazy annotation can now be used on injection points, as well as on @Bean definitions.

• The @Description annotation has been introduced for developers using Java-based configuration.

• A generalized model for conditionally filtering beans has been added via the @Conditional annotation. This is similar to @Profile support but allows for user-defined strategies to be developed programmatically.

• CGLIB-based proxy classes no longer require a default constructor. Support is provided via the objenesis library which is repackaged inline and distributed as part of the Spring Framework. With this strategy, no constructor at all is being invoked for proxy instances anymore.

• There is managed time zone support across the framework now, e.g. on LocaleContext.

3.7 General Web Improvements

Deployment to Servlet 2.5 servers remains an option, but Spring Framework 4.0 is now focused primarily on Servlet 3.0+ environments. If you are using the Spring MVC Test Framework you will need to ensure that a Servlet 3.0 compatible JAR is in your test classpath.

In addition to the WebSocket support mentioned later, the following general improvements have been made to Spring's Web modules:

• You can use the new @RestController annotation with Spring MVC applications, removing the need to add @ResponseBody to each of your @RequestMapping methods.

• The AsyncRestTemplate class has been added, allowing non-blocking asynchronous support when developing REST clients.

• Spring now offers comprehensive timezone support when developing Spring MVC applications.

3.8 WebSocket, SockJS, and STOMP Messaging

A new spring-websocket module provides comprehensive support for WebSocket-based, two-way communication between client and server in web applications. It is compatible with JSR-356, the Java WebSocket API, and in addition provides SockJS-based fallback options (i.e. WebSocket emulation) for use in browsers that don't yet support the WebSocket protocol (e.g. Internet Explorer < 10).

A new spring-messaging module adds support for STOMP as the WebSocket sub-protocol to use in applications along with an annotation programming model for routing and processing STOMP messages from WebSocket clients. As a result an @Controller can now contain both @RequestMapping and
@MessageMapping methods for handling HTTP requests and messages from WebSocket-connected clients. The new spring-messaging module also contains key abstractions formerly from the Spring
















































